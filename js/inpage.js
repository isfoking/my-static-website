!function() {
    try {
        var e = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}
          , n = (new Error).stack;
        n && (e._sentryDebugIds = e._sentryDebugIds || {},
        e._sentryDebugIds[n] = "b4c893ec-9981-47f4-9ecb-d46d92fce589",
        e._sentryDebugIdIdentifier = "sentry-dbid-b4c893ec-9981-47f4-9ecb-d46d92fce589")
    } catch (e) {}
}();
var _global = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
_global.SENTRY_RELEASE = {
    id: "3.65.1"
},
(()=>{
    var inProgress, __webpack_modules__ = {
        93286: (__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{
            "use strict";
            __webpack_require__.r(__webpack_exports__),
            __webpack_require__.d(__webpack_exports__, {
                arrayify: ()=>arrayify,
                concat: ()=>concat,
                hexConcat: ()=>hexConcat,
                hexDataLength: ()=>hexDataLength,
                hexDataSlice: ()=>hexDataSlice,
                hexStripZeros: ()=>hexStripZeros,
                hexValue: ()=>hexValue,
                hexZeroPad: ()=>hexZeroPad,
                hexlify: ()=>hexlify,
                isBytes: ()=>isBytes,
                isBytesLike: ()=>isBytesLike,
                isHexString: ()=>isHexString,
                joinSignature: ()=>joinSignature,
                splitSignature: ()=>splitSignature,
                stripZeros: ()=>stripZeros,
                zeroPad: ()=>zeroPad
            });
            const logger = new (__webpack_require__(80711).Logger)("bytes/5.7.0");
            function isHexable(value) {
                return !!value.toHexString
            }
            function addSlice(array) {
                return array.slice || (array.slice = function() {
                    const args = Array.prototype.slice.call(arguments);
                    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)))
                }
                ),
                array
            }
            function isBytesLike(value) {
                return isHexString(value) && !(value.length % 2) || isBytes(value)
            }
            function isInteger(value) {
                return "number" == typeof value && value == value && value % 1 == 0
            }
            function isBytes(value) {
                if (null == value)
                    return !1;
                if (value.constructor === Uint8Array)
                    return !0;
                if ("string" == typeof value)
                    return !1;
                if (!isInteger(value.length) || value.length < 0)
                    return !1;
                for (let i = 0; i < value.length; i++) {
                    const v = value[i];
                    if (!isInteger(v) || v < 0 || v >= 256)
                        return !1
                }
                return !0
            }
            function arrayify(value, options) {
                if (options || (options = {}),
                "number" == typeof value) {
                    logger.checkSafeUint53(value, "invalid arrayify value");
                    const result = [];
                    for (; value; )
                        result.unshift(255 & value),
                        value = parseInt(String(value / 256));
                    return 0 === result.length && result.push(0),
                    addSlice(new Uint8Array(result))
                }
                if (options.allowMissingPrefix && "string" == typeof value && "0x" !== value.substring(0, 2) && (value = "0x" + value),
                isHexable(value) && (value = value.toHexString()),
                isHexString(value)) {
                    let hex = value.substring(2);
                    hex.length % 2 && ("left" === options.hexPad ? hex = "0" + hex : "right" === options.hexPad ? hex += "0" : logger.throwArgumentError("hex data is odd-length", "value", value));
                    const result = [];
                    for (let i = 0; i < hex.length; i += 2)
                        result.push(parseInt(hex.substring(i, i + 2), 16));
                    return addSlice(new Uint8Array(result))
                }
                return isBytes(value) ? addSlice(new Uint8Array(value)) : logger.throwArgumentError("invalid arrayify value", "value", value)
            }
            function concat(items) {
                const objects = items.map((item=>arrayify(item)))
                  , length = objects.reduce(((accum,item)=>accum + item.length), 0)
                  , result = new Uint8Array(length);
                return objects.reduce(((offset,object)=>(result.set(object, offset),
                offset + object.length)), 0),
                addSlice(result)
            }
            function stripZeros(value) {
                let result = arrayify(value);
                if (0 === result.length)
                    return result;
                let start = 0;
                for (; start < result.length && 0 === result[start]; )
                    start++;
                return start && (result = result.slice(start)),
                result
            }
            function zeroPad(value, length) {
                (value = arrayify(value)).length > length && logger.throwArgumentError("value out of range", "value", arguments[0]);
                const result = new Uint8Array(length);
                return result.set(value, length - value.length),
                addSlice(result)
            }
            function isHexString(value, length) {
                return !("string" != typeof value || !value.match(/^0x[0-9A-Fa-f]*$/)) && (!length || value.length === 2 + 2 * length)
            }
            const HexCharacters = "0123456789abcdef";
            function hexlify(value, options) {
                if (options || (options = {}),
                "number" == typeof value) {
                    logger.checkSafeUint53(value, "invalid hexlify value");
                    let hex = "";
                    for (; value; )
                        hex = HexCharacters[15 & value] + hex,
                        value = Math.floor(value / 16);
                    return hex.length ? (hex.length % 2 && (hex = "0" + hex),
                    "0x" + hex) : "0x00"
                }
                if ("bigint" == typeof value)
                    return (value = value.toString(16)).length % 2 ? "0x0" + value : "0x" + value;
                if (options.allowMissingPrefix && "string" == typeof value && "0x" !== value.substring(0, 2) && (value = "0x" + value),
                isHexable(value))
                    return value.toHexString();
                if (isHexString(value))
                    return value.length % 2 && ("left" === options.hexPad ? value = "0x0" + value.substring(2) : "right" === options.hexPad ? value += "0" : logger.throwArgumentError("hex data is odd-length", "value", value)),
                    value.toLowerCase();
                if (isBytes(value)) {
                    let result = "0x";
                    for (let i = 0; i < value.length; i++) {
                        let v = value[i];
                        result += HexCharacters[(240 & v) >> 4] + HexCharacters[15 & v]
                    }
                    return result
                }
                return logger.throwArgumentError("invalid hexlify value", "value", value)
            }
            function hexDataLength(data) {
                if ("string" != typeof data)
                    data = hexlify(data);
                else if (!isHexString(data) || data.length % 2)
                    return null;
                return (data.length - 2) / 2
            }
            function hexDataSlice(data, offset, endOffset) {
                return "string" != typeof data ? data = hexlify(data) : (!isHexString(data) || data.length % 2) && logger.throwArgumentError("invalid hexData", "value", data),
                offset = 2 + 2 * offset,
                null != endOffset ? "0x" + data.substring(offset, 2 + 2 * endOffset) : "0x" + data.substring(offset)
            }
            function hexConcat(items) {
                let result = "0x";
                return items.forEach((item=>{
                    result += hexlify(item).substring(2)
                }
                )),
                result
            }
            function hexValue(value) {
                const trimmed = hexStripZeros(hexlify(value, {
                    hexPad: "left"
                }));
                return "0x" === trimmed ? "0x0" : trimmed
            }
            function hexStripZeros(value) {
                "string" != typeof value && (value = hexlify(value)),
                isHexString(value) || logger.throwArgumentError("invalid hex string", "value", value),
                value = value.substring(2);
                let offset = 0;
                for (; offset < value.length && "0" === value[offset]; )
                    offset++;
                return "0x" + value.substring(offset)
            }
            function hexZeroPad(value, length) {
                for ("string" != typeof value ? value = hexlify(value) : isHexString(value) || logger.throwArgumentError("invalid hex string", "value", value),
                value.length > 2 * length + 2 && logger.throwArgumentError("value out of range", "value", arguments[1]); value.length < 2 * length + 2; )
                    value = "0x0" + value.substring(2);
                return value
            }
            function splitSignature(signature) {
                const result = {
                    r: "0x",
                    s: "0x",
                    _vs: "0x",
                    recoveryParam: 0,
                    v: 0,
                    yParityAndS: "0x",
                    compact: "0x"
                };
                if (isBytesLike(signature)) {
                    let bytes = arrayify(signature);
                    64 === bytes.length ? (result.v = 27 + (bytes[32] >> 7),
                    bytes[32] &= 127,
                    result.r = hexlify(bytes.slice(0, 32)),
                    result.s = hexlify(bytes.slice(32, 64))) : 65 === bytes.length ? (result.r = hexlify(bytes.slice(0, 32)),
                    result.s = hexlify(bytes.slice(32, 64)),
                    result.v = bytes[64]) : logger.throwArgumentError("invalid signature string", "signature", signature),
                    result.v < 27 && (0 === result.v || 1 === result.v ? result.v += 27 : logger.throwArgumentError("signature invalid v byte", "signature", signature)),
                    result.recoveryParam = 1 - result.v % 2,
                    result.recoveryParam && (bytes[32] |= 128),
                    result._vs = hexlify(bytes.slice(32, 64))
                } else {
                    if (result.r = signature.r,
                    result.s = signature.s,
                    result.v = signature.v,
                    result.recoveryParam = signature.recoveryParam,
                    result._vs = signature._vs,
                    null != result._vs) {
                        const vs = zeroPad(arrayify(result._vs), 32);
                        result._vs = hexlify(vs);
                        const recoveryParam = vs[0] >= 128 ? 1 : 0;
                        null == result.recoveryParam ? result.recoveryParam = recoveryParam : result.recoveryParam !== recoveryParam && logger.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature),
                        vs[0] &= 127;
                        const s = hexlify(vs);
                        null == result.s ? result.s = s : result.s !== s && logger.throwArgumentError("signature v mismatch _vs", "signature", signature)
                    }
                    if (null == result.recoveryParam)
                        null == result.v ? logger.throwArgumentError("signature missing v and recoveryParam", "signature", signature) : 0 === result.v || 1 === result.v ? result.recoveryParam = result.v : result.recoveryParam = 1 - result.v % 2;
                    else if (null == result.v)
                        result.v = 27 + result.recoveryParam;
                    else {
                        const recId = 0 === result.v || 1 === result.v ? result.v : 1 - result.v % 2;
                        result.recoveryParam !== recId && logger.throwArgumentError("signature recoveryParam mismatch v", "signature", signature)
                    }
                    null != result.r && isHexString(result.r) ? result.r = hexZeroPad(result.r, 32) : logger.throwArgumentError("signature missing or invalid r", "signature", signature),
                    null != result.s && isHexString(result.s) ? result.s = hexZeroPad(result.s, 32) : logger.throwArgumentError("signature missing or invalid s", "signature", signature);
                    const vs = arrayify(result.s);
                    vs[0] >= 128 && logger.throwArgumentError("signature s out of range", "signature", signature),
                    result.recoveryParam && (vs[0] |= 128);
                    const _vs = hexlify(vs);
                    result._vs && (isHexString(result._vs) || logger.throwArgumentError("signature invalid _vs", "signature", signature),
                    result._vs = hexZeroPad(result._vs, 32)),
                    null == result._vs ? result._vs = _vs : result._vs !== _vs && logger.throwArgumentError("signature _vs mismatch v and s", "signature", signature)
                }
                return result.yParityAndS = result._vs,
                result.compact = result.r + result.yParityAndS.substring(2),
                result
            }
            function joinSignature(signature) {
                return hexlify(concat([(signature = splitSignature(signature)).r, signature.s, signature.recoveryParam ? "0x1c" : "0x1b"]))
            }
        }
        ,
        80711: (__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{
            "use strict";
            __webpack_require__.d(__webpack_exports__, {
                Logger: ()=>Logger
            });
            let _permanentCensorErrors = !1
              , _censorErrors = !1;
            const LogLevels = {
                debug: 1,
                default: 2,
                info: 2,
                warning: 3,
                error: 4,
                off: 5
            };
            let _logLevel = LogLevels.default
              , _globalLogger = null;
            const _normalizeError = function() {
                try {
                    const missing = [];
                    if (["NFD", "NFC", "NFKD", "NFKC"].forEach((form=>{
                        try {
                            if ("test" !== "test".normalize(form))
                                throw new Error("bad normalize")
                        } catch (error) {
                            missing.push(form)
                        }
                    }
                    )),
                    missing.length)
                        throw new Error("missing " + missing.join(", "));
                    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769))
                        throw new Error("broken implementation")
                } catch (error) {
                    return error.message
                }
                return null
            }();
            var LogLevel, ErrorCode;
            !function(LogLevel) {
                LogLevel.DEBUG = "DEBUG",
                LogLevel.INFO = "INFO",
                LogLevel.WARNING = "WARNING",
                LogLevel.ERROR = "ERROR",
                LogLevel.OFF = "OFF"
            }(LogLevel || (LogLevel = {})),
            function(ErrorCode) {
                ErrorCode.UNKNOWN_ERROR = "UNKNOWN_ERROR",
                ErrorCode.NOT_IMPLEMENTED = "NOT_IMPLEMENTED",
                ErrorCode.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION",
                ErrorCode.NETWORK_ERROR = "NETWORK_ERROR",
                ErrorCode.SERVER_ERROR = "SERVER_ERROR",
                ErrorCode.TIMEOUT = "TIMEOUT",
                ErrorCode.BUFFER_OVERRUN = "BUFFER_OVERRUN",
                ErrorCode.NUMERIC_FAULT = "NUMERIC_FAULT",
                ErrorCode.MISSING_NEW = "MISSING_NEW",
                ErrorCode.INVALID_ARGUMENT = "INVALID_ARGUMENT",
                ErrorCode.MISSING_ARGUMENT = "MISSING_ARGUMENT",
                ErrorCode.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT",
                ErrorCode.CALL_EXCEPTION = "CALL_EXCEPTION",
                ErrorCode.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS",
                ErrorCode.NONCE_EXPIRED = "NONCE_EXPIRED",
                ErrorCode.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED",
                ErrorCode.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT",
                ErrorCode.TRANSACTION_REPLACED = "TRANSACTION_REPLACED",
                ErrorCode.ACTION_REJECTED = "ACTION_REJECTED"
            }(ErrorCode || (ErrorCode = {}));
            const HEX = "0123456789abcdef";
            class Logger {
                constructor(version) {
                    Object.defineProperty(this, "version", {
                        enumerable: !0,
                        value: version,
                        writable: !1
                    })
                }
                _log(logLevel, args) {
                    const level = logLevel.toLowerCase();
                    null == LogLevels[level] && this.throwArgumentError("invalid log level name", "logLevel", logLevel)
                }
                debug(...args) {
                    this._log(Logger.levels.DEBUG, args)
                }
                info(...args) {
                    this._log(Logger.levels.INFO, args)
                }
                warn(...args) {
                    this._log(Logger.levels.WARNING, args)
                }
                makeError(message, code, params) {
                    if (_censorErrors)
                        return this.makeError("censored error", code, {});
                    code || (code = Logger.errors.UNKNOWN_ERROR),
                    params || (params = {});
                    const messageDetails = [];
                    Object.keys(params).forEach((key=>{
                        const value = params[key];
                        try {
                            if (value instanceof Uint8Array) {
                                let hex = "";
                                for (let i = 0; i < value.length; i++)
                                    hex += HEX[value[i] >> 4],
                                    hex += HEX[15 & value[i]];
                                messageDetails.push(key + "=Uint8Array(0x" + hex + ")")
                            } else
                                messageDetails.push(key + "=" + JSON.stringify(value))
                        } catch (error) {
                            messageDetails.push(key + "=" + JSON.stringify(params[key].toString()))
                        }
                    }
                    )),
                    messageDetails.push(`code=${code}`),
                    messageDetails.push(`version=${this.version}`);
                    const reason = message;
                    let url = "";
                    switch (code) {
                    case ErrorCode.NUMERIC_FAULT:
                        {
                            url = "NUMERIC_FAULT";
                            const fault = message;
                            switch (fault) {
                            case "overflow":
                            case "underflow":
                            case "division-by-zero":
                                url += "-" + fault;
                                break;
                            case "negative-power":
                            case "negative-width":
                                url += "-unsupported";
                                break;
                            case "unbound-bitwise-result":
                                url += "-unbound-result"
                            }
                            break
                        }
                    case ErrorCode.CALL_EXCEPTION:
                    case ErrorCode.INSUFFICIENT_FUNDS:
                    case ErrorCode.MISSING_NEW:
                    case ErrorCode.NONCE_EXPIRED:
                    case ErrorCode.REPLACEMENT_UNDERPRICED:
                    case ErrorCode.TRANSACTION_REPLACED:
                    case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
                        url = code
                    }
                    url && (message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]"),
                    messageDetails.length && (message += " (" + messageDetails.join(", ") + ")");
                    const error = new Error(message);
                    return error.reason = reason,
                    error.code = code,
                    Object.keys(params).forEach((function(key) {
                        error[key] = params[key]
                    }
                    )),
                    error
                }
                throwError(message, code, params) {
                    throw this.makeError(message, code, params)
                }
                throwArgumentError(message, name, value) {
                    return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
                        argument: name,
                        value
                    })
                }
                assert(condition, message, code, params) {
                    condition || this.throwError(message, code, params)
                }
                assertArgument(condition, message, name, value) {
                    condition || this.throwArgumentError(message, name, value)
                }
                checkNormalize(message) {
                    null == message && (message = "platform missing String.prototype.normalize"),
                    _normalizeError && this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
                        operation: "String.prototype.normalize",
                        form: _normalizeError
                    })
                }
                checkSafeUint53(value, message) {
                    "number" == typeof value && (null == message && (message = "value not safe"),
                    (value < 0 || value >= 9007199254740991) && this.throwError(message, Logger.errors.NUMERIC_FAULT, {
                        operation: "checkSafeInteger",
                        fault: "out-of-safe-range",
                        value
                    }),
                    value % 1 && this.throwError(message, Logger.errors.NUMERIC_FAULT, {
                        operation: "checkSafeInteger",
                        fault: "non-integer",
                        value
                    }))
                }
                checkArgumentCount(count, expectedCount, message) {
                    message = message ? ": " + message : "",
                    count < expectedCount && this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
                        count,
                        expectedCount
                    }),
                    count > expectedCount && this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
                        count,
                        expectedCount
                    })
                }
                checkNew(target, kind) {
                    target !== Object && null != target || this.throwError("missing new", Logger.errors.MISSING_NEW, {
                        name: kind.name
                    })
                }
                checkAbstract(target, kind) {
                    target === kind ? this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, {
                        name: target.name,
                        operation: "new"
                    }) : target !== Object && null != target || this.throwError("missing new", Logger.errors.MISSING_NEW, {
                        name: kind.name
                    })
                }
                static globalLogger() {
                    return _globalLogger || (_globalLogger = new Logger("logger/5.7.0")),
                    _globalLogger
                }
                static setCensorship(censorship, permanent) {
                    if (!censorship && permanent && this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
                        operation: "setCensorship"
                    }),
                    _permanentCensorErrors) {
                        if (!censorship)
                            return;
                        this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
                            operation: "setCensorship"
                        })
                    }
                    _censorErrors = !!censorship,
                    _permanentCensorErrors = !!permanent
                }
                static setLogLevel(logLevel) {
                    const level = LogLevels[logLevel.toLowerCase()];
                    null != level ? _logLevel = level : Logger.globalLogger().warn("invalid log level - " + logLevel)
                }
                static from(version) {
                    return new Logger(version)
                }
            }
            Logger.errors = ErrorCode,
            Logger.levels = LogLevel
        }
        ,
        79082: (__unused_webpack_module,exports,__webpack_require__)=>{
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.createCurve = exports.getHash = void 0;
            const hmac_1 = __webpack_require__(41128)
              , utils_1 = __webpack_require__(31717)
              , weierstrass_js_1 = __webpack_require__(96551);
            function getHash(hash) {
                return {
                    hash,
                    hmac: (key,...msgs)=>(0,
                    hmac_1.hmac)(hash, key, (0,
                    utils_1.concatBytes)(...msgs)),
                    randomBytes: utils_1.randomBytes
                }
            }
            exports.getHash = getHash,
            exports.createCurve = function(curveDef, defHash) {
                const create = hash=>(0,
                weierstrass_js_1.weierstrass)({
                    ...curveDef,
                    ...getHash(hash)
                });
                return Object.freeze({
                    ...create(defHash),
                    create
                })
            }
        }
        ,
        81525: (__unused_webpack_module,exports,__webpack_require__)=>{
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.validateBasic = exports.wNAF = void 0;
            const modular_js_1 = __webpack_require__(94632)
              , utils_js_1 = __webpack_require__(40219)
              , _0n = BigInt(0)
              , _1n = BigInt(1);
            exports.wNAF = function(c, bits) {
                const constTimeNegate = (condition,item)=>{
                    const neg = item.negate();
                    return condition ? neg : item
                }
                  , opts = W=>({
                    windows: Math.ceil(bits / W) + 1,
                    windowSize: 2 ** (W - 1)
                });
                return {
                    constTimeNegate,
                    unsafeLadder(elm, n) {
                        let p = c.ZERO
                          , d = elm;
                        for (; n > _0n; )
                            n & _1n && (p = p.add(d)),
                            d = d.double(),
                            n >>= _1n;
                        return p
                    },
                    precomputeWindow(elm, W) {
                        const {windows, windowSize} = opts(W)
                          , points = [];
                        let p = elm
                          , base = p;
                        for (let window = 0; window < windows; window++) {
                            base = p,
                            points.push(base);
                            for (let i = 1; i < windowSize; i++)
                                base = base.add(p),
                                points.push(base);
                            p = base.double()
                        }
                        return points
                    },
                    wNAF(W, precomputes, n) {
                        const {windows, windowSize} = opts(W);
                        let p = c.ZERO
                          , f = c.BASE;
                        const mask = BigInt(2 ** W - 1)
                          , maxNumber = 2 ** W
                          , shiftBy = BigInt(W);
                        for (let window = 0; window < windows; window++) {
                            const offset = window * windowSize;
                            let wbits = Number(n & mask);
                            n >>= shiftBy,
                            wbits > windowSize && (wbits -= maxNumber,
                            n += _1n);
                            const offset1 = offset
                              , offset2 = offset + Math.abs(wbits) - 1
                              , cond1 = window % 2 != 0
                              , cond2 = wbits < 0;
                            0 === wbits ? f = f.add(constTimeNegate(cond1, precomputes[offset1])) : p = p.add(constTimeNegate(cond2, precomputes[offset2]))
                        }
                        return {
                            p,
                            f
                        }
                    },
                    wNAFCached(P, precomputesMap, n, transform) {
                        const W = P._WINDOW_SIZE || 1;
                        let comp = precomputesMap.get(P);
                        return comp || (comp = this.precomputeWindow(P, W),
                        1 !== W && precomputesMap.set(P, transform(comp))),
                        this.wNAF(W, comp, n)
                    }
                }
            }
            ,
            exports.validateBasic = function(curve) {
                return (0,
                modular_js_1.validateField)(curve.Fp),
                (0,
                utils_js_1.validateObject)(curve, {
                    n: "bigint",
                    h: "bigint",
                    Gx: "field",
                    Gy: "field"
                }, {
                    nBitLength: "isSafeInteger",
                    nByteLength: "isSafeInteger"
                }),
                Object.freeze({
                    ...(0,
                    modular_js_1.nLength)(curve.n, curve.nBitLength),
                    ...curve,
                    p: curve.Fp.ORDER
                })
            }
        }
        ,
        94632: (__unused_webpack_module,exports,__webpack_require__)=>{
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.mapHashToField = exports.getMinHashLength = exports.getFieldBytesLength = exports.hashToPrivateScalar = exports.FpSqrtEven = exports.FpSqrtOdd = exports.Field = exports.nLength = exports.FpIsSquare = exports.FpDiv = exports.FpInvertBatch = exports.FpPow = exports.validateField = exports.isNegativeLE = exports.FpSqrt = exports.tonelliShanks = exports.invert = exports.pow2 = exports.pow = exports.mod = void 0;
            const utils_js_1 = __webpack_require__(40219)
              , _0n = BigInt(0)
              , _1n = BigInt(1)
              , _2n = BigInt(2)
              , _3n = BigInt(3)
              , _4n = BigInt(4)
              , _5n = BigInt(5)
              , _8n = BigInt(8);
            BigInt(9),
            BigInt(16);
            function mod(a, b) {
                const result = a % b;
                return result >= _0n ? result : b + result
            }
            function pow(num, power, modulo) {
                if (modulo <= _0n || power < _0n)
                    throw new Error("Expected power/modulo > 0");
                if (modulo === _1n)
                    return _0n;
                let res = _1n;
                for (; power > _0n; )
                    power & _1n && (res = res * num % modulo),
                    num = num * num % modulo,
                    power >>= _1n;
                return res
            }
            function invert(number, modulo) {
                if (number === _0n || modulo <= _0n)
                    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
                let a = mod(number, modulo)
                  , b = modulo
                  , x = _0n
                  , y = _1n
                  , u = _1n
                  , v = _0n;
                for (; a !== _0n; ) {
                    const q = b / a
                      , r = b % a
                      , m = x - u * q
                      , n = y - v * q;
                    b = a,
                    a = r,
                    x = u,
                    y = v,
                    u = m,
                    v = n
                }
                if (b !== _1n)
                    throw new Error("invert: does not exist");
                return mod(x, modulo)
            }
            function tonelliShanks(P) {
                const legendreC = (P - _1n) / _2n;
                let Q, S, Z;
                for (Q = P - _1n,
                S = 0; Q % _2n === _0n; Q /= _2n,
                S++)
                    ;
                for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)
                    ;
                if (1 === S) {
                    const p1div4 = (P + _1n) / _4n;
                    return function(Fp, n) {
                        const root = Fp.pow(n, p1div4);
                        if (!Fp.eql(Fp.sqr(root), n))
                            throw new Error("Cannot find square root");
                        return root
                    }
                }
                const Q1div2 = (Q + _1n) / _2n;
                return function(Fp, n) {
                    if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
                        throw new Error("Cannot find square root");
                    let r = S
                      , g = Fp.pow(Fp.mul(Fp.ONE, Z), Q)
                      , x = Fp.pow(n, Q1div2)
                      , b = Fp.pow(n, Q);
                    for (; !Fp.eql(b, Fp.ONE); ) {
                        if (Fp.eql(b, Fp.ZERO))
                            return Fp.ZERO;
                        let m = 1;
                        for (let t2 = Fp.sqr(b); m < r && !Fp.eql(t2, Fp.ONE); m++)
                            t2 = Fp.sqr(t2);
                        const ge = Fp.pow(g, _1n << BigInt(r - m - 1));
                        g = Fp.sqr(ge),
                        x = Fp.mul(x, ge),
                        b = Fp.mul(b, g),
                        r = m
                    }
                    return x
                }
            }
            function FpSqrt(P) {
                if (P % _4n === _3n) {
                    const p1div4 = (P + _1n) / _4n;
                    return function(Fp, n) {
                        const root = Fp.pow(n, p1div4);
                        if (!Fp.eql(Fp.sqr(root), n))
                            throw new Error("Cannot find square root");
                        return root
                    }
                }
                if (P % _8n === _5n) {
                    const c1 = (P - _5n) / _8n;
                    return function(Fp, n) {
                        const n2 = Fp.mul(n, _2n)
                          , v = Fp.pow(n2, c1)
                          , nv = Fp.mul(n, v)
                          , i = Fp.mul(Fp.mul(nv, _2n), v)
                          , root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
                        if (!Fp.eql(Fp.sqr(root), n))
                            throw new Error("Cannot find square root");
                        return root
                    }
                }
                return tonelliShanks(P)
            }
            exports.mod = mod,
            exports.pow = pow,
            exports.pow2 = function(x, power, modulo) {
                let res = x;
                for (; power-- > _0n; )
                    res *= res,
                    res %= modulo;
                return res
            }
            ,
            exports.invert = invert,
            exports.tonelliShanks = tonelliShanks,
            exports.FpSqrt = FpSqrt;
            exports.isNegativeLE = (num,modulo)=>(mod(num, modulo) & _1n) === _1n;
            const FIELD_FIELDS = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
            function FpPow(f, num, power) {
                if (power < _0n)
                    throw new Error("Expected power > 0");
                if (power === _0n)
                    return f.ONE;
                if (power === _1n)
                    return num;
                let p = f.ONE
                  , d = num;
                for (; power > _0n; )
                    power & _1n && (p = f.mul(p, d)),
                    d = f.sqr(d),
                    power >>= _1n;
                return p
            }
            function FpInvertBatch(f, nums) {
                const tmp = new Array(nums.length)
                  , lastMultiplied = nums.reduce(((acc,num,i)=>f.is0(num) ? acc : (tmp[i] = acc,
                f.mul(acc, num))), f.ONE)
                  , inverted = f.inv(lastMultiplied);
                return nums.reduceRight(((acc,num,i)=>f.is0(num) ? acc : (tmp[i] = f.mul(acc, tmp[i]),
                f.mul(acc, num))), inverted),
                tmp
            }
            function nLength(n, nBitLength) {
                const _nBitLength = void 0 !== nBitLength ? nBitLength : n.toString(2).length;
                return {
                    nBitLength: _nBitLength,
                    nByteLength: Math.ceil(_nBitLength / 8)
                }
            }
            function getFieldBytesLength(fieldOrder) {
                if ("bigint" != typeof fieldOrder)
                    throw new Error("field order must be bigint");
                const bitLength = fieldOrder.toString(2).length;
                return Math.ceil(bitLength / 8)
            }
            function getMinHashLength(fieldOrder) {
                const length = getFieldBytesLength(fieldOrder);
                return length + Math.ceil(length / 2)
            }
            exports.validateField = function(field) {
                const opts = FIELD_FIELDS.reduce(((map,val)=>(map[val] = "function",
                map)), {
                    ORDER: "bigint",
                    MASK: "bigint",
                    BYTES: "isSafeInteger",
                    BITS: "isSafeInteger"
                });
                return (0,
                utils_js_1.validateObject)(field, opts)
            }
            ,
            exports.FpPow = FpPow,
            exports.FpInvertBatch = FpInvertBatch,
            exports.FpDiv = function(f, lhs, rhs) {
                return f.mul(lhs, "bigint" == typeof rhs ? invert(rhs, f.ORDER) : f.inv(rhs))
            }
            ,
            exports.FpIsSquare = function(f) {
                const legendreConst = (f.ORDER - _1n) / _2n;
                return x=>{
                    const p = f.pow(x, legendreConst);
                    return f.eql(p, f.ZERO) || f.eql(p, f.ONE)
                }
            }
            ,
            exports.nLength = nLength,
            exports.Field = function(ORDER, bitLen, isLE=!1, redef={}) {
                if (ORDER <= _0n)
                    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
                const {nBitLength: BITS, nByteLength: BYTES} = nLength(ORDER, bitLen);
                if (BYTES > 2048)
                    throw new Error("Field lengths over 2048 bytes are not supported");
                const sqrtP = FpSqrt(ORDER)
                  , f = Object.freeze({
                    ORDER,
                    BITS,
                    BYTES,
                    MASK: (0,
                    utils_js_1.bitMask)(BITS),
                    ZERO: _0n,
                    ONE: _1n,
                    create: num=>mod(num, ORDER),
                    isValid: num=>{
                        if ("bigint" != typeof num)
                            throw new Error("Invalid field element: expected bigint, got " + typeof num);
                        return _0n <= num && num < ORDER
                    }
                    ,
                    is0: num=>num === _0n,
                    isOdd: num=>(num & _1n) === _1n,
                    neg: num=>mod(-num, ORDER),
                    eql: (lhs,rhs)=>lhs === rhs,
                    sqr: num=>mod(num * num, ORDER),
                    add: (lhs,rhs)=>mod(lhs + rhs, ORDER),
                    sub: (lhs,rhs)=>mod(lhs - rhs, ORDER),
                    mul: (lhs,rhs)=>mod(lhs * rhs, ORDER),
                    pow: (num,power)=>FpPow(f, num, power),
                    div: (lhs,rhs)=>mod(lhs * invert(rhs, ORDER), ORDER),
                    sqrN: num=>num * num,
                    addN: (lhs,rhs)=>lhs + rhs,
                    subN: (lhs,rhs)=>lhs - rhs,
                    mulN: (lhs,rhs)=>lhs * rhs,
                    inv: num=>invert(num, ORDER),
                    sqrt: redef.sqrt || (n=>sqrtP(f, n)),
                    invertBatch: lst=>FpInvertBatch(f, lst),
                    cmov: (a,b,c)=>c ? b : a,
                    toBytes: num=>isLE ? (0,
                    utils_js_1.numberToBytesLE)(num, BYTES) : (0,
                    utils_js_1.numberToBytesBE)(num, BYTES),
                    fromBytes: bytes=>{
                        if (bytes.length !== BYTES)
                            throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
                        return isLE ? (0,
                        utils_js_1.bytesToNumberLE)(bytes) : (0,
                        utils_js_1.bytesToNumberBE)(bytes)
                    }
                });
                return Object.freeze(f)
            }
            ,
            exports.FpSqrtOdd = function(Fp, elm) {
                if (!Fp.isOdd)
                    throw new Error("Field doesn't have isOdd");
                const root = Fp.sqrt(elm);
                return Fp.isOdd(root) ? root : Fp.neg(root)
            }
            ,
            exports.FpSqrtEven = function(Fp, elm) {
                if (!Fp.isOdd)
                    throw new Error("Field doesn't have isOdd");
                const root = Fp.sqrt(elm);
                return Fp.isOdd(root) ? Fp.neg(root) : root
            }
            ,
            exports.hashToPrivateScalar = function(hash, groupOrder, isLE=!1) {
                const hashLen = (hash = (0,
                utils_js_1.ensureBytes)("privateHash", hash)).length
                  , minLen = nLength(groupOrder).nByteLength + 8;
                if (minLen < 24 || hashLen < minLen || hashLen > 1024)
                    throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
                return mod(isLE ? (0,
                utils_js_1.bytesToNumberLE)(hash) : (0,
                utils_js_1.bytesToNumberBE)(hash), groupOrder - _1n) + _1n
            }
            ,
            exports.getFieldBytesLength = getFieldBytesLength,
            exports.getMinHashLength = getMinHashLength,
            exports.mapHashToField = function(key, fieldOrder, isLE=!1) {
                const len = key.length
                  , fieldLen = getFieldBytesLength(fieldOrder)
                  , minLen = getMinHashLength(fieldOrder);
                if (len < 16 || len < minLen || len > 1024)
                    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
                const reduced = mod(isLE ? (0,
                utils_js_1.bytesToNumberBE)(key) : (0,
                utils_js_1.bytesToNumberLE)(key), fieldOrder - _1n) + _1n;
                return isLE ? (0,
                utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0,
                utils_js_1.numberToBytesBE)(reduced, fieldLen)
            }
        }
        ,
        33192: (__unused_webpack_module,exports,__webpack_require__)=>{
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.poseidon = exports.splitConstants = exports.validateOpts = void 0;
            const modular_js_1 = __webpack_require__(94632);
            function validateOpts(opts) {
                const {Fp, mds, reversePartialPowIdx: rev, roundConstants: rc} = opts
                  , {roundsFull, roundsPartial, sboxPower, t} = opts;
                (0,
                modular_js_1.validateField)(Fp);
                for (const i of ["t", "roundsFull", "roundsPartial"])
                    if ("number" != typeof opts[i] || !Number.isSafeInteger(opts[i]))
                        throw new Error(`Poseidon: invalid param ${i}=${opts[i]} (${typeof opts[i]})`);
                if (!Array.isArray(mds) || mds.length !== t)
                    throw new Error("Poseidon: wrong MDS matrix");
                const _mds = mds.map((mdsRow=>{
                    if (!Array.isArray(mdsRow) || mdsRow.length !== t)
                        throw new Error(`Poseidon MDS matrix row: ${mdsRow}`);
                    return mdsRow.map((i=>{
                        if ("bigint" != typeof i)
                            throw new Error(`Poseidon MDS matrix value=${i}`);
                        return Fp.create(i)
                    }
                    ))
                }
                ));
                if (void 0 !== rev && "boolean" != typeof rev)
                    throw new Error(`Poseidon: invalid param reversePartialPowIdx=${rev}`);
                if (roundsFull % 2 != 0)
                    throw new Error(`Poseidon roundsFull is not even: ${roundsFull}`);
                const rounds = roundsFull + roundsPartial;
                if (!Array.isArray(rc) || rc.length !== rounds)
                    throw new Error("Poseidon: wrong round constants");
                const roundConstants = rc.map((rc=>{
                    if (!Array.isArray(rc) || rc.length !== t)
                        throw new Error(`Poseidon wrong round constants: ${rc}`);
                    return rc.map((i=>{
                        if ("bigint" != typeof i || !Fp.isValid(i))
                            throw new Error(`Poseidon wrong round constant=${i}`);
                        return Fp.create(i)
                    }
                    ))
                }
                ));
                if (!sboxPower || ![3, 5, 7].includes(sboxPower))
                    throw new Error(`Poseidon wrong sboxPower=${sboxPower}`);
                const _sboxPower = BigInt(sboxPower);
                let sboxFn = n=>(0,
                modular_js_1.FpPow)(Fp, n, _sboxPower);
                return 3 === sboxPower ? sboxFn = n=>Fp.mul(Fp.sqrN(n), n) : 5 === sboxPower && (sboxFn = n=>Fp.mul(Fp.sqrN(Fp.sqrN(n)), n)),
                Object.freeze({
                    ...opts,
                    rounds,
                    sboxFn,
                    roundConstants,
                    mds: _mds
                })
            }
            exports.validateOpts = validateOpts,
            exports.splitConstants = function(rc, t) {
                if ("number" != typeof t)
                    throw new Error("poseidonSplitConstants: wrong t");
                if (!Array.isArray(rc) || rc.length % t)
                    throw new Error("poseidonSplitConstants: wrong rc");
                const res = [];
                let tmp = [];
                for (let i = 0; i < rc.length; i++)
                    tmp.push(rc[i]),
                    tmp.length === t && (res.push(tmp),
                    tmp = []);
                return res
            }
            ,
            exports.poseidon = function(opts) {
                const _opts = validateOpts(opts)
                  , {Fp, mds, roundConstants, rounds, roundsPartial, sboxFn, t} = _opts
                  , halfRoundsFull = _opts.roundsFull / 2
                  , partialIdx = _opts.reversePartialPowIdx ? t - 1 : 0
                  , poseidonRound = (values,isFull,idx)=>(values = values.map(((i,j)=>Fp.add(i, roundConstants[idx][j]))),
                isFull ? values = values.map((i=>sboxFn(i))) : values[partialIdx] = sboxFn(values[partialIdx]),
                values = mds.map((i=>i.reduce(((acc,i,j)=>Fp.add(acc, Fp.mulN(i, values[j]))), Fp.ZERO))))
                  , poseidonHash = function(values) {
                    if (!Array.isArray(values) || values.length !== t)
                        throw new Error(`Poseidon: wrong values (expected array of bigints with length ${t})`);
                    values = values.map((i=>{
                        if ("bigint" != typeof i)
                            throw new Error(`Poseidon: wrong value=${i} (${typeof i})`);
                        return Fp.create(i)
                    }
                    ));
                    let round = 0;
                    for (let i = 0; i < halfRoundsFull; i++)
                        values = poseidonRound(values, !0, round++);
                    for (let i = 0; i < roundsPartial; i++)
                        values = poseidonRound(values, !1, round++);
                    for (let i = 0; i < halfRoundsFull; i++)
                        values = poseidonRound(values, !0, round++);
                    if (round !== rounds)
                        throw new Error(`Poseidon: wrong number of rounds: last round=${round}, total=${rounds}`);
                    return values
                };
                return poseidonHash.roundConstants = roundConstants,
                poseidonHash
            }
        }
        ,
        40219: (__unused_webpack_module,exports)=>{
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.validateObject = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.utf8ToBytes = exports.equalBytes = exports.concatBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToBytes = exports.hexToNumber = exports.numberToHexUnpadded = exports.bytesToHex = exports.isBytes = void 0;
            const _0n = BigInt(0)
              , _1n = BigInt(1)
              , _2n = BigInt(2);
            function isBytes(a) {
                return a instanceof Uint8Array || null != a && "object" == typeof a && "Uint8Array" === a.constructor.name
            }
            exports.isBytes = isBytes;
            const hexes = Array.from({
                length: 256
            }, ((_,i)=>i.toString(16).padStart(2, "0")));
            function bytesToHex(bytes) {
                if (!isBytes(bytes))
                    throw new Error("Uint8Array expected");
                let hex = "";
                for (let i = 0; i < bytes.length; i++)
                    hex += hexes[bytes[i]];
                return hex
            }
            function numberToHexUnpadded(num) {
                const hex = num.toString(16);
                return 1 & hex.length ? `0${hex}` : hex
            }
            function hexToNumber(hex) {
                if ("string" != typeof hex)
                    throw new Error("hex string expected, got " + typeof hex);
                return BigInt("" === hex ? "0" : `0x${hex}`)
            }
            exports.bytesToHex = bytesToHex,
            exports.numberToHexUnpadded = numberToHexUnpadded,
            exports.hexToNumber = hexToNumber;
            const asciis = {
                _0: 48,
                _9: 57,
                _A: 65,
                _F: 70,
                _a: 97,
                _f: 102
            };
            function asciiToBase16(char) {
                return char >= asciis._0 && char <= asciis._9 ? char - asciis._0 : char >= asciis._A && char <= asciis._F ? char - (asciis._A - 10) : char >= asciis._a && char <= asciis._f ? char - (asciis._a - 10) : void 0
            }
            function hexToBytes(hex) {
                if ("string" != typeof hex)
                    throw new Error("hex string expected, got " + typeof hex);
                const hl = hex.length
                  , al = hl / 2;
                if (hl % 2)
                    throw new Error("padded hex string expected, got unpadded hex of length " + hl);
                const array = new Uint8Array(al);
                for (let ai = 0, hi = 0; ai < al; ai++,
                hi += 2) {
                    const n1 = asciiToBase16(hex.charCodeAt(hi))
                      , n2 = asciiToBase16(hex.charCodeAt(hi + 1));
                    if (void 0 === n1 || void 0 === n2) {
                        const char = hex[hi] + hex[hi + 1];
                        throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi)
                    }
                    array[ai] = 16 * n1 + n2
                }
                return array
            }
            function numberToBytesBE(n, len) {
                return hexToBytes(n.toString(16).padStart(2 * len, "0"))
            }
            function concatBytes(...arrays) {
                let sum = 0;
                for (let i = 0; i < arrays.length; i++) {
                    const a = arrays[i];
                    if (!isBytes(a))
                        throw new Error("Uint8Array expected");
                    sum += a.length
                }
                let res = new Uint8Array(sum)
                  , pad = 0;
                for (let i = 0; i < arrays.length; i++) {
                    const a = arrays[i];
                    res.set(a, pad),
                    pad += a.length
                }
                return res
            }
            exports.hexToBytes = hexToBytes,
            exports.bytesToNumberBE = function(bytes) {
                return hexToNumber(bytesToHex(bytes))
            }
            ,
            exports.bytesToNumberLE = function(bytes) {
                if (!isBytes(bytes))
                    throw new Error("Uint8Array expected");
                return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()))
            }
            ,
            exports.numberToBytesBE = numberToBytesBE,
            exports.numberToBytesLE = function(n, len) {
                return numberToBytesBE(n, len).reverse()
            }
            ,
            exports.numberToVarBytesBE = function(n) {
                return hexToBytes(numberToHexUnpadded(n))
            }
            ,
            exports.ensureBytes = function(title, hex, expectedLength) {
                let res;
                if ("string" == typeof hex)
                    try {
                        res = hexToBytes(hex)
                    } catch (e) {
                        throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`)
                    }
                else {
                    if (!isBytes(hex))
                        throw new Error(`${title} must be hex string or Uint8Array`);
                    res = Uint8Array.from(hex)
                }
                const len = res.length;
                if ("number" == typeof expectedLength && len !== expectedLength)
                    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
                return res
            }
            ,
            exports.concatBytes = concatBytes,
            exports.equalBytes = function(a, b) {
                if (a.length !== b.length)
                    return !1;
                let diff = 0;
                for (let i = 0; i < a.length; i++)
                    diff |= a[i] ^ b[i];
                return 0 === diff
            }
            ,
            exports.utf8ToBytes = function(str) {
                if ("string" != typeof str)
                    throw new Error("utf8ToBytes expected string, got " + typeof str);
                return new Uint8Array((new TextEncoder).encode(str))
            }
            ,
            exports.bitLen = function(n) {
                let len;
                for (len = 0; n > _0n; n >>= _1n,
                len += 1)
                    ;
                return len
            }
            ,
            exports.bitGet = function(n, pos) {
                return n >> BigInt(pos) & _1n
            }
            ;
            exports.bitSet = (n,pos,value)=>n | (value ? _1n : _0n) << BigInt(pos);
            exports.bitMask = n=>(_2n << BigInt(n - 1)) - _1n;
            const u8n = data=>new Uint8Array(data)
              , u8fr = arr=>Uint8Array.from(arr);
            exports.createHmacDrbg = function(hashLen, qByteLen, hmacFn) {
                if ("number" != typeof hashLen || hashLen < 2)
                    throw new Error("hashLen must be a number");
                if ("number" != typeof qByteLen || qByteLen < 2)
                    throw new Error("qByteLen must be a number");
                if ("function" != typeof hmacFn)
                    throw new Error("hmacFn must be a function");
                let v = u8n(hashLen)
                  , k = u8n(hashLen)
                  , i = 0;
                const reset = ()=>{
                    v.fill(1),
                    k.fill(0),
                    i = 0
                }
                  , h = (...b)=>hmacFn(k, v, ...b)
                  , reseed = (seed=u8n())=>{
                    k = h(u8fr([0]), seed),
                    v = h(),
                    0 !== seed.length && (k = h(u8fr([1]), seed),
                    v = h())
                }
                  , gen = ()=>{
                    if (i++ >= 1e3)
                        throw new Error("drbg: tried 1000 values");
                    let len = 0;
                    const out = [];
                    for (; len < qByteLen; ) {
                        v = h();
                        const sl = v.slice();
                        out.push(sl),
                        len += v.length
                    }
                    return concatBytes(...out)
                }
                ;
                return (seed,pred)=>{
                    let res;
                    for (reset(),
                    reseed(seed); !(res = pred(gen())); )
                        reseed();
                    return reset(),
                    res
                }
            }
            ;
            const validatorFns = {
                bigint: val=>"bigint" == typeof val,
                function: val=>"function" == typeof val,
                boolean: val=>"boolean" == typeof val,
                string: val=>"string" == typeof val,
                stringOrUint8Array: val=>"string" == typeof val || isBytes(val),
                isSafeInteger: val=>Number.isSafeInteger(val),
                array: val=>Array.isArray(val),
                field: (val,object)=>object.Fp.isValid(val),
                hash: val=>"function" == typeof val && Number.isSafeInteger(val.outputLen)
            };
            exports.validateObject = function(object, validators, optValidators={}) {
                const checkField = (fieldName,type,isOptional)=>{
                    const checkVal = validatorFns[type];
                    if ("function" != typeof checkVal)
                        throw new Error(`Invalid validator "${type}", expected function`);
                    const val = object[fieldName];
                    if (!(isOptional && void 0 === val || checkVal(val, object)))
                        throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`)
                }
                ;
                for (const [fieldName,type] of Object.entries(validators))
                    checkField(fieldName, type, !1);
                for (const [fieldName,type] of Object.entries(optValidators))
                    checkField(fieldName, type, !0);
                return object
            }
        }
        ,
        96551: (__unused_webpack_module,exports,__webpack_require__)=>{
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.mapToCurveSimpleSWU = exports.SWUFpSqrtRatio = exports.weierstrass = exports.weierstrassPoints = exports.DER = void 0;
            const mod = __webpack_require__(94632)
              , ut = __webpack_require__(40219)
              , utils_js_1 = __webpack_require__(40219)
              , curve_js_1 = __webpack_require__(81525);
            const {bytesToNumberBE: b2n, hexToBytes: h2b} = ut;
            exports.DER = {
                Err: class extends Error {
                    constructor(m="") {
                        super(m)
                    }
                }
                ,
                _parseInt(data) {
                    const {Err: E} = exports.DER;
                    if (data.length < 2 || 2 !== data[0])
                        throw new E("Invalid signature integer tag");
                    const len = data[1]
                      , res = data.subarray(2, len + 2);
                    if (!len || res.length !== len)
                        throw new E("Invalid signature integer: wrong length");
                    if (128 & res[0])
                        throw new E("Invalid signature integer: negative");
                    if (0 === res[0] && !(128 & res[1]))
                        throw new E("Invalid signature integer: unnecessary leading zero");
                    return {
                        d: b2n(res),
                        l: data.subarray(len + 2)
                    }
                },
                toSig(hex) {
                    const {Err: E} = exports.DER
                      , data = "string" == typeof hex ? h2b(hex) : hex;
                    if (!ut.isBytes(data))
                        throw new Error("ui8a expected");
                    let l = data.length;
                    if (l < 2 || 48 != data[0])
                        throw new E("Invalid signature tag");
                    if (data[1] !== l - 2)
                        throw new E("Invalid signature: incorrect length");
                    const {d: r, l: sBytes} = exports.DER._parseInt(data.subarray(2))
                      , {d: s, l: rBytesLeft} = exports.DER._parseInt(sBytes);
                    if (rBytesLeft.length)
                        throw new E("Invalid signature: left bytes after parsing");
                    return {
                        r,
                        s
                    }
                },
                hexFromSig(sig) {
                    const slice = s=>8 & Number.parseInt(s[0], 16) ? "00" + s : s
                      , h = num=>{
                        const hex = num.toString(16);
                        return 1 & hex.length ? `0${hex}` : hex
                    }
                      , s = slice(h(sig.s))
                      , r = slice(h(sig.r))
                      , shl = s.length / 2
                      , rhl = r.length / 2
                      , sl = h(shl)
                      , rl = h(rhl);
                    return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`
                }
            };
            const _0n = BigInt(0)
              , _1n = BigInt(1)
              , _2n = BigInt(2)
              , _3n = BigInt(3)
              , _4n = BigInt(4);
            function weierstrassPoints(opts) {
                const CURVE = function(curve) {
                    const opts = (0,
                    curve_js_1.validateBasic)(curve);
                    ut.validateObject(opts, {
                        a: "field",
                        b: "field"
                    }, {
                        allowedPrivateKeyLengths: "array",
                        wrapPrivateKey: "boolean",
                        isTorsionFree: "function",
                        clearCofactor: "function",
                        allowInfinityPoint: "boolean",
                        fromBytes: "function",
                        toBytes: "function"
                    });
                    const {endo, Fp, a} = opts;
                    if (endo) {
                        if (!Fp.eql(a, Fp.ZERO))
                            throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
                        if ("object" != typeof endo || "bigint" != typeof endo.beta || "function" != typeof endo.splitScalar)
                            throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")
                    }
                    return Object.freeze({
                        ...opts
                    })
                }(opts)
                  , {Fp} = CURVE
                  , toBytes = CURVE.toBytes || ((_c,point,_isCompressed)=>{
                    const a = point.toAffine();
                    return ut.concatBytes(Uint8Array.from([4]), Fp.toBytes(a.x), Fp.toBytes(a.y))
                }
                )
                  , fromBytes = CURVE.fromBytes || (bytes=>{
                    const tail = bytes.subarray(1);
                    return {
                        x: Fp.fromBytes(tail.subarray(0, Fp.BYTES)),
                        y: Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES))
                    }
                }
                );
                function weierstrassEquation(x) {
                    const {a, b} = CURVE
                      , x2 = Fp.sqr(x)
                      , x3 = Fp.mul(x2, x);
                    return Fp.add(Fp.add(x3, Fp.mul(x, a)), b)
                }
                if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
                    throw new Error("bad generator point: equation left != right");
                function isWithinCurveOrder(num) {
                    return "bigint" == typeof num && _0n < num && num < CURVE.n
                }
                function assertGE(num) {
                    if (!isWithinCurveOrder(num))
                        throw new Error("Expected valid bigint: 0 < bigint < curve.n")
                }
                function normPrivateKeyToScalar(key) {
                    const {allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n} = CURVE;
                    if (lengths && "bigint" != typeof key) {
                        if (ut.isBytes(key) && (key = ut.bytesToHex(key)),
                        "string" != typeof key || !lengths.includes(key.length))
                            throw new Error("Invalid key");
                        key = key.padStart(2 * nByteLength, "0")
                    }
                    let num;
                    try {
                        num = "bigint" == typeof key ? key : ut.bytesToNumberBE((0,
                        utils_js_1.ensureBytes)("private key", key, nByteLength))
                    } catch (error) {
                        throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`)
                    }
                    return wrapPrivateKey && (num = mod.mod(num, n)),
                    assertGE(num),
                    num
                }
                const pointPrecomputes = new Map;
                function assertPrjPoint(other) {
                    if (!(other instanceof Point))
                        throw new Error("ProjectivePoint expected")
                }
                class Point {
                    constructor(px, py, pz) {
                        if (this.px = px,
                        this.py = py,
                        this.pz = pz,
                        null == px || !Fp.isValid(px))
                            throw new Error("x required");
                        if (null == py || !Fp.isValid(py))
                            throw new Error("y required");
                        if (null == pz || !Fp.isValid(pz))
                            throw new Error("z required")
                    }
                    static fromAffine(p) {
                        const {x, y} = p || {};
                        if (!p || !Fp.isValid(x) || !Fp.isValid(y))
                            throw new Error("invalid affine point");
                        if (p instanceof Point)
                            throw new Error("projective point not allowed");
                        const is0 = i=>Fp.eql(i, Fp.ZERO);
                        return is0(x) && is0(y) ? Point.ZERO : new Point(x,y,Fp.ONE)
                    }
                    get x() {
                        return this.toAffine().x
                    }
                    get y() {
                        return this.toAffine().y
                    }
                    static normalizeZ(points) {
                        const toInv = Fp.invertBatch(points.map((p=>p.pz)));
                        return points.map(((p,i)=>p.toAffine(toInv[i]))).map(Point.fromAffine)
                    }
                    static fromHex(hex) {
                        const P = Point.fromAffine(fromBytes((0,
                        utils_js_1.ensureBytes)("pointHex", hex)));
                        return P.assertValidity(),
                        P
                    }
                    static fromPrivateKey(privateKey) {
                        return Point.BASE.multiply(normPrivateKeyToScalar(privateKey))
                    }
                    _setWindowSize(windowSize) {
                        this._WINDOW_SIZE = windowSize,
                        pointPrecomputes.delete(this)
                    }
                    assertValidity() {
                        if (this.is0()) {
                            if (CURVE.allowInfinityPoint && !Fp.is0(this.py))
                                return;
                            throw new Error("bad point: ZERO")
                        }
                        const {x, y} = this.toAffine();
                        if (!Fp.isValid(x) || !Fp.isValid(y))
                            throw new Error("bad point: x or y not FE");
                        const left = Fp.sqr(y)
                          , right = weierstrassEquation(x);
                        if (!Fp.eql(left, right))
                            throw new Error("bad point: equation left != right");
                        if (!this.isTorsionFree())
                            throw new Error("bad point: not in prime-order subgroup")
                    }
                    hasEvenY() {
                        const {y} = this.toAffine();
                        if (Fp.isOdd)
                            return !Fp.isOdd(y);
                        throw new Error("Field doesn't support isOdd")
                    }
                    equals(other) {
                        assertPrjPoint(other);
                        const {px: X1, py: Y1, pz: Z1} = this
                          , {px: X2, py: Y2, pz: Z2} = other
                          , U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1))
                          , U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
                        return U1 && U2
                    }
                    negate() {
                        return new Point(this.px,Fp.neg(this.py),this.pz)
                    }
                    double() {
                        const {a, b} = CURVE
                          , b3 = Fp.mul(b, _3n)
                          , {px: X1, py: Y1, pz: Z1} = this;
                        let X3 = Fp.ZERO
                          , Y3 = Fp.ZERO
                          , Z3 = Fp.ZERO
                          , t0 = Fp.mul(X1, X1)
                          , t1 = Fp.mul(Y1, Y1)
                          , t2 = Fp.mul(Z1, Z1)
                          , t3 = Fp.mul(X1, Y1);
                        return t3 = Fp.add(t3, t3),
                        Z3 = Fp.mul(X1, Z1),
                        Z3 = Fp.add(Z3, Z3),
                        X3 = Fp.mul(a, Z3),
                        Y3 = Fp.mul(b3, t2),
                        Y3 = Fp.add(X3, Y3),
                        X3 = Fp.sub(t1, Y3),
                        Y3 = Fp.add(t1, Y3),
                        Y3 = Fp.mul(X3, Y3),
                        X3 = Fp.mul(t3, X3),
                        Z3 = Fp.mul(b3, Z3),
                        t2 = Fp.mul(a, t2),
                        t3 = Fp.sub(t0, t2),
                        t3 = Fp.mul(a, t3),
                        t3 = Fp.add(t3, Z3),
                        Z3 = Fp.add(t0, t0),
                        t0 = Fp.add(Z3, t0),
                        t0 = Fp.add(t0, t2),
                        t0 = Fp.mul(t0, t3),
                        Y3 = Fp.add(Y3, t0),
                        t2 = Fp.mul(Y1, Z1),
                        t2 = Fp.add(t2, t2),
                        t0 = Fp.mul(t2, t3),
                        X3 = Fp.sub(X3, t0),
                        Z3 = Fp.mul(t2, t1),
                        Z3 = Fp.add(Z3, Z3),
                        Z3 = Fp.add(Z3, Z3),
                        new Point(X3,Y3,Z3)
                    }
                    add(other) {
                        assertPrjPoint(other);
                        const {px: X1, py: Y1, pz: Z1} = this
                          , {px: X2, py: Y2, pz: Z2} = other;
                        let X3 = Fp.ZERO
                          , Y3 = Fp.ZERO
                          , Z3 = Fp.ZERO;
                        const a = CURVE.a
                          , b3 = Fp.mul(CURVE.b, _3n);
                        let t0 = Fp.mul(X1, X2)
                          , t1 = Fp.mul(Y1, Y2)
                          , t2 = Fp.mul(Z1, Z2)
                          , t3 = Fp.add(X1, Y1)
                          , t4 = Fp.add(X2, Y2);
                        t3 = Fp.mul(t3, t4),
                        t4 = Fp.add(t0, t1),
                        t3 = Fp.sub(t3, t4),
                        t4 = Fp.add(X1, Z1);
                        let t5 = Fp.add(X2, Z2);
                        return t4 = Fp.mul(t4, t5),
                        t5 = Fp.add(t0, t2),
                        t4 = Fp.sub(t4, t5),
                        t5 = Fp.add(Y1, Z1),
                        X3 = Fp.add(Y2, Z2),
                        t5 = Fp.mul(t5, X3),
                        X3 = Fp.add(t1, t2),
                        t5 = Fp.sub(t5, X3),
                        Z3 = Fp.mul(a, t4),
                        X3 = Fp.mul(b3, t2),
                        Z3 = Fp.add(X3, Z3),
                        X3 = Fp.sub(t1, Z3),
                        Z3 = Fp.add(t1, Z3),
                        Y3 = Fp.mul(X3, Z3),
                        t1 = Fp.add(t0, t0),
                        t1 = Fp.add(t1, t0),
                        t2 = Fp.mul(a, t2),
                        t4 = Fp.mul(b3, t4),
                        t1 = Fp.add(t1, t2),
                        t2 = Fp.sub(t0, t2),
                        t2 = Fp.mul(a, t2),
                        t4 = Fp.add(t4, t2),
                        t0 = Fp.mul(t1, t4),
                        Y3 = Fp.add(Y3, t0),
                        t0 = Fp.mul(t5, t4),
                        X3 = Fp.mul(t3, X3),
                        X3 = Fp.sub(X3, t0),
                        t0 = Fp.mul(t3, t1),
                        Z3 = Fp.mul(t5, Z3),
                        Z3 = Fp.add(Z3, t0),
                        new Point(X3,Y3,Z3)
                    }
                    subtract(other) {
                        return this.add(other.negate())
                    }
                    is0() {
                        return this.equals(Point.ZERO)
                    }
                    wNAF(n) {
                        return wnaf.wNAFCached(this, pointPrecomputes, n, (comp=>{
                            const toInv = Fp.invertBatch(comp.map((p=>p.pz)));
                            return comp.map(((p,i)=>p.toAffine(toInv[i]))).map(Point.fromAffine)
                        }
                        ))
                    }
                    multiplyUnsafe(n) {
                        const I = Point.ZERO;
                        if (n === _0n)
                            return I;
                        if (assertGE(n),
                        n === _1n)
                            return this;
                        const {endo} = CURVE;
                        if (!endo)
                            return wnaf.unsafeLadder(this, n);
                        let {k1neg, k1, k2neg, k2} = endo.splitScalar(n)
                          , k1p = I
                          , k2p = I
                          , d = this;
                        for (; k1 > _0n || k2 > _0n; )
                            k1 & _1n && (k1p = k1p.add(d)),
                            k2 & _1n && (k2p = k2p.add(d)),
                            d = d.double(),
                            k1 >>= _1n,
                            k2 >>= _1n;
                        return k1neg && (k1p = k1p.negate()),
                        k2neg && (k2p = k2p.negate()),
                        k2p = new Point(Fp.mul(k2p.px, endo.beta),k2p.py,k2p.pz),
                        k1p.add(k2p)
                    }
                    multiply(scalar) {
                        assertGE(scalar);
                        let point, fake, n = scalar;
                        const {endo} = CURVE;
                        if (endo) {
                            const {k1neg, k1, k2neg, k2} = endo.splitScalar(n);
                            let {p: k1p, f: f1p} = this.wNAF(k1)
                              , {p: k2p, f: f2p} = this.wNAF(k2);
                            k1p = wnaf.constTimeNegate(k1neg, k1p),
                            k2p = wnaf.constTimeNegate(k2neg, k2p),
                            k2p = new Point(Fp.mul(k2p.px, endo.beta),k2p.py,k2p.pz),
                            point = k1p.add(k2p),
                            fake = f1p.add(f2p)
                        } else {
                            const {p, f} = this.wNAF(n);
                            point = p,
                            fake = f
                        }
                        return Point.normalizeZ([point, fake])[0]
                    }
                    multiplyAndAddUnsafe(Q, a, b) {
                        const G = Point.BASE
                          , mul = (P,a)=>a !== _0n && a !== _1n && P.equals(G) ? P.multiply(a) : P.multiplyUnsafe(a)
                          , sum = mul(this, a).add(mul(Q, b));
                        return sum.is0() ? void 0 : sum
                    }
                    toAffine(iz) {
                        const {px: x, py: y, pz: z} = this
                          , is0 = this.is0();
                        null == iz && (iz = is0 ? Fp.ONE : Fp.inv(z));
                        const ax = Fp.mul(x, iz)
                          , ay = Fp.mul(y, iz)
                          , zz = Fp.mul(z, iz);
                        if (is0)
                            return {
                                x: Fp.ZERO,
                                y: Fp.ZERO
                            };
                        if (!Fp.eql(zz, Fp.ONE))
                            throw new Error("invZ was invalid");
                        return {
                            x: ax,
                            y: ay
                        }
                    }
                    isTorsionFree() {
                        const {h: cofactor, isTorsionFree} = CURVE;
                        if (cofactor === _1n)
                            return !0;
                        if (isTorsionFree)
                            return isTorsionFree(Point, this);
                        throw new Error("isTorsionFree() has not been declared for the elliptic curve")
                    }
                    clearCofactor() {
                        const {h: cofactor, clearCofactor} = CURVE;
                        return cofactor === _1n ? this : clearCofactor ? clearCofactor(Point, this) : this.multiplyUnsafe(CURVE.h)
                    }
                    toRawBytes(isCompressed=!0) {
                        return this.assertValidity(),
                        toBytes(Point, this, isCompressed)
                    }
                    toHex(isCompressed=!0) {
                        return ut.bytesToHex(this.toRawBytes(isCompressed))
                    }
                }
                Point.BASE = new Point(CURVE.Gx,CURVE.Gy,Fp.ONE),
                Point.ZERO = new Point(Fp.ZERO,Fp.ONE,Fp.ZERO);
                const _bits = CURVE.nBitLength
                  , wnaf = (0,
                curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
                return {
                    CURVE,
                    ProjectivePoint: Point,
                    normPrivateKeyToScalar,
                    weierstrassEquation,
                    isWithinCurveOrder
                }
            }
            function SWUFpSqrtRatio(Fp, Z) {
                const q = Fp.ORDER;
                let l = _0n;
                for (let o = q - _1n; o % _2n === _0n; o /= _2n)
                    l += _1n;
                const c1 = l
                  , _2n_pow_c1_1 = _2n << c1 - _1n - _1n
                  , _2n_pow_c1 = _2n_pow_c1_1 * _2n
                  , c2 = (q - _1n) / _2n_pow_c1
                  , c3 = (c2 - _1n) / _2n
                  , c4 = _2n_pow_c1 - _1n
                  , c5 = _2n_pow_c1_1
                  , c6 = Fp.pow(Z, c2)
                  , c7 = Fp.pow(Z, (c2 + _1n) / _2n);
                let sqrtRatio = (u,v)=>{
                    let tv1 = c6
                      , tv2 = Fp.pow(v, c4)
                      , tv3 = Fp.sqr(tv2);
                    tv3 = Fp.mul(tv3, v);
                    let tv5 = Fp.mul(u, tv3);
                    tv5 = Fp.pow(tv5, c3),
                    tv5 = Fp.mul(tv5, tv2),
                    tv2 = Fp.mul(tv5, v),
                    tv3 = Fp.mul(tv5, u);
                    let tv4 = Fp.mul(tv3, tv2);
                    tv5 = Fp.pow(tv4, c5);
                    let isQR = Fp.eql(tv5, Fp.ONE);
                    tv2 = Fp.mul(tv3, c7),
                    tv5 = Fp.mul(tv4, tv1),
                    tv3 = Fp.cmov(tv2, tv3, isQR),
                    tv4 = Fp.cmov(tv5, tv4, isQR);
                    for (let i = c1; i > _1n; i--) {
                        let tv5 = i - _2n;
                        tv5 = _2n << tv5 - _1n;
                        let tvv5 = Fp.pow(tv4, tv5);
                        const e1 = Fp.eql(tvv5, Fp.ONE);
                        tv2 = Fp.mul(tv3, tv1),
                        tv1 = Fp.mul(tv1, tv1),
                        tvv5 = Fp.mul(tv4, tv1),
                        tv3 = Fp.cmov(tv2, tv3, e1),
                        tv4 = Fp.cmov(tvv5, tv4, e1)
                    }
                    return {
                        isValid: isQR,
                        value: tv3
                    }
                }
                ;
                if (Fp.ORDER % _4n === _3n) {
                    const c1 = (Fp.ORDER - _3n) / _4n
                      , c2 = Fp.sqrt(Fp.neg(Z));
                    sqrtRatio = (u,v)=>{
                        let tv1 = Fp.sqr(v);
                        const tv2 = Fp.mul(u, v);
                        tv1 = Fp.mul(tv1, tv2);
                        let y1 = Fp.pow(tv1, c1);
                        y1 = Fp.mul(y1, tv2);
                        const y2 = Fp.mul(y1, c2)
                          , tv3 = Fp.mul(Fp.sqr(y1), v)
                          , isQR = Fp.eql(tv3, u);
                        return {
                            isValid: isQR,
                            value: Fp.cmov(y2, y1, isQR)
                        }
                    }
                }
                return sqrtRatio
            }
            exports.weierstrassPoints = weierstrassPoints,
            exports.weierstrass = function(curveDef) {
                const CURVE = function(curve) {
                    const opts = (0,
                    curve_js_1.validateBasic)(curve);
                    return ut.validateObject(opts, {
                        hash: "hash",
                        hmac: "function",
                        randomBytes: "function"
                    }, {
                        bits2int: "function",
                        bits2int_modN: "function",
                        lowS: "boolean"
                    }),
                    Object.freeze({
                        lowS: !0,
                        ...opts
                    })
                }(curveDef)
                  , {Fp, n: CURVE_ORDER} = CURVE
                  , compressedLen = Fp.BYTES + 1
                  , uncompressedLen = 2 * Fp.BYTES + 1;
                function modN(a) {
                    return mod.mod(a, CURVE_ORDER)
                }
                function invN(a) {
                    return mod.invert(a, CURVE_ORDER)
                }
                const {ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder} = weierstrassPoints({
                    ...CURVE,
                    toBytes(_c, point, isCompressed) {
                        const a = point.toAffine()
                          , x = Fp.toBytes(a.x)
                          , cat = ut.concatBytes;
                        return isCompressed ? cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x) : cat(Uint8Array.from([4]), x, Fp.toBytes(a.y))
                    },
                    fromBytes(bytes) {
                        const len = bytes.length
                          , head = bytes[0]
                          , tail = bytes.subarray(1);
                        if (len !== compressedLen || 2 !== head && 3 !== head) {
                            if (len === uncompressedLen && 4 === head) {
                                return {
                                    x: Fp.fromBytes(tail.subarray(0, Fp.BYTES)),
                                    y: Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES))
                                }
                            }
                            throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`)
                        }
                        {
                            const x = ut.bytesToNumberBE(tail);
                            if (!(_0n < (num = x) && num < Fp.ORDER))
                                throw new Error("Point is not on curve");
                            const y2 = weierstrassEquation(x);
                            let y = Fp.sqrt(y2);
                            return 1 == (1 & head) !== ((y & _1n) === _1n) && (y = Fp.neg(y)),
                            {
                                x,
                                y
                            }
                        }
                        var num
                    }
                })
                  , numToNByteStr = num=>ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));
                function isBiggerThanHalfOrder(number) {
                    return number > CURVE_ORDER >> _1n
                }
                const slcNum = (b,from,to)=>ut.bytesToNumberBE(b.slice(from, to));
                class Signature {
                    constructor(r, s, recovery) {
                        this.r = r,
                        this.s = s,
                        this.recovery = recovery,
                        this.assertValidity()
                    }
                    static fromCompact(hex) {
                        const l = CURVE.nByteLength;
                        return hex = (0,
                        utils_js_1.ensureBytes)("compactSignature", hex, 2 * l),
                        new Signature(slcNum(hex, 0, l),slcNum(hex, l, 2 * l))
                    }
                    static fromDER(hex) {
                        const {r, s} = exports.DER.toSig((0,
                        utils_js_1.ensureBytes)("DER", hex));
                        return new Signature(r,s)
                    }
                    assertValidity() {
                        if (!isWithinCurveOrder(this.r))
                            throw new Error("r must be 0 < r < CURVE.n");
                        if (!isWithinCurveOrder(this.s))
                            throw new Error("s must be 0 < s < CURVE.n")
                    }
                    addRecoveryBit(recovery) {
                        return new Signature(this.r,this.s,recovery)
                    }
                    recoverPublicKey(msgHash) {
                        const {r, s, recovery: rec} = this
                          , h = bits2int_modN((0,
                        utils_js_1.ensureBytes)("msgHash", msgHash));
                        if (null == rec || ![0, 1, 2, 3].includes(rec))
                            throw new Error("recovery id invalid");
                        const radj = 2 === rec || 3 === rec ? r + CURVE.n : r;
                        if (radj >= Fp.ORDER)
                            throw new Error("recovery id 2 or 3 invalid");
                        const prefix = 0 == (1 & rec) ? "02" : "03"
                          , R = Point.fromHex(prefix + numToNByteStr(radj))
                          , ir = invN(radj)
                          , u1 = modN(-h * ir)
                          , u2 = modN(s * ir)
                          , Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
                        if (!Q)
                            throw new Error("point at infinify");
                        return Q.assertValidity(),
                        Q
                    }
                    hasHighS() {
                        return isBiggerThanHalfOrder(this.s)
                    }
                    normalizeS() {
                        return this.hasHighS() ? new Signature(this.r,modN(-this.s),this.recovery) : this
                    }
                    toDERRawBytes() {
                        return ut.hexToBytes(this.toDERHex())
                    }
                    toDERHex() {
                        return exports.DER.hexFromSig({
                            r: this.r,
                            s: this.s
                        })
                    }
                    toCompactRawBytes() {
                        return ut.hexToBytes(this.toCompactHex())
                    }
                    toCompactHex() {
                        return numToNByteStr(this.r) + numToNByteStr(this.s)
                    }
                }
                const utils = {
                    isValidPrivateKey(privateKey) {
                        try {
                            return normPrivateKeyToScalar(privateKey),
                            !0
                        } catch (error) {
                            return !1
                        }
                    },
                    normPrivateKeyToScalar,
                    randomPrivateKey: ()=>{
                        const length = mod.getMinHashLength(CURVE.n);
                        return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n)
                    }
                    ,
                    precompute: (windowSize=8,point=Point.BASE)=>(point._setWindowSize(windowSize),
                    point.multiply(BigInt(3)),
                    point)
                };
                function isProbPub(item) {
                    const arr = ut.isBytes(item)
                      , str = "string" == typeof item
                      , len = (arr || str) && item.length;
                    return arr ? len === compressedLen || len === uncompressedLen : str ? len === 2 * compressedLen || len === 2 * uncompressedLen : item instanceof Point
                }
                const bits2int = CURVE.bits2int || function(bytes) {
                    const num = ut.bytesToNumberBE(bytes)
                      , delta = 8 * bytes.length - CURVE.nBitLength;
                    return delta > 0 ? num >> BigInt(delta) : num
                }
                  , bits2int_modN = CURVE.bits2int_modN || function(bytes) {
                    return modN(bits2int(bytes))
                }
                  , ORDER_MASK = ut.bitMask(CURVE.nBitLength);
                function int2octets(num) {
                    if ("bigint" != typeof num)
                        throw new Error("bigint expected");
                    if (!(_0n <= num && num < ORDER_MASK))
                        throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
                    return ut.numberToBytesBE(num, CURVE.nByteLength)
                }
                function prepSig(msgHash, privateKey, opts=defaultSigOpts) {
                    if (["recovered", "canonical"].some((k=>k in opts)))
                        throw new Error("sign() legacy options not supported");
                    const {hash, randomBytes} = CURVE;
                    let {lowS, prehash, extraEntropy: ent} = opts;
                    null == lowS && (lowS = !0),
                    msgHash = (0,
                    utils_js_1.ensureBytes)("msgHash", msgHash),
                    prehash && (msgHash = (0,
                    utils_js_1.ensureBytes)("prehashed msgHash", hash(msgHash)));
                    const h1int = bits2int_modN(msgHash)
                      , d = normPrivateKeyToScalar(privateKey)
                      , seedArgs = [int2octets(d), int2octets(h1int)];
                    if (null != ent) {
                        const e = !0 === ent ? randomBytes(Fp.BYTES) : ent;
                        seedArgs.push((0,
                        utils_js_1.ensureBytes)("extraEntropy", e))
                    }
                    const seed = ut.concatBytes(...seedArgs)
                      , m = h1int;
                    return {
                        seed,
                        k2sig: function(kBytes) {
                            const k = bits2int(kBytes);
                            if (!isWithinCurveOrder(k))
                                return;
                            const ik = invN(k)
                              , q = Point.BASE.multiply(k).toAffine()
                              , r = modN(q.x);
                            if (r === _0n)
                                return;
                            const s = modN(ik * modN(m + r * d));
                            if (s === _0n)
                                return;
                            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n)
                              , normS = s;
                            return lowS && isBiggerThanHalfOrder(s) && (normS = function(s) {
                                return isBiggerThanHalfOrder(s) ? modN(-s) : s
                            }(s),
                            recovery ^= 1),
                            new Signature(r,normS,recovery)
                        }
                    }
                }
                const defaultSigOpts = {
                    lowS: CURVE.lowS,
                    prehash: !1
                }
                  , defaultVerOpts = {
                    lowS: CURVE.lowS,
                    prehash: !1
                };
                return Point.BASE._setWindowSize(8),
                {
                    CURVE,
                    getPublicKey: function(privateKey, isCompressed=!0) {
                        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed)
                    },
                    getSharedSecret: function(privateA, publicB, isCompressed=!0) {
                        if (isProbPub(privateA))
                            throw new Error("first arg must be private key");
                        if (!isProbPub(publicB))
                            throw new Error("second arg must be public key");
                        return Point.fromHex(publicB).multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed)
                    },
                    sign: function(msgHash, privKey, opts=defaultSigOpts) {
                        const {seed, k2sig} = prepSig(msgHash, privKey, opts)
                          , C = CURVE;
                        return ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac)(seed, k2sig)
                    },
                    verify: function(signature, msgHash, publicKey, opts=defaultVerOpts) {
                        const sg = signature;
                        if (msgHash = (0,
                        utils_js_1.ensureBytes)("msgHash", msgHash),
                        publicKey = (0,
                        utils_js_1.ensureBytes)("publicKey", publicKey),
                        "strict"in opts)
                            throw new Error("options.strict was renamed to lowS");
                        const {lowS, prehash} = opts;
                        let _sig, P;
                        try {
                            if ("string" == typeof sg || ut.isBytes(sg))
                                try {
                                    _sig = Signature.fromDER(sg)
                                } catch (derError) {
                                    if (!(derError instanceof exports.DER.Err))
                                        throw derError;
                                    _sig = Signature.fromCompact(sg)
                                }
                            else {
                                if ("object" != typeof sg || "bigint" != typeof sg.r || "bigint" != typeof sg.s)
                                    throw new Error("PARSE");
                                {
                                    const {r, s} = sg;
                                    _sig = new Signature(r,s)
                                }
                            }
                            P = Point.fromHex(publicKey)
                        } catch (error) {
                            if ("PARSE" === error.message)
                                throw new Error("signature must be Signature instance, Uint8Array or hex string");
                            return !1
                        }
                        if (lowS && _sig.hasHighS())
                            return !1;
                        prehash && (msgHash = CURVE.hash(msgHash));
                        const {r, s} = _sig
                          , h = bits2int_modN(msgHash)
                          , is = invN(s)
                          , u1 = modN(h * is)
                          , u2 = modN(r * is)
                          , R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
                        return !!R && modN(R.x) === r
                    },
                    ProjectivePoint: Point,
                    Signature,
                    utils
                }
            }
            ,
            exports.SWUFpSqrtRatio = SWUFpSqrtRatio,
            exports.mapToCurveSimpleSWU = function(Fp, opts) {
                if (mod.validateField(Fp),
                !Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
                    throw new Error("mapToCurveSimpleSWU: invalid opts");
                const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
                if (!Fp.isOdd)
                    throw new Error("Fp.isOdd is not implemented!");
                return u=>{
                    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
                    tv1 = Fp.sqr(u),
                    tv1 = Fp.mul(tv1, opts.Z),
                    tv2 = Fp.sqr(tv1),
                    tv2 = Fp.add(tv2, tv1),
                    tv3 = Fp.add(tv2, Fp.ONE),
                    tv3 = Fp.mul(tv3, opts.B),
                    tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)),
                    tv4 = Fp.mul(tv4, opts.A),
                    tv2 = Fp.sqr(tv3),
                    tv6 = Fp.sqr(tv4),
                    tv5 = Fp.mul(tv6, opts.A),
                    tv2 = Fp.add(tv2, tv5),
                    tv2 = Fp.mul(tv2, tv3),
                    tv6 = Fp.mul(tv6, tv4),
                    tv5 = Fp.mul(tv6, opts.B),
                    tv2 = Fp.add(tv2, tv5),
                    x = Fp.mul(tv1, tv3);
                    const {isValid, value} = sqrtRatio(tv2, tv6);
                    y = Fp.mul(tv1, u),
                    y = Fp.mul(y, value),
                    x = Fp.cmov(x, tv3, isValid),
                    y = Fp.cmov(y, value, isValid);
                    const e1 = Fp.isOdd(u) === Fp.isOdd(y);
                    return y = Fp.cmov(Fp.neg(y), y, e1),
                    x = Fp.div(x, tv4),
                    {
                        x,
                        y
                    }
                }
            }
        }
        ,
        43150: (__unused_webpack_module,exports)=>{
            "use strict";
            function number(n) {
                if (!Number.isSafeInteger(n) || n < 0)
                    throw new Error(`Wrong positive integer: ${n}`)
            }
            function bool(b) {
                if ("boolean" != typeof b)
                    throw new Error(`Expected boolean, not ${b}`)
            }
            function bytes(b, ...lengths) {
                if (!((a = b)instanceof Uint8Array || null != a && "object" == typeof a && "Uint8Array" === a.constructor.name))
                    throw new Error("Expected Uint8Array");
                var a;
                if (lengths.length > 0 && !lengths.includes(b.length))
                    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`)
            }
            function hash(hash) {
                if ("function" != typeof hash || "function" != typeof hash.create)
                    throw new Error("Hash should be wrapped by utils.wrapConstructor");
                number(hash.outputLen),
                number(hash.blockLen)
            }
            function exists(instance, checkFinished=!0) {
                if (instance.destroyed)
                    throw new Error("Hash instance has been destroyed");
                if (checkFinished && instance.finished)
                    throw new Error("Hash#digest() has already been called")
            }
            function output(out, instance) {
                bytes(out);
                const min = instance.outputLen;
                if (out.length < min)
                    throw new Error(`digestInto() expects output buffer of length at least ${min}`)
            }
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0,
            exports.number = number,
            exports.bool = bool,
            exports.bytes = bytes,
            exports.hash = hash,
            exports.exists = exists,
            exports.output = output;
            const assert = {
                number,
                bool,
                bytes,
                hash,
                exists,
                output
            };
            exports.default = assert
        }
        ,
        17564: (__unused_webpack_module,exports)=>{
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.crypto = void 0,
            exports.crypto = "object" == typeof globalThis && "crypto"in globalThis ? globalThis.crypto : void 0
        }
        ,
        41128: (__unused_webpack_module,exports,__webpack_require__)=>{
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.hmac = exports.HMAC = void 0;
            const _assert_js_1 = __webpack_require__(43150)
              , utils_js_1 = __webpack_require__(31717);
            class HMAC extends utils_js_1.Hash {
                constructor(hash, _key) {
                    super(),
                    this.finished = !1,
                    this.destroyed = !1,
                    (0,
                    _assert_js_1.hash)(hash);
                    const key = (0,
                    utils_js_1.toBytes)(_key);
                    if (this.iHash = hash.create(),
                    "function" != typeof this.iHash.update)
                        throw new Error("Expected instance of class which extends utils.Hash");
                    this.blockLen = this.iHash.blockLen,
                    this.outputLen = this.iHash.outputLen;
                    const blockLen = this.blockLen
                      , pad = new Uint8Array(blockLen);
                    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
                    for (let i = 0; i < pad.length; i++)
                        pad[i] ^= 54;
                    this.iHash.update(pad),
                    this.oHash = hash.create();
                    for (let i = 0; i < pad.length; i++)
                        pad[i] ^= 106;
                    this.oHash.update(pad),
                    pad.fill(0)
                }
                update(buf) {
                    return (0,
                    _assert_js_1.exists)(this),
                    this.iHash.update(buf),
                    this
                }
                digestInto(out) {
                    (0,
                    _assert_js_1.exists)(this),
                    (0,
                    _assert_js_1.bytes)(out, this.outputLen),
                    this.finished = !0,
                    this.iHash.digestInto(out),
                    this.oHash.update(out),
                    this.oHash.digestInto(out),
                    this.destroy()
                }
                digest() {
                    const out = new Uint8Array(this.oHash.outputLen);
                    return this.digestInto(out),
                    out
                }
                _cloneInto(to) {
                    to || (to = Object.create(Object.getPrototypeOf(this), {}));
                    const {oHash, iHash, finished, destroyed, blockLen, outputLen} = this;
                    return to.finished = finished,
                    to.destroyed = destroyed,
                    to.blockLen = blockLen,
                    to.outputLen = outputLen,
                    to.oHash = oHash._cloneInto(to.oHash),
                    to.iHash = iHash._cloneInto(to.iHash),
                    to
                }
                destroy() {
                    this.destroyed = !0,
                    this.oHash.destroy(),
                    this.iHash.destroy()
                }
            }
            exports.HMAC = HMAC;
            exports.hmac = (hash,key,message)=>new HMAC(hash,key).update(message).digest(),
            exports.hmac.create = (hash,key)=>new HMAC(hash,key)
        }
        ,
        31717: (__unused_webpack_module,exports,__webpack_require__)=>{
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
            const crypto_1 = __webpack_require__(17564);
            exports.u8 = arr=>new Uint8Array(arr.buffer,arr.byteOffset,arr.byteLength);
            function isBytes(a) {
                return a instanceof Uint8Array || null != a && "object" == typeof a && "Uint8Array" === a.constructor.name
            }
            exports.u32 = arr=>new Uint32Array(arr.buffer,arr.byteOffset,Math.floor(arr.byteLength / 4));
            exports.createView = arr=>new DataView(arr.buffer,arr.byteOffset,arr.byteLength);
            if (exports.rotr = (word,shift)=>word << 32 - shift | word >>> shift,
            exports.isLE = 68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0],
            !exports.isLE)
                throw new Error("Non little-endian hardware is not supported");
            const hexes = Array.from({
                length: 256
            }, ((_,i)=>i.toString(16).padStart(2, "0")));
            exports.bytesToHex = function(bytes) {
                if (!isBytes(bytes))
                    throw new Error("Uint8Array expected");
                let hex = "";
                for (let i = 0; i < bytes.length; i++)
                    hex += hexes[bytes[i]];
                return hex
            }
            ;
            const asciis = {
                _0: 48,
                _9: 57,
                _A: 65,
                _F: 70,
                _a: 97,
                _f: 102
            };
            function asciiToBase16(char) {
                return char >= asciis._0 && char <= asciis._9 ? char - asciis._0 : char >= asciis._A && char <= asciis._F ? char - (asciis._A - 10) : char >= asciis._a && char <= asciis._f ? char - (asciis._a - 10) : void 0
            }
            exports.hexToBytes = function(hex) {
                if ("string" != typeof hex)
                    throw new Error("hex string expected, got " + typeof hex);
                const hl = hex.length
                  , al = hl / 2;
                if (hl % 2)
                    throw new Error("padded hex string expected, got unpadded hex of length " + hl);
                const array = new Uint8Array(al);
                for (let ai = 0, hi = 0; ai < al; ai++,
                hi += 2) {
                    const n1 = asciiToBase16(hex.charCodeAt(hi))
                      , n2 = asciiToBase16(hex.charCodeAt(hi + 1));
                    if (void 0 === n1 || void 0 === n2) {
                        const char = hex[hi] + hex[hi + 1];
                        throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi)
                    }
                    array[ai] = 16 * n1 + n2
                }
                return array
            }
            ;
            function utf8ToBytes(str) {
                if ("string" != typeof str)
                    throw new Error("utf8ToBytes expected string, got " + typeof str);
                return new Uint8Array((new TextEncoder).encode(str))
            }
            function toBytes(data) {
                if ("string" == typeof data && (data = utf8ToBytes(data)),
                !isBytes(data))
                    throw new Error("expected Uint8Array, got " + typeof data);
                return data
            }
            exports.nextTick = async()=>{}
            ,
            exports.asyncLoop = async function(iters, tick, cb) {
                let ts = Date.now();
                for (let i = 0; i < iters; i++) {
                    cb(i);
                    const diff = Date.now() - ts;
                    diff >= 0 && diff < tick || (await (0,
                    exports.nextTick)(),
                    ts += diff)
                }
            }
            ,
            exports.utf8ToBytes = utf8ToBytes,
            exports.toBytes = toBytes,
            exports.concatBytes = function(...arrays) {
                let sum = 0;
                for (let i = 0; i < arrays.length; i++) {
                    const a = arrays[i];
                    if (!isBytes(a))
                        throw new Error("Uint8Array expected");
                    sum += a.length
                }
                const res = new Uint8Array(sum);
                for (let i = 0, pad = 0; i < arrays.length; i++) {
                    const a = arrays[i];
                    res.set(a, pad),
                    pad += a.length
                }
                return res
            }
            ;
            exports.Hash = class {
                clone() {
                    return this._cloneInto()
                }
            }
            ;
            const toStr = {}.toString;
            exports.checkOpts = function(defaults, opts) {
                if (void 0 !== opts && "[object Object]" !== toStr.call(opts))
                    throw new Error("Options should be object or undefined");
                return Object.assign(defaults, opts)
            }
            ,
            exports.wrapConstructor = function(hashCons) {
                const hashC = msg=>hashCons().update(toBytes(msg)).digest()
                  , tmp = hashCons();
                return hashC.outputLen = tmp.outputLen,
                hashC.blockLen = tmp.blockLen,
                hashC.create = ()=>hashCons(),
                hashC
            }
            ,
            exports.wrapConstructorWithOpts = function(hashCons) {
                const hashC = (msg,opts)=>hashCons(opts).update(toBytes(msg)).digest()
                  , tmp = hashCons({});
                return hashC.outputLen = tmp.outputLen,
                hashC.blockLen = tmp.blockLen,
                hashC.create = opts=>hashCons(opts),
                hashC
            }
            ,
            exports.wrapXOFConstructorWithOpts = function(hashCons) {
                const hashC = (msg,opts)=>hashCons(opts).update(toBytes(msg)).digest()
                  , tmp = hashCons({});
                return hashC.outputLen = tmp.outputLen,
                hashC.blockLen = tmp.blockLen,
                hashC.create = opts=>hashCons(opts),
                hashC
            }
            ,
            exports.randomBytes = function(bytesLength=32) {
                if (crypto_1.crypto && "function" == typeof crypto_1.crypto.getRandomValues)
                    return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
                throw new Error("crypto.getRandomValues must be defined")
            }
        }
        ,
        37962: (__unused_webpack_module,exports,__webpack_require__)=>{
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.poseidonHashMany = exports.poseidonHashSingle = exports.poseidonHashFunc = exports.poseidonHash = exports.poseidonSmall = exports.poseidonCreate = exports.poseidonBasic = exports._poseidonMDS = exports.Fp251 = exports.keccak = exports.computeHashOnElements = exports.pedersen = exports.getAccountPath = exports.ethSigToPrivate = exports.getStarkKey = exports.grindKey = exports.utils = exports.Signature = exports.ProjectivePoint = exports.CURVE = exports.verify = exports.sign = exports.getSharedSecret = exports.getPublicKey = exports._starkCurve = exports.MAX_VALUE = void 0;
            const sha3_1 = __webpack_require__(31258)
              , sha256_1 = __webpack_require__(326)
              , utils_1 = __webpack_require__(9617)
              , modular_1 = __webpack_require__(94632)
              , poseidon_1 = __webpack_require__(33192)
              , weierstrass_1 = __webpack_require__(96551)
              , u = __webpack_require__(40219)
              , _shortw_utils_1 = __webpack_require__(79082)
              , CURVE_ORDER = BigInt("3618502788666131213697322783095070105526743751716087489154079457884512865583");
            exports.MAX_VALUE = BigInt("0x800000000000000000000000000000000000000000000000000000000000000");
            function bits2int(bytes) {
                for (; 0 === bytes[0]; )
                    bytes = bytes.subarray(1);
                const delta = 8 * bytes.length - 252
                  , num = u.bytesToNumberBE(bytes);
                return delta > 0 ? num >> BigInt(delta) : num
            }
            function hex0xToBytes(hex) {
                return "string" == typeof hex && 1 & (hex = strip0x(hex)).length && (hex = "0" + hex),
                u.hexToBytes(hex)
            }
            const curve = (0,
            weierstrass_1.weierstrass)({
                a: BigInt(1),
                b: BigInt("3141592653589793238462643383279502884197169399375105820974944592307816406665"),
                Fp: (0,
                modular_1.Field)(BigInt("0x800000000000011000000000000000000000000000000000000000000000001")),
                n: CURVE_ORDER,
                nBitLength: 252,
                Gx: BigInt("874739451078007766457464989774322083649278607533249481151382481072868806602"),
                Gy: BigInt("152666792071518830868575557812948353041420400780739481342941381225525861407"),
                h: BigInt(1),
                lowS: !1,
                ...(0,
                _shortw_utils_1.getHash)(sha256_1.sha256),
                bits2int,
                bits2int_modN: bytes=>{
                    const hex = u.bytesToNumberBE(bytes).toString(16);
                    return 63 === hex.length && (bytes = hex0xToBytes(hex + "0")),
                    (0,
                    modular_1.mod)(bits2int(bytes), CURVE_ORDER)
                }
            });
            function ensureBytes(hex) {
                return u.ensureBytes("", "string" == typeof hex ? hex0xToBytes(hex) : hex)
            }
            function normPrivKey(privKey) {
                return u.bytesToHex(ensureBytes(privKey)).padStart(64, "0")
            }
            function getPublicKey(privKey, isCompressed=!1) {
                return curve.getPublicKey(normPrivKey(privKey), isCompressed)
            }
            function checkSignature(signature) {
                const {r, s} = signature;
                if (r < 0n || r >= exports.MAX_VALUE)
                    throw new Error(`Signature.r should be [1, ${exports.MAX_VALUE})`);
                const w = (0,
                modular_1.invert)(s, CURVE_ORDER);
                if (w < 0n || w >= exports.MAX_VALUE)
                    throw new Error(`inv(Signature.s) should be [1, ${exports.MAX_VALUE})`)
            }
            function checkMessage(msgHash) {
                const bytes = ensureBytes(msgHash);
                if (u.bytesToNumberBE(bytes) >= exports.MAX_VALUE)
                    throw new Error(`msgHash should be [0, ${exports.MAX_VALUE})`);
                return bytes
            }
            exports._starkCurve = curve,
            exports.getPublicKey = getPublicKey,
            exports.getSharedSecret = function(privKeyA, pubKeyB) {
                return curve.getSharedSecret(normPrivKey(privKeyA), pubKeyB)
            }
            ,
            exports.sign = function(msgHash, privKey, opts) {
                const sig = curve.sign(checkMessage(msgHash), normPrivKey(privKey), opts);
                return checkSignature(sig),
                sig
            }
            ,
            exports.verify = function(signature, msgHash, pubKey) {
                if (!(signature instanceof Signature)) {
                    const bytes = ensureBytes(signature);
                    try {
                        signature = Signature.fromDER(bytes)
                    } catch (derError) {
                        if (!(derError instanceof weierstrass_1.DER.Err))
                            throw derError;
                        signature = Signature.fromCompact(bytes)
                    }
                }
                return checkSignature(signature),
                curve.verify(signature, checkMessage(msgHash), ensureBytes(pubKey))
            }
            ;
            const {CURVE, ProjectivePoint, Signature, utils} = curve;
            function extractX(bytes) {
                return `0x${u.bytesToHex(bytes.subarray(1)).replace(/^0+/gm, "")}`
            }
            function strip0x(hex) {
                return hex.replace(/^0x/i, "")
            }
            function grindKey(seed) {
                const _seed = ensureBytes(seed)
                  , sha256mask = 2n ** 256n
                  , limit = sha256mask - (0,
                modular_1.mod)(sha256mask, CURVE_ORDER);
                for (let i = 0; ; i++) {
                    const key = sha256Num(u.concatBytes(_seed, u.numberToVarBytesBE(BigInt(i))));
                    if (key < limit)
                        return (0,
                        modular_1.mod)(key, CURVE_ORDER).toString(16);
                    if (1e5 === i)
                        throw new Error("grindKey is broken: tried 100k vals")
                }
            }
            exports.CURVE = CURVE,
            exports.ProjectivePoint = ProjectivePoint,
            exports.Signature = Signature,
            exports.utils = utils,
            exports.grindKey = grindKey,
            exports.getStarkKey = function(privateKey) {
                return extractX(getPublicKey(privateKey, !0))
            }
            ,
            exports.ethSigToPrivate = function(signature) {
                if (130 !== (signature = strip0x(signature)).length)
                    throw new Error("Wrong ethereum signature");
                return grindKey(signature.substring(0, 64))
            }
            ;
            const MASK_31 = 2n ** 31n - 1n
              , int31 = n=>Number(n & MASK_31);
            exports.getAccountPath = function(layer, application, ethereumAddress, index) {
                const layerNum = int31(sha256Num(layer))
                  , applicationNum = int31(sha256Num(application))
                  , eth = u.hexToNumber(strip0x(ethereumAddress));
                return `m/2645'/${layerNum}'/${applicationNum}'/${int31(eth)}'/${int31(eth >> 31n)}'/${index}`
            }
            ;
            const PEDERSEN_POINTS = [new ProjectivePoint(2089986280348253421170679821480865132823066470938446095505822317253594081284n,1713931329540660377023406109199410414810705867260802078187082345529207694986n,1n), new ProjectivePoint(996781205833008774514500082376783249102396023663454813447423147977397232763n,1668503676786377725805489344771023921079126552019160156920634619255970485781n,1n), new ProjectivePoint(2251563274489750535117886426533222435294046428347329203627021249169616184184n,1798716007562728905295480679789526322175868328062420237419143593021674992973n,1n), new ProjectivePoint(2138414695194151160943305727036575959195309218611738193261179310511854807447n,113410276730064486255102093846540133784865286929052426931474106396135072156n,1n), new ProjectivePoint(2379962749567351885752724891227938183011949129833673362440656643086021394946n,776496453633298175483985398648758586525933812536653089401905292063708816422n,1n)];
            function pedersenPrecompute(p1, p2) {
                const out = [];
                let p = p1;
                for (let i = 0; i < 248; i++)
                    out.push(p),
                    p = p.double();
                p = p2;
                for (let i = 0; i < 4; i++)
                    out.push(p),
                    p = p.double();
                return out
            }
            const PEDERSEN_POINTS1 = pedersenPrecompute(PEDERSEN_POINTS[1], PEDERSEN_POINTS[2])
              , PEDERSEN_POINTS2 = pedersenPrecompute(PEDERSEN_POINTS[3], PEDERSEN_POINTS[4]);
            function pedersenSingle(point, value, constants) {
                let x = function(arg) {
                    let value;
                    if ("bigint" == typeof arg)
                        value = arg;
                    else if ("number" == typeof arg) {
                        if (!Number.isSafeInteger(arg))
                            throw new Error(`Invalid pedersenArg: ${arg}`);
                        value = BigInt(arg)
                    } else
                        value = u.bytesToNumberBE(ensureBytes(arg));
                    if (!(0n <= value && value < curve.CURVE.Fp.ORDER))
                        throw new Error(`PedersenArg should be 0 <= value < CURVE.P: ${value}`);
                    return value
                }(value);
                for (let j = 0; j < 252; j++) {
                    const pt = constants[j];
                    if (pt.equals(point))
                        throw new Error("Same point");
                    0n !== (1n & x) && (point = point.add(pt)),
                    x >>= 1n
                }
                return point
            }
            function pedersen(x, y) {
                let point = PEDERSEN_POINTS[0];
                return point = pedersenSingle(point, x, PEDERSEN_POINTS1),
                point = pedersenSingle(point, y, PEDERSEN_POINTS2),
                extractX(point.toRawBytes(!0))
            }
            exports.pedersen = pedersen;
            exports.computeHashOnElements = (data,fn=pedersen)=>[0, ...data, data.length].reduce(((x,y)=>fn(x, y)));
            const MASK_250 = u.bitMask(250);
            exports.keccak = data=>u.bytesToNumberBE((0,
            sha3_1.keccak_256)(data)) & MASK_250;
            const sha256Num = data=>u.bytesToNumberBE((0,
            sha256_1.sha256)(data));
            function poseidonRoundConstant(Fp, name, idx) {
                const val = Fp.fromBytes((0,
                sha256_1.sha256)((0,
                utils_1.utf8ToBytes)(`${name}${idx}`)));
                return Fp.create(val)
            }
            function _poseidonMDS(Fp, name, m, attempt=0) {
                const x_values = []
                  , y_values = [];
                for (let i = 0; i < m; i++)
                    x_values.push(poseidonRoundConstant(Fp, `${name}x`, attempt * m + i)),
                    y_values.push(poseidonRoundConstant(Fp, `${name}y`, attempt * m + i));
                if (new Set([...x_values, ...y_values]).size !== 2 * m)
                    throw new Error("X and Y values are not distinct");
                return x_values.map((x=>y_values.map((y=>Fp.inv(Fp.sub(x, y))))))
            }
            exports.Fp251 = (0,
            modular_1.Field)(BigInt("3618502788666131213697322783095070105623107215331596699973092056135872020481")),
            exports._poseidonMDS = _poseidonMDS;
            const MDS_SMALL = [[3, 1, 1], [1, -1, 1], [1, 1, -2]].map((i=>i.map(BigInt)));
            function poseidonBasic(opts, mds) {
                if ((0,
                modular_1.validateField)(opts.Fp),
                !Number.isSafeInteger(opts.rate) || !Number.isSafeInteger(opts.capacity))
                    throw new Error(`Wrong poseidon opts: ${opts}`);
                const m = opts.rate + opts.capacity
                  , rounds = opts.roundsFull + opts.roundsPartial
                  , roundConstants = [];
                for (let i = 0; i < rounds; i++) {
                    const row = [];
                    for (let j = 0; j < m; j++)
                        row.push(poseidonRoundConstant(opts.Fp, "Hades", m * i + j));
                    roundConstants.push(row)
                }
                const res = (0,
                poseidon_1.poseidon)({
                    ...opts,
                    t: m,
                    sboxPower: 3,
                    reversePartialPowIdx: !0,
                    mds,
                    roundConstants
                });
                return res.m = m,
                res.rate = opts.rate,
                res.capacity = opts.capacity,
                res
            }
            function poseidonHash(x, y, fn=exports.poseidonSmall) {
                return fn([x, y, 2n])[0]
            }
            exports.poseidonBasic = poseidonBasic,
            exports.poseidonCreate = function(opts, mdsAttempt=0) {
                const m = opts.rate + opts.capacity;
                if (!Number.isSafeInteger(mdsAttempt))
                    throw new Error(`Wrong mdsAttempt=${mdsAttempt}`);
                return poseidonBasic(opts, _poseidonMDS(opts.Fp, "HadesMDS", m, mdsAttempt))
            }
            ,
            exports.poseidonSmall = poseidonBasic({
                Fp: exports.Fp251,
                rate: 2,
                capacity: 1,
                roundsFull: 8,
                roundsPartial: 83
            }, MDS_SMALL),
            exports.poseidonHash = poseidonHash,
            exports.poseidonHashFunc = function(x, y, fn=exports.poseidonSmall) {
                return u.numberToVarBytesBE(poseidonHash(u.bytesToNumberBE(x), u.bytesToNumberBE(y), fn))
            }
            ,
            exports.poseidonHashSingle = function(x, fn=exports.poseidonSmall) {
                return fn([x, 0n, 1n])[0]
            }
            ,
            exports.poseidonHashMany = function(values, fn=exports.poseidonSmall) {
                const {m, rate} = fn;
                if (!Array.isArray(values))
                    throw new Error("bigint array expected in values");
                const padded = Array.from(values);
                for (padded.push(1n); padded.length % rate != 0; )
                    padded.push(0n);
                let state = new Array(m).fill(0n);
                for (let i = 0; i < padded.length; i += rate) {
                    for (let j = 0; j < rate; j++)
                        state[j] += padded[i + j];
                    state = fn(state)
                }
                return state[0]
            }
        }
        ,
        36060: (__unused_webpack_module,exports)=>{
            "use strict";
            function number(n) {
                if (!Number.isSafeInteger(n) || n < 0)
                    throw new Error(`Wrong positive integer: ${n}`)
            }
            function bool(b) {
                if ("boolean" != typeof b)
                    throw new Error(`Expected boolean, not ${b}`)
            }
            function bytes(b, ...lengths) {
                if (!((a = b)instanceof Uint8Array || null != a && "object" == typeof a && "Uint8Array" === a.constructor.name))
                    throw new Error("Expected Uint8Array");
                var a;
                if (lengths.length > 0 && !lengths.includes(b.length))
                    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`)
            }
            function hash(hash) {
                if ("function" != typeof hash || "function" != typeof hash.create)
                    throw new Error("Hash should be wrapped by utils.wrapConstructor");
                number(hash.outputLen),
                number(hash.blockLen)
            }
            function exists(instance, checkFinished=!0) {
                if (instance.destroyed)
                    throw new Error("Hash instance has been destroyed");
                if (checkFinished && instance.finished)
                    throw new Error("Hash#digest() has already been called")
            }
            function output(out, instance) {
                bytes(out);
                const min = instance.outputLen;
                if (out.length < min)
                    throw new Error(`digestInto() expects output buffer of length at least ${min}`)
            }
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0,
            exports.number = number,
            exports.bool = bool,
            exports.bytes = bytes,
            exports.hash = hash,
            exports.exists = exists,
            exports.output = output;
            const assert = {
                number,
                bool,
                bytes,
                hash,
                exists,
                output
            };
            exports.default = assert
        }
        ,
        69273: (__unused_webpack_module,exports,__webpack_require__)=>{
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.SHA2 = void 0;
            const _assert_js_1 = __webpack_require__(36060)
              , utils_js_1 = __webpack_require__(9617);
            class SHA2 extends utils_js_1.Hash {
                constructor(blockLen, outputLen, padOffset, isLE) {
                    super(),
                    this.blockLen = blockLen,
                    this.outputLen = outputLen,
                    this.padOffset = padOffset,
                    this.isLE = isLE,
                    this.finished = !1,
                    this.length = 0,
                    this.pos = 0,
                    this.destroyed = !1,
                    this.buffer = new Uint8Array(blockLen),
                    this.view = (0,
                    utils_js_1.createView)(this.buffer)
                }
                update(data) {
                    (0,
                    _assert_js_1.exists)(this);
                    const {view, buffer, blockLen} = this
                      , len = (data = (0,
                    utils_js_1.toBytes)(data)).length;
                    for (let pos = 0; pos < len; ) {
                        const take = Math.min(blockLen - this.pos, len - pos);
                        if (take !== blockLen)
                            buffer.set(data.subarray(pos, pos + take), this.pos),
                            this.pos += take,
                            pos += take,
                            this.pos === blockLen && (this.process(view, 0),
                            this.pos = 0);
                        else {
                            const dataView = (0,
                            utils_js_1.createView)(data);
                            for (; blockLen <= len - pos; pos += blockLen)
                                this.process(dataView, pos)
                        }
                    }
                    return this.length += data.length,
                    this.roundClean(),
                    this
                }
                digestInto(out) {
                    (0,
                    _assert_js_1.exists)(this),
                    (0,
                    _assert_js_1.output)(out, this),
                    this.finished = !0;
                    const {buffer, view, blockLen, isLE} = this;
                    let {pos} = this;
                    buffer[pos++] = 128,
                    this.buffer.subarray(pos).fill(0),
                    this.padOffset > blockLen - pos && (this.process(view, 0),
                    pos = 0);
                    for (let i = pos; i < blockLen; i++)
                        buffer[i] = 0;
                    !function(view, byteOffset, value, isLE) {
                        if ("function" == typeof view.setBigUint64)
                            return view.setBigUint64(byteOffset, value, isLE);
                        const _32n = BigInt(32)
                          , _u32_max = BigInt(4294967295)
                          , wh = Number(value >> _32n & _u32_max)
                          , wl = Number(value & _u32_max)
                          , h = isLE ? 4 : 0
                          , l = isLE ? 0 : 4;
                        view.setUint32(byteOffset + h, wh, isLE),
                        view.setUint32(byteOffset + l, wl, isLE)
                    }(view, blockLen - 8, BigInt(8 * this.length), isLE),
                    this.process(view, 0);
                    const oview = (0,
                    utils_js_1.createView)(out)
                      , len = this.outputLen;
                    if (len % 4)
                        throw new Error("_sha2: outputLen should be aligned to 32bit");
                    const outLen = len / 4
                      , state = this.get();
                    if (outLen > state.length)
                        throw new Error("_sha2: outputLen bigger than state");
                    for (let i = 0; i < outLen; i++)
                        oview.setUint32(4 * i, state[i], isLE)
                }
                digest() {
                    const {buffer, outputLen} = this;
                    this.digestInto(buffer);
                    const res = buffer.slice(0, outputLen);
                    return this.destroy(),
                    res
                }
                _cloneInto(to) {
                    to || (to = new this.constructor),
                    to.set(...this.get());
                    const {blockLen, buffer, length, finished, destroyed, pos} = this;
                    return to.length = length,
                    to.pos = pos,
                    to.finished = finished,
                    to.destroyed = destroyed,
                    length % blockLen && to.buffer.set(buffer),
                    to
                }
            }
            exports.SHA2 = SHA2
        }
        ,
        1092: (__unused_webpack_module,exports)=>{
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = void 0;
            const U32_MASK64 = BigInt(2 ** 32 - 1)
              , _32n = BigInt(32);
            function fromBig(n, le=!1) {
                return le ? {
                    h: Number(n & U32_MASK64),
                    l: Number(n >> _32n & U32_MASK64)
                } : {
                    h: 0 | Number(n >> _32n & U32_MASK64),
                    l: 0 | Number(n & U32_MASK64)
                }
            }
            function split(lst, le=!1) {
                let Ah = new Uint32Array(lst.length)
                  , Al = new Uint32Array(lst.length);
                for (let i = 0; i < lst.length; i++) {
                    const {h, l} = fromBig(lst[i], le);
                    [Ah[i],Al[i]] = [h, l]
                }
                return [Ah, Al]
            }
            exports.fromBig = fromBig,
            exports.split = split;
            const toBig = (h,l)=>BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
            exports.toBig = toBig;
            const shrSH = (h,_l,s)=>h >>> s;
            exports.shrSH = shrSH;
            const shrSL = (h,l,s)=>h << 32 - s | l >>> s;
            exports.shrSL = shrSL;
            const rotrSH = (h,l,s)=>h >>> s | l << 32 - s;
            exports.rotrSH = rotrSH;
            const rotrSL = (h,l,s)=>h << 32 - s | l >>> s;
            exports.rotrSL = rotrSL;
            const rotrBH = (h,l,s)=>h << 64 - s | l >>> s - 32;
            exports.rotrBH = rotrBH;
            const rotrBL = (h,l,s)=>h >>> s - 32 | l << 64 - s;
            exports.rotrBL = rotrBL;
            const rotr32H = (_h,l)=>l;
            exports.rotr32H = rotr32H;
            const rotr32L = (h,_l)=>h;
            exports.rotr32L = rotr32L;
            const rotlSH = (h,l,s)=>h << s | l >>> 32 - s;
            exports.rotlSH = rotlSH;
            const rotlSL = (h,l,s)=>l << s | h >>> 32 - s;
            exports.rotlSL = rotlSL;
            const rotlBH = (h,l,s)=>l << s - 32 | h >>> 64 - s;
            exports.rotlBH = rotlBH;
            const rotlBL = (h,l,s)=>h << s - 32 | l >>> 64 - s;
            function add(Ah, Al, Bh, Bl) {
                const l = (Al >>> 0) + (Bl >>> 0);
                return {
                    h: Ah + Bh + (l / 2 ** 32 | 0) | 0,
                    l: 0 | l
                }
            }
            exports.rotlBL = rotlBL,
            exports.add = add;
            const add3L = (Al,Bl,Cl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
            exports.add3L = add3L;
            const add3H = (low,Ah,Bh,Ch)=>Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
            exports.add3H = add3H;
            const add4L = (Al,Bl,Cl,Dl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
            exports.add4L = add4L;
            const add4H = (low,Ah,Bh,Ch,Dh)=>Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
            exports.add4H = add4H;
            const add5L = (Al,Bl,Cl,Dl,El)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
            exports.add5L = add5L;
            const add5H = (low,Ah,Bh,Ch,Dh,Eh)=>Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
            exports.add5H = add5H;
            const u64 = {
                fromBig,
                split,
                toBig,
                shrSH,
                shrSL,
                rotrSH,
                rotrSL,
                rotrBH,
                rotrBL,
                rotr32H,
                rotr32L,
                rotlSH,
                rotlSL,
                rotlBH,
                rotlBL,
                add,
                add3L,
                add3H,
                add4L,
                add4H,
                add5H,
                add5L
            };
            exports.default = u64
        }
        ,
        34786: (__unused_webpack_module,exports)=>{
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.crypto = void 0,
            exports.crypto = "object" == typeof globalThis && "crypto"in globalThis ? globalThis.crypto : void 0
        }
        ,
        326: (__unused_webpack_module,exports,__webpack_require__)=>{
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.sha224 = exports.sha256 = void 0;
            const _sha2_js_1 = __webpack_require__(69273)
              , utils_js_1 = __webpack_require__(9617)
              , Maj = (a,b,c)=>a & b ^ a & c ^ b & c
              , SHA256_K = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298])
              , IV = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225])
              , SHA256_W = new Uint32Array(64);
            class SHA256 extends _sha2_js_1.SHA2 {
                constructor() {
                    super(64, 32, 8, !1),
                    this.A = 0 | IV[0],
                    this.B = 0 | IV[1],
                    this.C = 0 | IV[2],
                    this.D = 0 | IV[3],
                    this.E = 0 | IV[4],
                    this.F = 0 | IV[5],
                    this.G = 0 | IV[6],
                    this.H = 0 | IV[7]
                }
                get() {
                    const {A, B, C, D, E, F, G, H} = this;
                    return [A, B, C, D, E, F, G, H]
                }
                set(A, B, C, D, E, F, G, H) {
                    this.A = 0 | A,
                    this.B = 0 | B,
                    this.C = 0 | C,
                    this.D = 0 | D,
                    this.E = 0 | E,
                    this.F = 0 | F,
                    this.G = 0 | G,
                    this.H = 0 | H
                }
                process(view, offset) {
                    for (let i = 0; i < 16; i++,
                    offset += 4)
                        SHA256_W[i] = view.getUint32(offset, !1);
                    for (let i = 16; i < 64; i++) {
                        const W15 = SHA256_W[i - 15]
                          , W2 = SHA256_W[i - 2]
                          , s0 = (0,
                        utils_js_1.rotr)(W15, 7) ^ (0,
                        utils_js_1.rotr)(W15, 18) ^ W15 >>> 3
                          , s1 = (0,
                        utils_js_1.rotr)(W2, 17) ^ (0,
                        utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
                        SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0
                    }
                    let {A, B, C, D, E, F, G, H} = this;
                    for (let i = 0; i < 64; i++) {
                        const T1 = H + ((0,
                        utils_js_1.rotr)(E, 6) ^ (0,
                        utils_js_1.rotr)(E, 11) ^ (0,
                        utils_js_1.rotr)(E, 25)) + ((a = E) & F ^ ~a & G) + SHA256_K[i] + SHA256_W[i] | 0
                          , T2 = ((0,
                        utils_js_1.rotr)(A, 2) ^ (0,
                        utils_js_1.rotr)(A, 13) ^ (0,
                        utils_js_1.rotr)(A, 22)) + Maj(A, B, C) | 0;
                        H = G,
                        G = F,
                        F = E,
                        E = D + T1 | 0,
                        D = C,
                        C = B,
                        B = A,
                        A = T1 + T2 | 0
                    }
                    var a;
                    A = A + this.A | 0,
                    B = B + this.B | 0,
                    C = C + this.C | 0,
                    D = D + this.D | 0,
                    E = E + this.E | 0,
                    F = F + this.F | 0,
                    G = G + this.G | 0,
                    H = H + this.H | 0,
                    this.set(A, B, C, D, E, F, G, H)
                }
                roundClean() {
                    SHA256_W.fill(0)
                }
                destroy() {
                    this.set(0, 0, 0, 0, 0, 0, 0, 0),
                    this.buffer.fill(0)
                }
            }
            class SHA224 extends SHA256 {
                constructor() {
                    super(),
                    this.A = -1056596264,
                    this.B = 914150663,
                    this.C = 812702999,
                    this.D = -150054599,
                    this.E = -4191439,
                    this.F = 1750603025,
                    this.G = 1694076839,
                    this.H = -1090891868,
                    this.outputLen = 28
                }
            }
            exports.sha256 = (0,
            utils_js_1.wrapConstructor)((()=>new SHA256)),
            exports.sha224 = (0,
            utils_js_1.wrapConstructor)((()=>new SHA224))
        }
        ,
        31258: (__unused_webpack_module,exports,__webpack_require__)=>{
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;
            const _assert_js_1 = __webpack_require__(36060)
              , _u64_js_1 = __webpack_require__(1092)
              , utils_js_1 = __webpack_require__(9617)
              , [SHA3_PI,SHA3_ROTL,_SHA3_IOTA] = [[], [], []]
              , _0n = BigInt(0)
              , _1n = BigInt(1)
              , _2n = BigInt(2)
              , _7n = BigInt(7)
              , _256n = BigInt(256)
              , _0x71n = BigInt(113);
            for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
                [x,y] = [y, (2 * x + 3 * y) % 5],
                SHA3_PI.push(2 * (5 * y + x)),
                SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
                let t = _0n;
                for (let j = 0; j < 7; j++)
                    R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n,
                    R & _2n && (t ^= _1n << (_1n << BigInt(j)) - _1n);
                _SHA3_IOTA.push(t)
            }
            const [SHA3_IOTA_H,SHA3_IOTA_L] = (0,
            _u64_js_1.split)(_SHA3_IOTA, !0)
              , rotlH = (h,l,s)=>s > 32 ? (0,
            _u64_js_1.rotlBH)(h, l, s) : (0,
            _u64_js_1.rotlSH)(h, l, s)
              , rotlL = (h,l,s)=>s > 32 ? (0,
            _u64_js_1.rotlBL)(h, l, s) : (0,
            _u64_js_1.rotlSL)(h, l, s);
            function keccakP(s, rounds=24) {
                const B = new Uint32Array(10);
                for (let round = 24 - rounds; round < 24; round++) {
                    for (let x = 0; x < 10; x++)
                        B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
                    for (let x = 0; x < 10; x += 2) {
                        const idx1 = (x + 8) % 10
                          , idx0 = (x + 2) % 10
                          , B0 = B[idx0]
                          , B1 = B[idx0 + 1]
                          , Th = rotlH(B0, B1, 1) ^ B[idx1]
                          , Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
                        for (let y = 0; y < 50; y += 10)
                            s[x + y] ^= Th,
                            s[x + y + 1] ^= Tl
                    }
                    let curH = s[2]
                      , curL = s[3];
                    for (let t = 0; t < 24; t++) {
                        const shift = SHA3_ROTL[t]
                          , Th = rotlH(curH, curL, shift)
                          , Tl = rotlL(curH, curL, shift)
                          , PI = SHA3_PI[t];
                        curH = s[PI],
                        curL = s[PI + 1],
                        s[PI] = Th,
                        s[PI + 1] = Tl
                    }
                    for (let y = 0; y < 50; y += 10) {
                        for (let x = 0; x < 10; x++)
                            B[x] = s[y + x];
                        for (let x = 0; x < 10; x++)
                            s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10]
                    }
                    s[0] ^= SHA3_IOTA_H[round],
                    s[1] ^= SHA3_IOTA_L[round]
                }
                B.fill(0)
            }
            exports.keccakP = keccakP;
            class Keccak extends utils_js_1.Hash {
                constructor(blockLen, suffix, outputLen, enableXOF=!1, rounds=24) {
                    if (super(),
                    this.blockLen = blockLen,
                    this.suffix = suffix,
                    this.outputLen = outputLen,
                    this.enableXOF = enableXOF,
                    this.rounds = rounds,
                    this.pos = 0,
                    this.posOut = 0,
                    this.finished = !1,
                    this.destroyed = !1,
                    (0,
                    _assert_js_1.number)(outputLen),
                    0 >= this.blockLen || this.blockLen >= 200)
                        throw new Error("Sha3 supports only keccak-f1600 function");
                    this.state = new Uint8Array(200),
                    this.state32 = (0,
                    utils_js_1.u32)(this.state)
                }
                keccak() {
                    keccakP(this.state32, this.rounds),
                    this.posOut = 0,
                    this.pos = 0
                }
                update(data) {
                    (0,
                    _assert_js_1.exists)(this);
                    const {blockLen, state} = this
                      , len = (data = (0,
                    utils_js_1.toBytes)(data)).length;
                    for (let pos = 0; pos < len; ) {
                        const take = Math.min(blockLen - this.pos, len - pos);
                        for (let i = 0; i < take; i++)
                            state[this.pos++] ^= data[pos++];
                        this.pos === blockLen && this.keccak()
                    }
                    return this
                }
                finish() {
                    if (this.finished)
                        return;
                    this.finished = !0;
                    const {state, suffix, pos, blockLen} = this;
                    state[pos] ^= suffix,
                    0 != (128 & suffix) && pos === blockLen - 1 && this.keccak(),
                    state[blockLen - 1] ^= 128,
                    this.keccak()
                }
                writeInto(out) {
                    (0,
                    _assert_js_1.exists)(this, !1),
                    (0,
                    _assert_js_1.bytes)(out),
                    this.finish();
                    const bufferOut = this.state
                      , {blockLen} = this;
                    for (let pos = 0, len = out.length; pos < len; ) {
                        this.posOut >= blockLen && this.keccak();
                        const take = Math.min(blockLen - this.posOut, len - pos);
                        out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos),
                        this.posOut += take,
                        pos += take
                    }
                    return out
                }
                xofInto(out) {
                    if (!this.enableXOF)
                        throw new Error("XOF is not possible for this instance");
                    return this.writeInto(out)
                }
                xof(bytes) {
                    return (0,
                    _assert_js_1.number)(bytes),
                    this.xofInto(new Uint8Array(bytes))
                }
                digestInto(out) {
                    if ((0,
                    _assert_js_1.output)(out, this),
                    this.finished)
                        throw new Error("digest() was already called");
                    return this.writeInto(out),
                    this.destroy(),
                    out
                }
                digest() {
                    return this.digestInto(new Uint8Array(this.outputLen))
                }
                destroy() {
                    this.destroyed = !0,
                    this.state.fill(0)
                }
                _cloneInto(to) {
                    const {blockLen, suffix, outputLen, rounds, enableXOF} = this;
                    return to || (to = new Keccak(blockLen,suffix,outputLen,enableXOF,rounds)),
                    to.state32.set(this.state32),
                    to.pos = this.pos,
                    to.posOut = this.posOut,
                    to.finished = this.finished,
                    to.rounds = rounds,
                    to.suffix = suffix,
                    to.outputLen = outputLen,
                    to.enableXOF = enableXOF,
                    to.destroyed = this.destroyed,
                    to
                }
            }
            exports.Keccak = Keccak;
            const gen = (suffix,blockLen,outputLen)=>(0,
            utils_js_1.wrapConstructor)((()=>new Keccak(blockLen,suffix,outputLen)));
            exports.sha3_224 = gen(6, 144, 28),
            exports.sha3_256 = gen(6, 136, 32),
            exports.sha3_384 = gen(6, 104, 48),
            exports.sha3_512 = gen(6, 72, 64),
            exports.keccak_224 = gen(1, 144, 28),
            exports.keccak_256 = gen(1, 136, 32),
            exports.keccak_384 = gen(1, 104, 48),
            exports.keccak_512 = gen(1, 72, 64);
            const genShake = (suffix,blockLen,outputLen)=>(0,
            utils_js_1.wrapXOFConstructorWithOpts)(((opts={})=>new Keccak(blockLen,suffix,void 0 === opts.dkLen ? outputLen : opts.dkLen,!0)));
            exports.shake128 = genShake(31, 168, 16),
            exports.shake256 = genShake(31, 136, 32)
        }
        ,
        9617: (__unused_webpack_module,exports,__webpack_require__)=>{
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
            const crypto_1 = __webpack_require__(34786);
            exports.u8 = arr=>new Uint8Array(arr.buffer,arr.byteOffset,arr.byteLength);
            function isBytes(a) {
                return a instanceof Uint8Array || null != a && "object" == typeof a && "Uint8Array" === a.constructor.name
            }
            exports.u32 = arr=>new Uint32Array(arr.buffer,arr.byteOffset,Math.floor(arr.byteLength / 4));
            exports.createView = arr=>new DataView(arr.buffer,arr.byteOffset,arr.byteLength);
            if (exports.rotr = (word,shift)=>word << 32 - shift | word >>> shift,
            exports.isLE = 68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0],
            !exports.isLE)
                throw new Error("Non little-endian hardware is not supported");
            const hexes = Array.from({
                length: 256
            }, ((_,i)=>i.toString(16).padStart(2, "0")));
            exports.bytesToHex = function(bytes) {
                if (!isBytes(bytes))
                    throw new Error("Uint8Array expected");
                let hex = "";
                for (let i = 0; i < bytes.length; i++)
                    hex += hexes[bytes[i]];
                return hex
            }
            ;
            const asciis = {
                _0: 48,
                _9: 57,
                _A: 65,
                _F: 70,
                _a: 97,
                _f: 102
            };
            function asciiToBase16(char) {
                return char >= asciis._0 && char <= asciis._9 ? char - asciis._0 : char >= asciis._A && char <= asciis._F ? char - (asciis._A - 10) : char >= asciis._a && char <= asciis._f ? char - (asciis._a - 10) : void 0
            }
            exports.hexToBytes = function(hex) {
                if ("string" != typeof hex)
                    throw new Error("hex string expected, got " + typeof hex);
                const hl = hex.length
                  , al = hl / 2;
                if (hl % 2)
                    throw new Error("padded hex string expected, got unpadded hex of length " + hl);
                const array = new Uint8Array(al);
                for (let ai = 0, hi = 0; ai < al; ai++,
                hi += 2) {
                    const n1 = asciiToBase16(hex.charCodeAt(hi))
                      , n2 = asciiToBase16(hex.charCodeAt(hi + 1));
                    if (void 0 === n1 || void 0 === n2) {
                        const char = hex[hi] + hex[hi + 1];
                        throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi)
                    }
                    array[ai] = 16 * n1 + n2
                }
                return array
            }
            ;
            function utf8ToBytes(str) {
                if ("string" != typeof str)
                    throw new Error("utf8ToBytes expected string, got " + typeof str);
                return new Uint8Array((new TextEncoder).encode(str))
            }
            function toBytes(data) {
                if ("string" == typeof data && (data = utf8ToBytes(data)),
                !isBytes(data))
                    throw new Error("expected Uint8Array, got " + typeof data);
                return data
            }
            exports.nextTick = async()=>{}
            ,
            exports.asyncLoop = async function(iters, tick, cb) {
                let ts = Date.now();
                for (let i = 0; i < iters; i++) {
                    cb(i);
                    const diff = Date.now() - ts;
                    diff >= 0 && diff < tick || (await (0,
                    exports.nextTick)(),
                    ts += diff)
                }
            }
            ,
            exports.utf8ToBytes = utf8ToBytes,
            exports.toBytes = toBytes,
            exports.concatBytes = function(...arrays) {
                let sum = 0;
                for (let i = 0; i < arrays.length; i++) {
                    const a = arrays[i];
                    if (!isBytes(a))
                        throw new Error("Uint8Array expected");
                    sum += a.length
                }
                const res = new Uint8Array(sum);
                for (let i = 0, pad = 0; i < arrays.length; i++) {
                    const a = arrays[i];
                    res.set(a, pad),
                    pad += a.length
                }
                return res
            }
            ;
            exports.Hash = class {
                clone() {
                    return this._cloneInto()
                }
            }
            ;
            const toStr = {}.toString;
            exports.checkOpts = function(defaults, opts) {
                if (void 0 !== opts && "[object Object]" !== toStr.call(opts))
                    throw new Error("Options should be object or undefined");
                return Object.assign(defaults, opts)
            }
            ,
            exports.wrapConstructor = function(hashCons) {
                const hashC = msg=>hashCons().update(toBytes(msg)).digest()
                  , tmp = hashCons();
                return hashC.outputLen = tmp.outputLen,
                hashC.blockLen = tmp.blockLen,
                hashC.create = ()=>hashCons(),
                hashC
            }
            ,
            exports.wrapConstructorWithOpts = function(hashCons) {
                const hashC = (msg,opts)=>hashCons(opts).update(toBytes(msg)).digest()
                  , tmp = hashCons({});
                return hashC.outputLen = tmp.outputLen,
                hashC.blockLen = tmp.blockLen,
                hashC.create = opts=>hashCons(opts),
                hashC
            }
            ,
            exports.wrapXOFConstructorWithOpts = function(hashCons) {
                const hashC = (msg,opts)=>hashCons(opts).update(toBytes(msg)).digest()
                  , tmp = hashCons({});
                return hashC.outputLen = tmp.outputLen,
                hashC.blockLen = tmp.blockLen,
                hashC.create = opts=>hashCons(opts),
                hashC
            }
            ,
            exports.randomBytes = function(bytesLength=32) {
                if (crypto_1.crypto && "function" == typeof crypto_1.crypto.getRandomValues)
                    return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
                throw new Error("crypto.getRandomValues must be defined")
            }
        }
        ,
        13023: (__unused_webpack_module,exports)=>{
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.BASE64_SVG_PREFIX = void 0;
            exports.BASE64_SVG_PREFIX = "data:image/svg+xml;base64,"
        }
        ,
        53453: (__unused_webpack_module,exports,__webpack_require__)=>{
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.default = void 0;
            var _default = `${__webpack_require__(13023).BASE64_SVG_PREFIX}${btoa('<svg width="100" height="100" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">\n    <path\n        d="M62.705 13.9116C62.8359 14.1333 62.6621 14.407 62.4039 14.407C57.1807 14.407 52.9348 18.5427 52.8351 23.6817C51.0465 23.3477 49.1933 23.3226 47.3626 23.6311C47.2361 18.5156 43.0009 14.407 37.7948 14.407C37.5365 14.407 37.3625 14.1331 37.4935 13.9112C40.0217 9.62809 44.7204 6.75 50.0991 6.75C55.4781 6.75 60.1769 9.62826 62.705 13.9116Z"\n        fill="url(#paint0_linear_372_40259)" />\n    <path\n        d="M78.7606 45.8718C80.2725 46.3297 81.7025 45.0055 81.1714 43.5222C76.4137 30.2334 61.3911 24.8039 50.0277 24.8039C38.6442 24.8039 23.2868 30.407 18.8754 43.5912C18.3824 45.0645 19.8083 46.3446 21.2978 45.8881L48.872 37.4381C49.5331 37.2355 50.2399 37.2344 50.9017 37.4348L78.7606 45.8718Z"\n        fill="url(#paint1_linear_372_40259)" />\n    <path\n        d="M18.8132 48.1707L48.8935 39.0472C49.5506 38.8478 50.2524 38.8473 50.9098 39.0456L81.1781 48.1752C83.6912 48.9332 85.411 51.2483 85.411 53.8735V81.2233C85.2944 87.8991 79.2977 93.25 72.6245 93.25H61.5406C60.4449 93.25 59.5577 92.3637 59.5577 91.268V81.6789C59.5577 77.9031 61.7921 74.4855 65.2498 72.9729C69.8849 70.9454 75.3681 68.2028 76.3994 62.6992C76.7323 60.9229 75.5741 59.2094 73.8024 58.8573C69.3226 57.9667 64.3562 58.3107 60.1564 60.1893C55.3887 62.3219 54.1415 65.8694 53.6797 70.6337L53.1201 75.7662C52.9491 77.3349 51.4785 78.5366 49.9014 78.5366C48.2699 78.5366 47.0465 77.294 46.8696 75.6712L46.3204 70.6337C45.9249 66.5529 45.2079 62.5887 40.9895 60.7018C36.1776 58.5494 31.3419 57.8347 26.1976 58.8573C24.426 59.2094 23.2678 60.9229 23.6007 62.6992C24.641 68.2507 30.0812 70.9305 34.7503 72.9729C38.208 74.4855 40.4424 77.9031 40.4424 81.6789V91.2663C40.4424 92.362 39.5555 93.25 38.4599 93.25H27.3756C20.7024 93.25 14.7057 87.8991 14.5891 81.2233V53.8663C14.5891 51.2446 16.3045 48.9316 18.8132 48.1707Z"\n        fill="url(#paint2_linear_372_40259)" />\n    <defs>\n        <linearGradient id="paint0_linear_372_40259" x1="49.3057" y1="2.079" x2="80.3627" y2="93.6597"\n            gradientUnits="userSpaceOnUse">\n            <stop stop-color="#F5D45E" />\n            <stop offset="1" stop-color="#FF9600" />\n        </linearGradient>\n        <linearGradient id="paint1_linear_372_40259" x1="49.3057" y1="2.079" x2="80.3627" y2="93.6597"\n            gradientUnits="userSpaceOnUse">\n            <stop stop-color="#F5D45E" />\n            <stop offset="1" stop-color="#FF9600" />\n        </linearGradient>\n        <linearGradient id="paint2_linear_372_40259" x1="49.3057" y1="2.079" x2="80.3627" y2="93.6597"\n            gradientUnits="userSpaceOnUse">\n            <stop stop-color="#F5D45E" />\n            <stop offset="1" stop-color="#FF9600" />\n        </linearGradient>\n    </defs>\n</svg>')}`;
            exports.default = _default
        }
        ,
        34565: (__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{
            var _interopRequireDefault = __webpack_require__(64836)
              , _classCallCheck2 = _interopRequireDefault(__webpack_require__(56690))
              , _createClass2 = _interopRequireDefault(__webpack_require__(89728))
              , _inherits2 = _interopRequireDefault(__webpack_require__(61655))
              , _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(94993))
              , _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(73808))
              , _StarknetWindowObject2 = __webpack_require__(58511)
              , _sameOriginListener = _interopRequireDefault(__webpack_require__(31642))
              , _dappRequests = _interopRequireDefault(__webpack_require__(64534));
            function _createSuper(t) {
                var r = _isNativeReflectConstruct();
                return function() {
                    var e, o = (0,
                    _getPrototypeOf2.default)(t);
                    if (r) {
                        var s = (0,
                        _getPrototypeOf2.default)(this).constructor;
                        e = Reflect.construct(o, arguments, s)
                    } else
                        e = o.apply(this, arguments);
                    return (0,
                    _possibleConstructorReturn2.default)(this, e)
                }
            }
            function _isNativeReflectConstruct() {
                try {
                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}
                    )))
                } catch (t) {}
                return (_isNativeReflectConstruct = function() {
                    return !!t
                }
                )()
            }
            var starknetWindowObject = new (function(_StarknetWindowObject) {
                (0,
                _inherits2.default)(ExtStarknetWindowObject, _StarknetWindowObject);
                var _super = _createSuper(ExtStarknetWindowObject);
                function ExtStarknetWindowObject() {
                    var _this;
                    return (0,
                    _classCallCheck2.default)(this, ExtStarknetWindowObject),
                    _this = _super.call(this),
                    (0,
                    _sameOriginListener.default)((function(_ref) {
                        var message = _ref.data;
                        _this.handleIncomingMessage(message).catch((function(err) {}
                        ))
                    }
                    )),
                    _this
                }
                return (0,
                _createClass2.default)(ExtStarknetWindowObject, [{
                    key: "sendMessageFromInpageToContent",
                    value: function(_msg) {
                        return new Promise((function(resolve) {
                            var msg = JSON.parse(JSON.stringify(_msg))
                              , uid = _dappRequests.default.add(msg, resolve);
                            window.postMessage(Object.assign({}, msg, {
                                uid,
                                from: "braavos-inpage"
                            }))
                        }
                        ))
                    }
                }]),
                ExtStarknetWindowObject
            }(_StarknetWindowObject2.StarknetWindowObject))
              , validateAttached = function() {
                try {
                    window.starknet_braavos = starknetWindowObject
                } catch (_unused) {}
                try {
                    window.starknet = starknetWindowObject
                } catch (_unused2) {}
            };
            validateAttached(),
            window.addEventListener("load", (function() {
                return validateAttached()
            }
            )),
            document.addEventListener("readystatechange", (function() {
                return validateAttached()
            }
            )),
            document.addEventListener("DOMContentLoaded", (function() {
                return validateAttached()
            }
            ))
        }
        ,
        31642: (__unused_webpack_module,exports)=>{
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.default = function(callback, options) {
                var initOrigin = window.location.origin
                  , innerCallback = function(event) {
                    event.origin === initOrigin && event.source === window && callback(event)
                };
                return window.addEventListener("message", innerCallback, options),
                function() {
                    return window.removeEventListener("message", innerCallback)
                }
            }
        }
        ,
        58511: (__unused_webpack_module,exports,__webpack_require__)=>{
            var _interopRequireDefault = __webpack_require__(64836);
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.getDevnetProvider = exports.getChainIdForNetwork = exports.StarknetWindowObject = void 0;
            var _slicedToArray2 = _interopRequireDefault(__webpack_require__(27424))
              , _inherits2 = _interopRequireDefault(__webpack_require__(61655))
              , _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(94993))
              , _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(73808))
              , _toConsumableArray2 = _interopRequireDefault(__webpack_require__(861))
              , _classCallCheck2 = _interopRequireDefault(__webpack_require__(56690))
              , _createClass2 = _interopRequireDefault(__webpack_require__(89728))
              , _classPrivateFieldLooseBase2 = _interopRequireDefault(__webpack_require__(29399))
              , _classPrivateFieldLooseKey2 = _interopRequireDefault(__webpack_require__(40426))
              , _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(17156))
              , _starknetTypes = __webpack_require__(19765)
              , _starknet_v = __webpack_require__(84817)
              , _starknet_v2 = __webpack_require__(69131)
              , _dappRequests = _interopRequireDefault(__webpack_require__(64534))
              , _message = __webpack_require__(23631)
              , _logoBase = _interopRequireDefault(__webpack_require__(53453));
            function _createSuper(t) {
                var r = _isNativeReflectConstruct();
                return function() {
                    var e, o = (0,
                    _getPrototypeOf2.default)(t);
                    if (r) {
                        var s = (0,
                        _getPrototypeOf2.default)(this).constructor;
                        e = Reflect.construct(o, arguments, s)
                    } else
                        e = o.apply(this, arguments);
                    return (0,
                    _possibleConstructorReturn2.default)(this, e)
                }
            }
            function _isNativeReflectConstruct() {
                try {
                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}
                    )))
                } catch (t) {}
                return (_isNativeReflectConstruct = function() {
                    return !!t
                }
                )()
            }
            function getPublicRpcForNetwork(network) {
                switch (network) {
                case "mainnet-alpha":
                    return "https://starknet-mainnet.public.blastapi.io";
                case "sepolia-alpha":
                    return "https://starknet-sepolia.public.blastapi.io";
                default:
                    throw new Error(`No public RPC endpoint for network: ${network}`)
                }
            }
            var getChainIdForNetwork = function(network) {
                switch (network) {
                case "mainnet-alpha":
                    return _starknet_v.constants.StarknetChainId.SN_MAIN;
                case "sepolia-alpha":
                    return _starknet_v.constants.StarknetChainId.SN_SEPOLIA;
                default:
                    return
                }
            };
            exports.getChainIdForNetwork = getChainIdForNetwork;
            var _ref, getDevnetProvider = (_ref = (0,
            _asyncToGenerator2.default)((function*(baseUrl, nodeType) {
                var v4 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                switch (nodeType) {
                case "rpc":
                    var options = {
                        nodeUrl: baseUrl,
                        blockIdentifier: "pending"
                    };
                    return v4 ? new _starknet_v2.RpcProvider(options) : new _starknet_v.RpcProvider(options);
                case "sequencer":
                    var _options = {
                        baseUrl
                    };
                    return v4 ? new _starknet_v2.SequencerProvider(_options) : new _starknet_v.SequencerProvider(_options)
                }
            }
            )),
            function(_x, _x2) {
                return _ref.apply(this, arguments)
            }
            );
            exports.getDevnetProvider = getDevnetProvider;
            var _callbacks = (0,
            _classPrivateFieldLooseKey2.default)("callbacks")
              , _snjsVersion = (0,
            _classPrivateFieldLooseKey2.default)("snjsVersion")
              , _getProvider = (0,
            _classPrivateFieldLooseKey2.default)("getProvider")
              , _getWrappedAccount = (0,
            _classPrivateFieldLooseKey2.default)("getWrappedAccount")
              , _executeImpl = (0,
            _classPrivateFieldLooseKey2.default)("executeImpl")
              , _signMsgImpl = (0,
            _classPrivateFieldLooseKey2.default)("signMsgImpl")
              , _declareImpl = (0,
            _classPrivateFieldLooseKey2.default)("declareImpl")
              , _deployImpl = (0,
            _classPrivateFieldLooseKey2.default)("deployImpl")
              , StarknetWindowObject = function() {
                function StarknetWindowObject() {
                    var _this = this;
                    (0,
                    _classCallCheck2.default)(this, StarknetWindowObject),
                    Object.defineProperty(this, _getWrappedAccount, {
                        value: _getWrappedAccount2
                    }),
                    Object.defineProperty(this, _getProvider, {
                        value: _getProvider2
                    }),
                    Object.defineProperty(this, _callbacks, {
                        writable: !0,
                        value: {}
                    }),
                    this.id = "braavos",
                    this.name = "Braavos",
                    this.icon = _logoBase.default,
                    Object.defineProperty(this, _snjsVersion, {
                        writable: !0,
                        value: "v6"
                    }),
                    this.selectedAddress = void 0,
                    this.chainId = void 0,
                    this.isConnected = !1,
                    this.provider = (0,
                    _classPrivateFieldLooseBase2.default)(this, _getProvider)[_getProvider]("mainnet-alpha"),
                    this.account = new _starknet_v.Account(this.provider,"",{}),
                    Object.defineProperty(this, _executeImpl, {
                        writable: !0,
                        value: function(transactions) {
                            var calls = Array.isArray(transactions) ? transactions : [transactions];
                            return _this.sendMessageFromInpageToContent({
                                method: _message.DappMethod.INVOKE,
                                data: {
                                    calls
                                },
                                source: ""
                            }).then((function(msg) {
                                if (null == msg || !msg.txHash)
                                    throw Error("Execute failed");
                                return {
                                    transaction_hash: msg.txHash
                                }
                            }
                            ))
                        }
                    }),
                    Object.defineProperty(this, _signMsgImpl, {
                        writable: !0,
                        value: function(data) {
                            return _this.sendMessageFromInpageToContent({
                                method: _message.DappMethod.SIGN_MESSAGE,
                                data: {
                                    message: data
                                },
                                source: ""
                            }).then((function(msg) {
                                var _msg$asp$signers, _msg$asp, result = (null !== (_msg$asp$signers = null == msg || null === (_msg$asp = msg.asp) || void 0 === _msg$asp ? void 0 : _msg$asp.signers) && void 0 !== _msg$asp$signers ? _msg$asp$signers : []).reduce((function(allSignatures, _ref2) {
                                    var signature = _ref2.signature;
                                    return [].concat((0,
                                    _toConsumableArray2.default)(allSignatures), (0,
                                    _toConsumableArray2.default)(signature))
                                }
                                ), []);
                                if (null == result || !result.length)
                                    throw Error("Signature failed");
                                return result
                            }
                            ))
                        }
                    }),
                    Object.defineProperty(this, _declareImpl, {
                        writable: !0,
                        value: function(payload) {
                            return _this.sendMessageFromInpageToContent({
                                method: _message.DappMethod.DECLARE_CONTRACT,
                                data: payload,
                                source: ""
                            }).then((function(msg) {
                                if (null == msg || !msg.tx_hash)
                                    throw Error("Declare failed");
                                return {
                                    transaction_hash: msg.tx_hash,
                                    class_hash: `${payload.classHash}`
                                }
                            }
                            ))
                        }
                    }),
                    Object.defineProperty(this, _deployImpl, {
                        writable: !0,
                        value: function(payload) {
                            var data = Array.isArray(payload) ? payload : [payload];
                            return _this.sendMessageFromInpageToContent({
                                method: _message.DappMethod.DEPLOY_CONTRACT,
                                data: {
                                    payload: data
                                },
                                source: ""
                            }).then((function(msg) {
                                if (null == msg || !msg.tx_hash)
                                    throw Error("Deploy failed");
                                return {
                                    transaction_hash: msg.tx_hash,
                                    contract_address: msg.contract_address
                                }
                            }
                            ))
                        }
                    }),
                    this.version = "3.65.1"
                }
                var _handleIncomingMessage;
                return (0,
                _createClass2.default)(StarknetWindowObject, [{
                    key: "handleIncomingMessage",
                    value: (_handleIncomingMessage = (0,
                    _asyncToGenerator2.default)((function*(message) {
                        var _message$from, _data$;
                        if ("braavos-inpage" !== (null == message ? void 0 : message.from)) {
                            var uid = null == message ? void 0 : message.uid;
                            if (uid && _dappRequests.default.has(uid))
                                _dappRequests.default.resolve(uid, message.data);
                            else if (null != message && null !== (_message$from = message.from) && void 0 !== _message$from && _message$from.startsWith(_message.ConnectionType.ContentListenerBridge)) {
                                var _message$data = message.data
                                  , type = _message$data.type
                                  , data = _message$data.data;
                                switch ((0,
                                _classPrivateFieldLooseBase2.default)(this, _snjsVersion)[_snjsVersion]) {
                                case "v4":
                                case "v5":
                                    var _classPrivateFieldLoo, _classPrivateFieldLoo2, starknet = window.starknet_braavos;
                                    if (starknet)
                                        switch (type) {
                                        case "networkChanged":
                                            starknet.isConnected = !0,
                                            starknet.selectedAddress = "",
                                            starknet.provider = yield(0,
                                            _classPrivateFieldLooseBase2.default)(this, _getProvider)[_getProvider](null == data ? void 0 : data[0]),
                                            starknet.chainId = getChainIdForNetwork(null == data ? void 0 : data[0]),
                                            starknet.account = (0,
                                            _classPrivateFieldLooseBase2.default)(this, _getWrappedAccount)[_getWrappedAccount]("", starknet.provider);
                                            break;
                                        case "accountsChanged":
                                            starknet.isConnected = !(null == data || !data.length),
                                            starknet.selectedAddress = null == data ? void 0 : data[0],
                                            starknet.isConnected || (starknet.provider = yield(0,
                                            _classPrivateFieldLooseBase2.default)(this, _getProvider)[_getProvider]("mainnet-alpha"),
                                            starknet.chainId = getChainIdForNetwork("mainnet-alpha")),
                                            starknet.account = (0,
                                            _classPrivateFieldLooseBase2.default)(this, _getWrappedAccount)[_getWrappedAccount](null !== (_data$ = null == data ? void 0 : data[0]) && void 0 !== _data$ ? _data$ : "", starknet.provider)
                                        }
                                    null === (_classPrivateFieldLoo = (0,
                                    _classPrivateFieldLooseBase2.default)(this, _callbacks)[_callbacks][type]) || void 0 === _classPrivateFieldLoo || null === (_classPrivateFieldLoo2 = _classPrivateFieldLoo.listeners) || void 0 === _classPrivateFieldLoo2 || _classPrivateFieldLoo2.forEach((function(callback) {
                                        return callback(null == data ? void 0 : data[0])
                                    }
                                    ));
                                    break;
                                case "v6":
                                    var _callbackInfo$listene, _callbackInfo$lastDat, callbackInfo = (0,
                                    _classPrivateFieldLooseBase2.default)(this, _callbacks)[_callbacks][type];
                                    if (null == callbackInfo || null === (_callbackInfo$listene = callbackInfo.listeners) || void 0 === _callbackInfo$listene || !_callbackInfo$listene.length)
                                        return;
                                    if (JSON.stringify(null != data ? data : {}) === JSON.stringify(null !== (_callbackInfo$lastDat = callbackInfo.lastData) && void 0 !== _callbackInfo$lastDat ? _callbackInfo$lastDat : {}))
                                        return;
                                    callbackInfo.lastData = data,
                                    callbackInfo.listeners.forEach((function(callback) {
                                        switch (type) {
                                        case "networkChanged":
                                            callback(getChainIdForNetwork(data[0]), data[1]);
                                            break;
                                        case "accountsChanged":
                                            callback(data)
                                        }
                                    }
                                    ))
                                }
                            }
                        }
                    }
                    )),
                    function(_x3) {
                        return _handleIncomingMessage.apply(this, arguments)
                    }
                    )
                }, {
                    key: "request",
                    value: function(call) {
                        switch ((0,
                        _classPrivateFieldLooseBase2.default)(this, _snjsVersion)[_snjsVersion]) {
                        case "v4":
                        case "v5":
                            switch (call.type) {
                            case "wallet_watchAsset":
                                return this.sendMessageFromInpageToContent({
                                    method: _message.DappMethod.WATCH_ASSET,
                                    data: call.params,
                                    source: ""
                                }).then((function(res) {
                                    return !!res
                                }
                                ));
                            case "wallet_deploymentData":
                                return this.sendMessageFromInpageToContent({
                                    method: _message.DappMethod.GET_DEPLOYMENT_DATA,
                                    source: ""
                                }).then((function(res) {
                                    return res
                                }
                                ));
                            default:
                                throw new Error("Not implemented")
                            }
                        case "v6":
                            switch (call.type) {
                            case "wallet_getPermissions":
                                return this.sendMessageFromInpageToContent({
                                    method: _message.DappMethod.IS_AUTHORIZED,
                                    source: ""
                                }).then((function(msg) {
                                    return msg ? [_starknetTypes.Permission.Accounts] : []
                                }
                                ));
                            case "wallet_requestAccounts":
                                var _params, silent_mode = (null !== (_params = call.params) && void 0 !== _params ? _params : {}).silent_mode;
                                return this.sendMessageFromInpageToContent({
                                    method: _message.DappMethod.CONNECT,
                                    data: {
                                        silent_mode
                                    },
                                    source: ""
                                }).then((function(msg) {
                                    return null != msg && msg.address ? [null == msg ? void 0 : msg.address] : []
                                }
                                ));
                            case "wallet_watchAsset":
                                var _params2 = call.params
                                  , type = _params2.type
                                  , _params2$options = _params2.options
                                  , address = _params2$options.address
                                  , name = _params2$options.name
                                  , symbol = _params2$options.symbol
                                  , image = _params2$options.image
                                  , decimals = _params2$options.decimals;
                                return this.sendMessageFromInpageToContent({
                                    method: _message.DappMethod.WATCH_ASSET,
                                    data: {
                                        type,
                                        options: {
                                            address,
                                            name,
                                            symbol,
                                            image,
                                            decimals
                                        }
                                    },
                                    source: ""
                                }).then((function(res) {
                                    return !!res
                                }
                                ));
                            case "wallet_addStarknetChain":
                            case "wallet_switchStarknetChain":
                                throw new Error(`Unsupported dApp request ${call.type}`);
                            case "wallet_requestChainId":
                                return this.sendMessageFromInpageToContent({
                                    method: _message.DappMethod.GET_CHAIN_ID,
                                    source: ""
                                }).then((function(res) {
                                    return res
                                }
                                ));
                            case "wallet_deploymentData":
                                return this.sendMessageFromInpageToContent({
                                    method: _message.DappMethod.GET_DEPLOYMENT_DATA,
                                    source: ""
                                }).then((function(res) {
                                    return res
                                }
                                ));
                            case "wallet_addInvokeTransaction":
                                return this.sendMessageFromInpageToContent({
                                    method: _message.DappMethod.INVOKE,
                                    data: {
                                        calls: call.params.calls.map((function(call) {
                                            return {
                                                contractAddress: call.contract_address,
                                                entrypoint: call.entry_point,
                                                calldata: call.calldata
                                            }
                                        }
                                        ))
                                    },
                                    source: ""
                                }).then((function(msg) {
                                    if (null == msg || !msg.txHash)
                                        throw Error("Execute failed");
                                    return {
                                        transaction_hash: msg.txHash
                                    }
                                }
                                ));
                            case "wallet_addDeclareTransaction":
                                var _params3 = call.params
                                  , class_hash = _params3.class_hash
                                  , contract_class = _params3.contract_class
                                  , compiled_class_hash = _params3.compiled_class_hash;
                                return this.sendMessageFromInpageToContent({
                                    method: _message.DappMethod.DECLARE_CONTRACT,
                                    data: {
                                        classHash: class_hash,
                                        compiledClassHash: compiled_class_hash,
                                        contract: contract_class
                                    },
                                    source: ""
                                }).then((function(msg) {
                                    if (null == msg || !msg.tx_hash)
                                        throw Error("Declare failed");
                                    return {
                                        transaction_hash: msg.tx_hash,
                                        class_hash: `${msg.class_hash}`
                                    }
                                }
                                ));
                            case "wallet_signTypedData":
                                var _params4 = call.params
                                  , message = _params4.message
                                  , types = _params4.types
                                  , primaryType = _params4.primaryType
                                  , domain = _params4.domain;
                                return this.sendMessageFromInpageToContent({
                                    method: _message.DappMethod.SIGN_MESSAGE,
                                    data: {
                                        message: {
                                            message,
                                            types,
                                            primaryType,
                                            domain
                                        }
                                    },
                                    source: ""
                                }).then((function(msg) {
                                    var _msg$asp$signers2, _msg$asp2, result = (null !== (_msg$asp$signers2 = null == msg || null === (_msg$asp2 = msg.asp) || void 0 === _msg$asp2 ? void 0 : _msg$asp2.signers) && void 0 !== _msg$asp$signers2 ? _msg$asp$signers2 : []).reduce((function(allSignatures, _ref4) {
                                        var signature = _ref4.signature;
                                        return [].concat((0,
                                        _toConsumableArray2.default)(allSignatures), (0,
                                        _toConsumableArray2.default)(signature))
                                    }
                                    ), []);
                                    if (null == result || !result.length)
                                        throw Error("Signature failed");
                                    return result
                                }
                                ));
                            case "wallet_supportedSpecs":
                                return this.sendMessageFromInpageToContent({
                                    method: _message.DappMethod.GET_SUPPORTED_SPECS,
                                    source: ""
                                }).then((function(res) {
                                    return res
                                }
                                ));
                            default:
                                throw new Error("Not implemented")
                            }
                        }
                    }
                }, {
                    key: "isPreauthorized",
                    value: function() {
                        return "v6" === (0,
                        _classPrivateFieldLooseBase2.default)(this, _snjsVersion)[_snjsVersion] && ((0,
                        _classPrivateFieldLooseBase2.default)(this, _snjsVersion)[_snjsVersion] = "v5"),
                        this.sendMessageFromInpageToContent({
                            method: _message.DappMethod.IS_AUTHORIZED,
                            source: ""
                        }).then((function(msg) {
                            return !!msg
                        }
                        ))
                    }
                }, {
                    key: "on",
                    value: function(event, handleEvent) {
                        var _classPrivateFieldLoo3, currListeners = (null !== (_classPrivateFieldLoo3 = (0,
                        _classPrivateFieldLooseBase2.default)(this, _callbacks)[_callbacks][event]) && void 0 !== _classPrivateFieldLoo3 ? _classPrivateFieldLoo3 : (0,
                        _classPrivateFieldLooseBase2.default)(this, _callbacks)[_callbacks][event] = {
                            listeners: []
                        }).listeners;
                        currListeners.includes(handleEvent) || currListeners.push(handleEvent)
                    }
                }, {
                    key: "off",
                    value: function(event, handleEvent) {
                        var _classPrivateFieldLoo4;
                        null !== (_classPrivateFieldLoo4 = (0,
                        _classPrivateFieldLooseBase2.default)(this, _callbacks)[_callbacks][event]) && void 0 !== _classPrivateFieldLoo4 && _classPrivateFieldLoo4.listeners && ((0,
                        _classPrivateFieldLooseBase2.default)(this, _callbacks)[_callbacks][event].listeners = (0,
                        _classPrivateFieldLooseBase2.default)(this, _callbacks)[_callbacks][event].listeners.filter((function(callback) {
                            return callback !== handleEvent
                        }
                        )))
                    }
                }, {
                    key: "enable",
                    value: function(options) {
                        var _ref5, _this2 = this;
                        return (0,
                        _classPrivateFieldLooseBase2.default)(this, _snjsVersion)[_snjsVersion] = null != options && options.starknetVersion && ["v4", "v5"].includes(options.starknetVersion) ? options.starknetVersion : "v5",
                        this.sendMessageFromInpageToContent({
                            method: _message.DappMethod.CONNECT,
                            source: ""
                        }).then((_ref5 = (0,
                        _asyncToGenerator2.default)((function*(msg) {
                            if (!msg)
                                return [""];
                            var _window2 = window
                              , windowObj = [_window2.starknet_braavos, _window2.starknet].find((function(obj) {
                                return "braavos" === (null == obj ? void 0 : obj.id)
                            }
                            ));
                            return windowObj ? (windowObj.isConnected = !0,
                            windowObj.selectedAddress = msg.address,
                            windowObj.provider = yield(0,
                            _classPrivateFieldLooseBase2.default)(_this2, _getProvider)[_getProvider](msg.network),
                            windowObj.account = (0,
                            _classPrivateFieldLooseBase2.default)(_this2, _getWrappedAccount)[_getWrappedAccount](msg.address || "", windowObj.provider),
                            [msg.address || ""]) : [""]
                        }
                        )),
                        function(_x4) {
                            return _ref5.apply(this, arguments)
                        }
                        )).finally((function() {}
                        ))
                    }
                }]),
                StarknetWindowObject
            }();
            function _getProvider2(network) {
                var snjsVersion = "v6" === (0,
                _classPrivateFieldLooseBase2.default)(this, _snjsVersion)[_snjsVersion] ? "v5" : (0,
                _classPrivateFieldLooseBase2.default)(this, _snjsVersion)[_snjsVersion];
                if ("devnet" === network)
                    return this.sendMessageFromInpageToContent({
                        method: _message.DappMethod.GET_NODE,
                        source: ""
                    }).then((function(node) {
                        return node ? getDevnetProvider(node.url, node.type, "v4" === snjsVersion) : void 0
                    }
                    ));
                switch (snjsVersion) {
                case "v4":
                    var provider = new _starknet_v2.RpcProvider({
                        nodeUrl: getPublicRpcForNetwork(network),
                        chainId: getChainIdForNetwork(network)
                    });
                    return ["nodeUrl", "chainId", "retries", "headers", "blockIdentifier"].forEach((function(field) {
                        var _provider$provider, value = null === (_provider$provider = provider.provider) || void 0 === _provider$provider ? void 0 : _provider$provider[field];
                        value && Object.defineProperty(provider, field, {
                            value
                        })
                    }
                    )),
                    provider;
                case "v5":
                    return new _starknet_v.RpcProvider({
                        nodeUrl: getPublicRpcForNetwork(network),
                        chainId: getChainIdForNetwork(network)
                    });
                default:
                    throw new Error(`[SNWindowObj] getProvider(): Unsupported starknet.js version ${snjsVersion}`)
                }
            }
            function _getWrappedAccount2(address, provider) {
                switch ((0,
                _classPrivateFieldLooseBase2.default)(this, _snjsVersion)[_snjsVersion]) {
                case "v4":
                    return new WrappedAccountV4((0,
                    _classPrivateFieldLooseBase2.default)(this, _executeImpl)[_executeImpl],(0,
                    _classPrivateFieldLooseBase2.default)(this, _signMsgImpl)[_signMsgImpl],(0,
                    _classPrivateFieldLooseBase2.default)(this, _declareImpl)[_declareImpl],(0,
                    _classPrivateFieldLooseBase2.default)(this, _deployImpl)[_deployImpl],address,provider);
                case "v5":
                    return new WrappedAccount((0,
                    _classPrivateFieldLooseBase2.default)(this, _executeImpl)[_executeImpl],(0,
                    _classPrivateFieldLooseBase2.default)(this, _signMsgImpl)[_signMsgImpl],(0,
                    _classPrivateFieldLooseBase2.default)(this, _declareImpl)[_declareImpl],(0,
                    _classPrivateFieldLooseBase2.default)(this, _deployImpl)[_deployImpl],address,provider)
                }
            }
            exports.StarknetWindowObject = StarknetWindowObject;
            var WrappedAccount = function(_Account) {
                (0,
                _inherits2.default)(WrappedAccount, _Account);
                var _deploy, _declare, _signMessage, _execute, _super = _createSuper(WrappedAccount);
                function WrappedAccount(executeImpl, signMessageImpl, declareImpl, deployImpl, address, provider) {
                    var _this3;
                    return (0,
                    _classCallCheck2.default)(this, WrappedAccount),
                    (_this3 = _super.call(this, provider, address, "0")).executeImpl = executeImpl,
                    _this3.signMessageImpl = signMessageImpl,
                    _this3.declareImpl = declareImpl,
                    _this3.deployImpl = deployImpl,
                    _this3
                }
                return (0,
                _createClass2.default)(WrappedAccount, [{
                    key: "execute",
                    value: (_execute = (0,
                    _asyncToGenerator2.default)((function*(transactions) {
                        return this.executeImpl(transactions)
                    }
                    )),
                    function(_x5) {
                        return _execute.apply(this, arguments)
                    }
                    )
                }, {
                    key: "signMessage",
                    value: (_signMessage = (0,
                    _asyncToGenerator2.default)((function*(data) {
                        return this.signMessageImpl(data)
                    }
                    )),
                    function(_x6) {
                        return _signMessage.apply(this, arguments)
                    }
                    )
                }, {
                    key: "declare",
                    value: (_declare = (0,
                    _asyncToGenerator2.default)((function*(payload) {
                        return this.declareImpl(payload)
                    }
                    )),
                    function(_x7) {
                        return _declare.apply(this, arguments)
                    }
                    )
                }, {
                    key: "deploy",
                    value: (_deploy = (0,
                    _asyncToGenerator2.default)((function*(payload) {
                        return this.deployImpl(payload)
                    }
                    )),
                    function(_x8) {
                        return _deploy.apply(this, arguments)
                    }
                    )
                }]),
                WrappedAccount
            }(_starknet_v.Account)
              , WrappedAccountV4 = function(_AccountV) {
                (0,
                _inherits2.default)(WrappedAccountV4, _AccountV);
                var _deploy2, _declare2, _signMessage2, _execute2, _super2 = _createSuper(WrappedAccountV4);
                function WrappedAccountV4(executeImpl, signMessageImpl, declareImpl, deployImpl, address, provider) {
                    var _this4;
                    return (0,
                    _classCallCheck2.default)(this, WrappedAccountV4),
                    (_this4 = _super2.call(this, provider, address, {})).executeImpl = executeImpl,
                    _this4.signMessageImpl = signMessageImpl,
                    _this4.declareImpl = declareImpl,
                    _this4.deployImpl = deployImpl,
                    _this4
                }
                return (0,
                _createClass2.default)(WrappedAccountV4, [{
                    key: "execute",
                    value: (_execute2 = (0,
                    _asyncToGenerator2.default)((function*(transactions) {
                        var _transactions$calldat, calldataMapper = function(e) {
                            var str = e.toString();
                            return "0x" === str.toLowerCase() ? "0x0" : str
                        };
                        return this.executeImpl(Array.isArray(transactions) ? transactions.map((function(c) {
                            var _c$calldata;
                            return Object.assign({}, c, {
                                calldata: null === (_c$calldata = c.calldata) || void 0 === _c$calldata ? void 0 : _c$calldata.map(calldataMapper)
                            })
                        }
                        )) : Object.assign({}, transactions, {
                            calldata: null === (_transactions$calldat = transactions.calldata) || void 0 === _transactions$calldat ? void 0 : _transactions$calldat.map(calldataMapper)
                        }))
                    }
                    )),
                    function(_x9) {
                        return _execute2.apply(this, arguments)
                    }
                    )
                }, {
                    key: "signMessage",
                    value: (_signMessage2 = (0,
                    _asyncToGenerator2.default)((function*(data) {
                        return yield this.signMessageImpl(data)
                    }
                    )),
                    function(_x10) {
                        return _signMessage2.apply(this, arguments)
                    }
                    )
                }, {
                    key: "declare",
                    value: (_declare2 = (0,
                    _asyncToGenerator2.default)((function*(payload) {
                        return this.declareImpl(Object.assign({}, payload, {
                            classHash: payload.classHash.toString(),
                            contract: "string" == typeof payload.contract ? payload.contract : Object.assign({}, payload.contract, {
                                entry_points_by_type: payload.contract.entry_points_by_type,
                                program: payload.contract.program
                            })
                        }))
                    }
                    )),
                    function(_x11) {
                        return _declare2.apply(this, arguments)
                    }
                    )
                }, {
                    key: "deploy",
                    value: (_deploy2 = (0,
                    _asyncToGenerator2.default)((function*(payload) {
                        var v4ToV5Payload = function(v4Payload) {
                            var _v4Payload$constructo;
                            return Object.assign({}, v4Payload, {
                                classHash: v4Payload.classHash.toString(),
                                constructorCalldata: Object.fromEntries(Object.entries(null !== (_v4Payload$constructo = v4Payload.constructorCalldata) && void 0 !== _v4Payload$constructo ? _v4Payload$constructo : {}).map((function(_ref6) {
                                    var _ref7 = (0,
                                    _slicedToArray2.default)(_ref6, 2)
                                      , k = _ref7[0]
                                      , v = _ref7[1];
                                    return "object" != typeof v || Array.isArray(v) || (v = Object.fromEntries(Object.entries(v).map((function(_ref8) {
                                        var _ref9 = (0,
                                        _slicedToArray2.default)(_ref8, 2);
                                        return [_ref9[0], _ref9[1].toString()]
                                    }
                                    )))),
                                    [k, v]
                                }
                                )))
                            })
                        };
                        return this.deployImpl(Array.isArray(payload) ? payload.map((function(p) {
                            return v4ToV5Payload(p)
                        }
                        )) : v4ToV5Payload(payload))
                    }
                    )),
                    function(_x12) {
                        return _deploy2.apply(this, arguments)
                    }
                    )
                }]),
                WrappedAccountV4
            }(_starknet_v2.Account)
        }
        ,
        64534: (__unused_webpack_module,exports,__webpack_require__)=>{
            var _interopRequireDefault = __webpack_require__(64836);
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.default = void 0;
            var _uid = _interopRequireDefault(__webpack_require__(50904))
              , pendingDappRequests = {}
              , _default = {
                add: function(message, callback) {
                    var uid = (0,
                    _uid.default)();
                    return pendingDappRequests[uid] = {
                        message,
                        callback
                    },
                    uid
                },
                resolve: function(uid, result) {
                    var _pendingDappRequests$;
                    null === (_pendingDappRequests$ = pendingDappRequests[uid]) || void 0 === _pendingDappRequests$ || _pendingDappRequests$.callback(result),
                    delete pendingDappRequests[uid]
                },
                get: function(uid) {
                    var _pendingDappRequests$2;
                    return null === (_pendingDappRequests$2 = pendingDappRequests[uid]) || void 0 === _pendingDappRequests$2 ? void 0 : _pendingDappRequests$2.message
                },
                has: function(uid) {
                    return !!pendingDappRequests[uid]
                }
            };
            exports.default = _default
        }
        ,
        50904: (__unused_webpack_module,exports)=>{
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.default = function(prefix) {
                return `${prefix ? `${prefix}-` : ""}${Date.now()}-${Math.floor(8999999999999 * Math.random()) + 1e12}`
            }
        }
        ,
        23631: (__unused_webpack_module,exports)=>{
            var WalletMethod, DappMethod, PopupMethod, ConnectionType;
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.WalletMethod = exports.PopupMethod = exports.DappMethod = exports.ConnectionType = void 0,
            exports.WalletMethod = WalletMethod,
            function(WalletMethod) {
                WalletMethod.IS_NEW = "IS_NEW",
                WalletMethod.IS_RECOVERING = "IS_RECOVERING",
                WalletMethod.GET_RECOVERY_STATE = "GET_RECOVERY_STATE",
                WalletMethod.LOCK = "LOCK",
                WalletMethod.UNLOCK = "UNLOCK",
                WalletMethod.IS_LOCKED = "IS_LOCKED",
                WalletMethod.VALIDATE_PASSWORD = "VALIDATE_PASSWORD",
                WalletMethod.GET_ALL_NETWORKS = "GET_ALL_NETWORKS",
                WalletMethod.GET_ALL_NETWORKS_ACCOUNTS = "GET_ALL_NETWORKS_ACCOUNTS",
                WalletMethod.GET_ACTIVE_NETWORK = "GET_ACTIVE_NETWORK",
                WalletMethod.SET_ACTIVE_NETWORK = "SET_ACTIVE_NETWORK",
                WalletMethod.GET_ALL_ACCOUNTS = "GET_ALL_ACCOUNTS",
                WalletMethod.GET_ACTIVE_ACCOUNT = "GET_ACTIVE_ACCOUNT",
                WalletMethod.SET_ACTIVE_ACCOUNT = "SET_ACTIVE_ACCOUNT",
                WalletMethod.SET_ACCOUNT_NAME = "SET_ACCOUNT_NAME",
                WalletMethod.AUX_ACCOUNT_AUTH = "AUXILIARY_ACCOUNT_AUTH",
                WalletMethod.INVOKE = "INVOKE",
                WalletMethod.SIGN_MESSAGE = "SIGN_MESSAGE",
                WalletMethod.DECLARE_CONTRACT = "DECLARE_CONTRACT",
                WalletMethod.DEPLOY_CONTRACT = "DEPLOY_CONTRACT",
                WalletMethod.NEW_ACCOUNT = "NEW_ACCOUNT",
                WalletMethod.IMPORT_LEDGER_ACCOUNT = "IMPORT_LEDGER_ACCOUNT",
                WalletMethod.IMPORT_MULTI_OWNER_ACCOUNT = "IMPORT_MULTI_OWNER_ACCOUNT",
                WalletMethod.EJECT_EXTERNAL_ACCOUNT = "EJECT_EXTERNAL_ACCOUNT",
                WalletMethod.DEPLOY_ACTIVE_ACCOUNT = "DEPLOY_ACTIVE_ACCOUNT",
                WalletMethod.DEPLOY_LEDGER_ACCOUNT = "DEPLOY_LEDGER_ACCOUNT",
                WalletMethod.GET_VERSION = "GET_VERSION",
                WalletMethod.GET_SIGNERS = "GET_SIGNERS",
                WalletMethod.IS_POPUP_CONNECTED = "IS_POPUP_CONNECTED",
                WalletMethod.GET_SEED = "GET_SEED",
                WalletMethod.SEED_RECOVERY = "SEED_RECOVERY",
                WalletMethod.INVOKE_ESTIMATE_FEE = "INVOKE_ESTIMATE_FEE",
                WalletMethod.DECLARE_CONTRACT_ESTIMATE_FEE = "DECLARE_CONTRACT_ESTIMATE_FEE",
                WalletMethod.DEPLOY_CONTRACT_ESTIMATE_FEE = "DEPLOY_CONTRACT_ESTIMATE_FEE",
                WalletMethod.DEPLOY_ACTIVE_ACCOUNT_ESTIMATE_FEE = "DEPLOY_ACTIVE_ACCOUNT_ESTIMATE_FEE",
                WalletMethod.DEPLOY_MOCK_ACCOUNT_ESTIMATE_FEE = "DEPLOY_MOCK_ACCOUNT_ESTIMATE_FEE",
                WalletMethod.GET_ACTIVE_ACCOUNT_DEPLOYMENT_DATA = "GET_ACTIVE_ACCOUNT_DEPLOYMENT_DATA",
                WalletMethod.UPGRADE_ESTIMATE_FEE = "UPGRADE_ESTIMATE_FEE",
                WalletMethod.IS_UPGRADABLE = "IS_UPGRADABLE",
                WalletMethod.UPGRADE = "UPGRADE",
                WalletMethod.RESET = "RESET",
                WalletMethod.GET_ACTIVE_ACCOUNT_KEY = "GET_ACTIVE_ACCOUNT_KEY",
                WalletMethod.DISCOVER_NEW_ACCOUNTS = "DISCOVER_NEW_ACCOUNTS",
                WalletMethod.IS_DEPLOYED = "IS_DEPLOYED",
                WalletMethod.GET_PENDING_MULTISIG_TRANSACTION = "GET_PENDING_MULTISIG_TRANSACTION",
                WalletMethod.HANDLE_ACCOUNT_PENDING_MULTISIG_TRANSACTION = "HANDLE_ACCOUNT_PENDING_MULTISIG_TRANSACTION",
                WalletMethod.ADD_SIGNERS_ESTIMATE_FEE = "ADD_SIGNERS_ESTIMATE_FEE",
                WalletMethod.REMOVE_SIGNERS_ESTIMATE_FEE = "REMOVE_SIGNERS_ESTIMATE_FEE",
                WalletMethod.SWAP_SIGNERS_ESTIMATE_FEE = "SWAP_SIGNERS_ESTIMATE_FEE",
                WalletMethod.CANCEL_SIGNER_DEFERRED_REMOVAL_ESTIMATE_FEE = "CANCEL_SIGNER_DEFERRED_REMOVAL_ESTIMATE_FEE",
                WalletMethod.CANCEL_MULTISIG_DEFERRED_REMOVAL_ESTIMATE_FEE = "CANCEL_MULTISIG_DEFERRED_REMOVAL_ESTIMATE_FEE",
                WalletMethod.DISABLE_MULTISIG_ESTIMATE_FEE = "DISABLE_MULTISIG_ESTIMATE_FEE",
                WalletMethod.ENABLE_MULTISIG_ESTIMATE_FEE = "ENABLE_MULTISIG_ESTIMATE_FEE",
                WalletMethod.SET_WITHDRAWAL_LIMITS_ESTIMATE_FEE = "SET_WITHDRAWAL_LIMITS_ESTIMATE_FEE",
                WalletMethod.ADD_SIGNERS = "ADD_SIGNERS",
                WalletMethod.REMOVE_SIGNERS = "REMOVE_SIGNERS",
                WalletMethod.SWAP_SIGNERS = "SWAP_SIGNERS",
                WalletMethod.CANCEL_SIGNER_DEFERRED_REMOVAL = "CANCEL_SIGNER_DEFERRED_REMOVAL",
                WalletMethod.CANCEL_MULTISIG_DEFERRED_REMOVAL = "CANCEL_MULTISIG_DEFERRED_REMOVAL",
                WalletMethod.DISABLE_MULTISIG = "DISABLE_MULTISIG",
                WalletMethod.ENABLE_MULTISIG = "ENABLE_MULTISIG",
                WalletMethod.SET_WITHDRAWAL_LIMITS = "SET_WITHDRAWAL_LIMITS",
                WalletMethod.SET_DAILY_WITHDRAWAL_LIMITS = "SET_DAILY_WITHDRAWAL_LIMITS",
                WalletMethod.SET_DAILY_WITHDRAWAL_LIMITS_ESTIMATE_FEE = "SET_DAILY_WITHDRAWAL_LIMITS_ESTIMATE_FEE",
                WalletMethod.GET_WITHDRAWAL_LIMITS = "GET_WITHDRAWAL_LIMITS",
                WalletMethod.GET_REQUIRED_SIGNER = "GET_REQUIRED_SIGNER"
            }(WalletMethod || (exports.WalletMethod = WalletMethod = {})),
            exports.DappMethod = DappMethod,
            function(DappMethod) {
                DappMethod.IS_AUTHORIZED = "IS_AUTHORIZED",
                DappMethod.CONNECT = "CONNECT",
                DappMethod.INVOKE = "INVOKE",
                DappMethod.WATCH_ASSET = "WATCH_ASSET",
                DappMethod.SIGN_MESSAGE = "SIGN_MESSAGE",
                DappMethod.DECLARE_CONTRACT = "DECLARE_CONTRACT",
                DappMethod.DEPLOY_CONTRACT = "DEPLOY_CONTRACT",
                DappMethod.GET_DEPLOYMENT_DATA = "GET_DEPLOYMENT_DATA",
                DappMethod.GET_NODE = "GET_NODE",
                DappMethod.GET_CHAIN_ID = "GET_CHAIN_ID",
                DappMethod.GET_SUPPORTED_SPECS = "GET_SUPPORTED_SPECS"
            }(DappMethod || (exports.DappMethod = DappMethod = {})),
            exports.PopupMethod = PopupMethod,
            function(PopupMethod) {
                PopupMethod.WEBAUTHN_SIGNING = "WEBAUTHN_SIGNING",
                PopupMethod.REMOTE_SIGNING = "REMOTE_SIGNING",
                PopupMethod.PENDING_MULTISIG_SIGNING = "PENDING_MULTISIG_SIGNING",
                PopupMethod.CONNECT_LEDGER = "CONNECT_LEDGER",
                PopupMethod.SELECT_LEDGER_DEVICE = "SELECT_LEDGER_DEVICE",
                PopupMethod.SIGN_WITH_LEDGER = "SIGN_WITH_LEDGER",
                PopupMethod.DEPLOY_LEDGER_ACCOUNT = "DEPLOY_LEDGER_ACCOUNT"
            }(PopupMethod || (exports.PopupMethod = PopupMethod = {})),
            exports.ConnectionType = ConnectionType,
            function(ConnectionType) {
                ConnectionType.MessagesWallet = "messages-wallet",
                ConnectionType.ContentListenerBridge = "content-listener-bridge",
                ConnectionType.BackgroundIsReady = "background-is-ready"
            }(ConnectionType || (exports.ConnectionType = ConnectionType = {}))
        }
        ,
        79742: (__unused_webpack_module,exports)=>{
            "use strict";
            exports.byteLength = function(b64) {
                var lens = getLens(b64)
                  , validLen = lens[0]
                  , placeHoldersLen = lens[1];
                return 3 * (validLen + placeHoldersLen) / 4 - placeHoldersLen
            }
            ,
            exports.toByteArray = function(b64) {
                var tmp, i, lens = getLens(b64), validLen = lens[0], placeHoldersLen = lens[1], arr = new Arr(function(b64, validLen, placeHoldersLen) {
                    return 3 * (validLen + placeHoldersLen) / 4 - placeHoldersLen
                }(0, validLen, placeHoldersLen)), curByte = 0, len = placeHoldersLen > 0 ? validLen - 4 : validLen;
                for (i = 0; i < len; i += 4)
                    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)],
                    arr[curByte++] = tmp >> 16 & 255,
                    arr[curByte++] = tmp >> 8 & 255,
                    arr[curByte++] = 255 & tmp;
                2 === placeHoldersLen && (tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4,
                arr[curByte++] = 255 & tmp);
                1 === placeHoldersLen && (tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2,
                arr[curByte++] = tmp >> 8 & 255,
                arr[curByte++] = 255 & tmp);
                return arr
            }
            ,
            exports.fromByteArray = function(uint8) {
                for (var tmp, len = uint8.length, extraBytes = len % 3, parts = [], i = 0, len2 = len - extraBytes; i < len2; i += 16383)
                    parts.push(encodeChunk(uint8, i, i + 16383 > len2 ? len2 : i + 16383));
                1 === extraBytes ? (tmp = uint8[len - 1],
                parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==")) : 2 === extraBytes && (tmp = (uint8[len - 2] << 8) + uint8[len - 1],
                parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="));
                return parts.join("")
            }
            ;
            for (var lookup = [], revLookup = [], Arr = "undefined" != typeof Uint8Array ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i = 0, len = code.length; i < len; ++i)
                lookup[i] = code[i],
                revLookup[code.charCodeAt(i)] = i;
            function getLens(b64) {
                var len = b64.length;
                if (len % 4 > 0)
                    throw new Error("Invalid string. Length must be a multiple of 4");
                var validLen = b64.indexOf("=");
                return -1 === validLen && (validLen = len),
                [validLen, validLen === len ? 0 : 4 - validLen % 4]
            }
            function encodeChunk(uint8, start, end) {
                for (var tmp, num, output = [], i = start; i < end; i += 3)
                    tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (255 & uint8[i + 2]),
                    output.push(lookup[(num = tmp) >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[63 & num]);
                return output.join("")
            }
            revLookup["-".charCodeAt(0)] = 62,
            revLookup["_".charCodeAt(0)] = 63
        }
        ,
        13550: function(module, __unused_webpack_exports, __webpack_require__) {
            !function(module, exports) {
                "use strict";
                function assert(val, msg) {
                    if (!val)
                        throw new Error(msg || "Assertion failed")
                }
                function inherits(ctor, superCtor) {
                    ctor.super_ = superCtor;
                    var TempCtor = function() {};
                    TempCtor.prototype = superCtor.prototype,
                    ctor.prototype = new TempCtor,
                    ctor.prototype.constructor = ctor
                }
                function BN(number, base, endian) {
                    if (BN.isBN(number))
                        return number;
                    this.negative = 0,
                    this.words = null,
                    this.length = 0,
                    this.red = null,
                    null !== number && ("le" !== base && "be" !== base || (endian = base,
                    base = 10),
                    this._init(number || 0, base || 10, endian || "be"))
                }
                var Buffer;
                "object" == typeof module ? module.exports = BN : exports.BN = BN,
                BN.BN = BN,
                BN.wordSize = 26;
                try {
                    Buffer = "undefined" != typeof window && void 0 !== window.Buffer ? window.Buffer : __webpack_require__(46601).Buffer
                } catch (e) {}
                function parseHex4Bits(string, index) {
                    var c = string.charCodeAt(index);
                    return c >= 65 && c <= 70 ? c - 55 : c >= 97 && c <= 102 ? c - 87 : c - 48 & 15
                }
                function parseHexByte(string, lowerBound, index) {
                    var r = parseHex4Bits(string, index);
                    return index - 1 >= lowerBound && (r |= parseHex4Bits(string, index - 1) << 4),
                    r
                }
                function parseBase(str, start, end, mul) {
                    for (var r = 0, len = Math.min(str.length, end), i = start; i < len; i++) {
                        var c = str.charCodeAt(i) - 48;
                        r *= mul,
                        r += c >= 49 ? c - 49 + 10 : c >= 17 ? c - 17 + 10 : c
                    }
                    return r
                }
                BN.isBN = function(num) {
                    return num instanceof BN || null !== num && "object" == typeof num && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words)
                }
                ,
                BN.max = function(left, right) {
                    return left.cmp(right) > 0 ? left : right
                }
                ,
                BN.min = function(left, right) {
                    return left.cmp(right) < 0 ? left : right
                }
                ,
                BN.prototype._init = function(number, base, endian) {
                    if ("number" == typeof number)
                        return this._initNumber(number, base, endian);
                    if ("object" == typeof number)
                        return this._initArray(number, base, endian);
                    "hex" === base && (base = 16),
                    assert(base === (0 | base) && base >= 2 && base <= 36);
                    var start = 0;
                    "-" === (number = number.toString().replace(/\s+/g, ""))[0] && (start++,
                    this.negative = 1),
                    start < number.length && (16 === base ? this._parseHex(number, start, endian) : (this._parseBase(number, base, start),
                    "le" === endian && this._initArray(this.toArray(), base, endian)))
                }
                ,
                BN.prototype._initNumber = function(number, base, endian) {
                    number < 0 && (this.negative = 1,
                    number = -number),
                    number < 67108864 ? (this.words = [67108863 & number],
                    this.length = 1) : number < 4503599627370496 ? (this.words = [67108863 & number, number / 67108864 & 67108863],
                    this.length = 2) : (assert(number < 9007199254740992),
                    this.words = [67108863 & number, number / 67108864 & 67108863, 1],
                    this.length = 3),
                    "le" === endian && this._initArray(this.toArray(), base, endian)
                }
                ,
                BN.prototype._initArray = function(number, base, endian) {
                    if (assert("number" == typeof number.length),
                    number.length <= 0)
                        return this.words = [0],
                        this.length = 1,
                        this;
                    this.length = Math.ceil(number.length / 3),
                    this.words = new Array(this.length);
                    for (var i = 0; i < this.length; i++)
                        this.words[i] = 0;
                    var j, w, off = 0;
                    if ("be" === endian)
                        for (i = number.length - 1,
                        j = 0; i >= 0; i -= 3)
                            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16,
                            this.words[j] |= w << off & 67108863,
                            this.words[j + 1] = w >>> 26 - off & 67108863,
                            (off += 24) >= 26 && (off -= 26,
                            j++);
                    else if ("le" === endian)
                        for (i = 0,
                        j = 0; i < number.length; i += 3)
                            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16,
                            this.words[j] |= w << off & 67108863,
                            this.words[j + 1] = w >>> 26 - off & 67108863,
                            (off += 24) >= 26 && (off -= 26,
                            j++);
                    return this.strip()
                }
                ,
                BN.prototype._parseHex = function(number, start, endian) {
                    this.length = Math.ceil((number.length - start) / 6),
                    this.words = new Array(this.length);
                    for (var i = 0; i < this.length; i++)
                        this.words[i] = 0;
                    var w, off = 0, j = 0;
                    if ("be" === endian)
                        for (i = number.length - 1; i >= start; i -= 2)
                            w = parseHexByte(number, start, i) << off,
                            this.words[j] |= 67108863 & w,
                            off >= 18 ? (off -= 18,
                            j += 1,
                            this.words[j] |= w >>> 26) : off += 8;
                    else
                        for (i = (number.length - start) % 2 == 0 ? start + 1 : start; i < number.length; i += 2)
                            w = parseHexByte(number, start, i) << off,
                            this.words[j] |= 67108863 & w,
                            off >= 18 ? (off -= 18,
                            j += 1,
                            this.words[j] |= w >>> 26) : off += 8;
                    this.strip()
                }
                ,
                BN.prototype._parseBase = function(number, base, start) {
                    this.words = [0],
                    this.length = 1;
                    for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base)
                        limbLen++;
                    limbLen--,
                    limbPow = limbPow / base | 0;
                    for (var total = number.length - start, mod = total % limbLen, end = Math.min(total, total - mod) + start, word = 0, i = start; i < end; i += limbLen)
                        word = parseBase(number, i, i + limbLen, base),
                        this.imuln(limbPow),
                        this.words[0] + word < 67108864 ? this.words[0] += word : this._iaddn(word);
                    if (0 !== mod) {
                        var pow = 1;
                        for (word = parseBase(number, i, number.length, base),
                        i = 0; i < mod; i++)
                            pow *= base;
                        this.imuln(pow),
                        this.words[0] + word < 67108864 ? this.words[0] += word : this._iaddn(word)
                    }
                    this.strip()
                }
                ,
                BN.prototype.copy = function(dest) {
                    dest.words = new Array(this.length);
                    for (var i = 0; i < this.length; i++)
                        dest.words[i] = this.words[i];
                    dest.length = this.length,
                    dest.negative = this.negative,
                    dest.red = this.red
                }
                ,
                BN.prototype.clone = function() {
                    var r = new BN(null);
                    return this.copy(r),
                    r
                }
                ,
                BN.prototype._expand = function(size) {
                    for (; this.length < size; )
                        this.words[this.length++] = 0;
                    return this
                }
                ,
                BN.prototype.strip = function() {
                    for (; this.length > 1 && 0 === this.words[this.length - 1]; )
                        this.length--;
                    return this._normSign()
                }
                ,
                BN.prototype._normSign = function() {
                    return 1 === this.length && 0 === this.words[0] && (this.negative = 0),
                    this
                }
                ,
                BN.prototype.inspect = function() {
                    return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
                }
                ;
                var zeros = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"]
                  , groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
                  , groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
                function smallMulTo(self, num, out) {
                    out.negative = num.negative ^ self.negative;
                    var len = self.length + num.length | 0;
                    out.length = len,
                    len = len - 1 | 0;
                    var a = 0 | self.words[0]
                      , b = 0 | num.words[0]
                      , r = a * b
                      , lo = 67108863 & r
                      , carry = r / 67108864 | 0;
                    out.words[0] = lo;
                    for (var k = 1; k < len; k++) {
                        for (var ncarry = carry >>> 26, rword = 67108863 & carry, maxJ = Math.min(k, num.length - 1), j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
                            var i = k - j | 0;
                            ncarry += (r = (a = 0 | self.words[i]) * (b = 0 | num.words[j]) + rword) / 67108864 | 0,
                            rword = 67108863 & r
                        }
                        out.words[k] = 0 | rword,
                        carry = 0 | ncarry
                    }
                    return 0 !== carry ? out.words[k] = 0 | carry : out.length--,
                    out.strip()
                }
                BN.prototype.toString = function(base, padding) {
                    var out;
                    if (padding = 0 | padding || 1,
                    16 === (base = base || 10) || "hex" === base) {
                        out = "";
                        for (var off = 0, carry = 0, i = 0; i < this.length; i++) {
                            var w = this.words[i]
                              , word = (16777215 & (w << off | carry)).toString(16);
                            out = 0 !== (carry = w >>> 24 - off & 16777215) || i !== this.length - 1 ? zeros[6 - word.length] + word + out : word + out,
                            (off += 2) >= 26 && (off -= 26,
                            i--)
                        }
                        for (0 !== carry && (out = carry.toString(16) + out); out.length % padding != 0; )
                            out = "0" + out;
                        return 0 !== this.negative && (out = "-" + out),
                        out
                    }
                    if (base === (0 | base) && base >= 2 && base <= 36) {
                        var groupSize = groupSizes[base]
                          , groupBase = groupBases[base];
                        out = "";
                        var c = this.clone();
                        for (c.negative = 0; !c.isZero(); ) {
                            var r = c.modn(groupBase).toString(base);
                            out = (c = c.idivn(groupBase)).isZero() ? r + out : zeros[groupSize - r.length] + r + out
                        }
                        for (this.isZero() && (out = "0" + out); out.length % padding != 0; )
                            out = "0" + out;
                        return 0 !== this.negative && (out = "-" + out),
                        out
                    }
                    assert(!1, "Base should be between 2 and 36")
                }
                ,
                BN.prototype.toNumber = function() {
                    var ret = this.words[0];
                    return 2 === this.length ? ret += 67108864 * this.words[1] : 3 === this.length && 1 === this.words[2] ? ret += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && assert(!1, "Number can only safely store up to 53 bits"),
                    0 !== this.negative ? -ret : ret
                }
                ,
                BN.prototype.toJSON = function() {
                    return this.toString(16)
                }
                ,
                BN.prototype.toBuffer = function(endian, length) {
                    return assert(void 0 !== Buffer),
                    this.toArrayLike(Buffer, endian, length)
                }
                ,
                BN.prototype.toArray = function(endian, length) {
                    return this.toArrayLike(Array, endian, length)
                }
                ,
                BN.prototype.toArrayLike = function(ArrayType, endian, length) {
                    var byteLength = this.byteLength()
                      , reqLength = length || Math.max(1, byteLength);
                    assert(byteLength <= reqLength, "byte array longer than desired length"),
                    assert(reqLength > 0, "Requested array length <= 0"),
                    this.strip();
                    var b, i, littleEndian = "le" === endian, res = new ArrayType(reqLength), q = this.clone();
                    if (littleEndian) {
                        for (i = 0; !q.isZero(); i++)
                            b = q.andln(255),
                            q.iushrn(8),
                            res[i] = b;
                        for (; i < reqLength; i++)
                            res[i] = 0
                    } else {
                        for (i = 0; i < reqLength - byteLength; i++)
                            res[i] = 0;
                        for (i = 0; !q.isZero(); i++)
                            b = q.andln(255),
                            q.iushrn(8),
                            res[reqLength - i - 1] = b
                    }
                    return res
                }
                ,
                Math.clz32 ? BN.prototype._countBits = function(w) {
                    return 32 - Math.clz32(w)
                }
                : BN.prototype._countBits = function(w) {
                    var t = w
                      , r = 0;
                    return t >= 4096 && (r += 13,
                    t >>>= 13),
                    t >= 64 && (r += 7,
                    t >>>= 7),
                    t >= 8 && (r += 4,
                    t >>>= 4),
                    t >= 2 && (r += 2,
                    t >>>= 2),
                    r + t
                }
                ,
                BN.prototype._zeroBits = function(w) {
                    if (0 === w)
                        return 26;
                    var t = w
                      , r = 0;
                    return 0 == (8191 & t) && (r += 13,
                    t >>>= 13),
                    0 == (127 & t) && (r += 7,
                    t >>>= 7),
                    0 == (15 & t) && (r += 4,
                    t >>>= 4),
                    0 == (3 & t) && (r += 2,
                    t >>>= 2),
                    0 == (1 & t) && r++,
                    r
                }
                ,
                BN.prototype.bitLength = function() {
                    var w = this.words[this.length - 1]
                      , hi = this._countBits(w);
                    return 26 * (this.length - 1) + hi
                }
                ,
                BN.prototype.zeroBits = function() {
                    if (this.isZero())
                        return 0;
                    for (var r = 0, i = 0; i < this.length; i++) {
                        var b = this._zeroBits(this.words[i]);
                        if (r += b,
                        26 !== b)
                            break
                    }
                    return r
                }
                ,
                BN.prototype.byteLength = function() {
                    return Math.ceil(this.bitLength() / 8)
                }
                ,
                BN.prototype.toTwos = function(width) {
                    return 0 !== this.negative ? this.abs().inotn(width).iaddn(1) : this.clone()
                }
                ,
                BN.prototype.fromTwos = function(width) {
                    return this.testn(width - 1) ? this.notn(width).iaddn(1).ineg() : this.clone()
                }
                ,
                BN.prototype.isNeg = function() {
                    return 0 !== this.negative
                }
                ,
                BN.prototype.neg = function() {
                    return this.clone().ineg()
                }
                ,
                BN.prototype.ineg = function() {
                    return this.isZero() || (this.negative ^= 1),
                    this
                }
                ,
                BN.prototype.iuor = function(num) {
                    for (; this.length < num.length; )
                        this.words[this.length++] = 0;
                    for (var i = 0; i < num.length; i++)
                        this.words[i] = this.words[i] | num.words[i];
                    return this.strip()
                }
                ,
                BN.prototype.ior = function(num) {
                    return assert(0 == (this.negative | num.negative)),
                    this.iuor(num)
                }
                ,
                BN.prototype.or = function(num) {
                    return this.length > num.length ? this.clone().ior(num) : num.clone().ior(this)
                }
                ,
                BN.prototype.uor = function(num) {
                    return this.length > num.length ? this.clone().iuor(num) : num.clone().iuor(this)
                }
                ,
                BN.prototype.iuand = function(num) {
                    var b;
                    b = this.length > num.length ? num : this;
                    for (var i = 0; i < b.length; i++)
                        this.words[i] = this.words[i] & num.words[i];
                    return this.length = b.length,
                    this.strip()
                }
                ,
                BN.prototype.iand = function(num) {
                    return assert(0 == (this.negative | num.negative)),
                    this.iuand(num)
                }
                ,
                BN.prototype.and = function(num) {
                    return this.length > num.length ? this.clone().iand(num) : num.clone().iand(this)
                }
                ,
                BN.prototype.uand = function(num) {
                    return this.length > num.length ? this.clone().iuand(num) : num.clone().iuand(this)
                }
                ,
                BN.prototype.iuxor = function(num) {
                    var a, b;
                    this.length > num.length ? (a = this,
                    b = num) : (a = num,
                    b = this);
                    for (var i = 0; i < b.length; i++)
                        this.words[i] = a.words[i] ^ b.words[i];
                    if (this !== a)
                        for (; i < a.length; i++)
                            this.words[i] = a.words[i];
                    return this.length = a.length,
                    this.strip()
                }
                ,
                BN.prototype.ixor = function(num) {
                    return assert(0 == (this.negative | num.negative)),
                    this.iuxor(num)
                }
                ,
                BN.prototype.xor = function(num) {
                    return this.length > num.length ? this.clone().ixor(num) : num.clone().ixor(this)
                }
                ,
                BN.prototype.uxor = function(num) {
                    return this.length > num.length ? this.clone().iuxor(num) : num.clone().iuxor(this)
                }
                ,
                BN.prototype.inotn = function(width) {
                    assert("number" == typeof width && width >= 0);
                    var bytesNeeded = 0 | Math.ceil(width / 26)
                      , bitsLeft = width % 26;
                    this._expand(bytesNeeded),
                    bitsLeft > 0 && bytesNeeded--;
                    for (var i = 0; i < bytesNeeded; i++)
                        this.words[i] = 67108863 & ~this.words[i];
                    return bitsLeft > 0 && (this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft),
                    this.strip()
                }
                ,
                BN.prototype.notn = function(width) {
                    return this.clone().inotn(width)
                }
                ,
                BN.prototype.setn = function(bit, val) {
                    assert("number" == typeof bit && bit >= 0);
                    var off = bit / 26 | 0
                      , wbit = bit % 26;
                    return this._expand(off + 1),
                    this.words[off] = val ? this.words[off] | 1 << wbit : this.words[off] & ~(1 << wbit),
                    this.strip()
                }
                ,
                BN.prototype.iadd = function(num) {
                    var r, a, b;
                    if (0 !== this.negative && 0 === num.negative)
                        return this.negative = 0,
                        r = this.isub(num),
                        this.negative ^= 1,
                        this._normSign();
                    if (0 === this.negative && 0 !== num.negative)
                        return num.negative = 0,
                        r = this.isub(num),
                        num.negative = 1,
                        r._normSign();
                    this.length > num.length ? (a = this,
                    b = num) : (a = num,
                    b = this);
                    for (var carry = 0, i = 0; i < b.length; i++)
                        r = (0 | a.words[i]) + (0 | b.words[i]) + carry,
                        this.words[i] = 67108863 & r,
                        carry = r >>> 26;
                    for (; 0 !== carry && i < a.length; i++)
                        r = (0 | a.words[i]) + carry,
                        this.words[i] = 67108863 & r,
                        carry = r >>> 26;
                    if (this.length = a.length,
                    0 !== carry)
                        this.words[this.length] = carry,
                        this.length++;
                    else if (a !== this)
                        for (; i < a.length; i++)
                            this.words[i] = a.words[i];
                    return this
                }
                ,
                BN.prototype.add = function(num) {
                    var res;
                    return 0 !== num.negative && 0 === this.negative ? (num.negative = 0,
                    res = this.sub(num),
                    num.negative ^= 1,
                    res) : 0 === num.negative && 0 !== this.negative ? (this.negative = 0,
                    res = num.sub(this),
                    this.negative = 1,
                    res) : this.length > num.length ? this.clone().iadd(num) : num.clone().iadd(this)
                }
                ,
                BN.prototype.isub = function(num) {
                    if (0 !== num.negative) {
                        num.negative = 0;
                        var r = this.iadd(num);
                        return num.negative = 1,
                        r._normSign()
                    }
                    if (0 !== this.negative)
                        return this.negative = 0,
                        this.iadd(num),
                        this.negative = 1,
                        this._normSign();
                    var a, b, cmp = this.cmp(num);
                    if (0 === cmp)
                        return this.negative = 0,
                        this.length = 1,
                        this.words[0] = 0,
                        this;
                    cmp > 0 ? (a = this,
                    b = num) : (a = num,
                    b = this);
                    for (var carry = 0, i = 0; i < b.length; i++)
                        carry = (r = (0 | a.words[i]) - (0 | b.words[i]) + carry) >> 26,
                        this.words[i] = 67108863 & r;
                    for (; 0 !== carry && i < a.length; i++)
                        carry = (r = (0 | a.words[i]) + carry) >> 26,
                        this.words[i] = 67108863 & r;
                    if (0 === carry && i < a.length && a !== this)
                        for (; i < a.length; i++)
                            this.words[i] = a.words[i];
                    return this.length = Math.max(this.length, i),
                    a !== this && (this.negative = 1),
                    this.strip()
                }
                ,
                BN.prototype.sub = function(num) {
                    return this.clone().isub(num)
                }
                ;
                var comb10MulTo = function(self, num, out) {
                    var lo, mid, hi, a = self.words, b = num.words, o = out.words, c = 0, a0 = 0 | a[0], al0 = 8191 & a0, ah0 = a0 >>> 13, a1 = 0 | a[1], al1 = 8191 & a1, ah1 = a1 >>> 13, a2 = 0 | a[2], al2 = 8191 & a2, ah2 = a2 >>> 13, a3 = 0 | a[3], al3 = 8191 & a3, ah3 = a3 >>> 13, a4 = 0 | a[4], al4 = 8191 & a4, ah4 = a4 >>> 13, a5 = 0 | a[5], al5 = 8191 & a5, ah5 = a5 >>> 13, a6 = 0 | a[6], al6 = 8191 & a6, ah6 = a6 >>> 13, a7 = 0 | a[7], al7 = 8191 & a7, ah7 = a7 >>> 13, a8 = 0 | a[8], al8 = 8191 & a8, ah8 = a8 >>> 13, a9 = 0 | a[9], al9 = 8191 & a9, ah9 = a9 >>> 13, b0 = 0 | b[0], bl0 = 8191 & b0, bh0 = b0 >>> 13, b1 = 0 | b[1], bl1 = 8191 & b1, bh1 = b1 >>> 13, b2 = 0 | b[2], bl2 = 8191 & b2, bh2 = b2 >>> 13, b3 = 0 | b[3], bl3 = 8191 & b3, bh3 = b3 >>> 13, b4 = 0 | b[4], bl4 = 8191 & b4, bh4 = b4 >>> 13, b5 = 0 | b[5], bl5 = 8191 & b5, bh5 = b5 >>> 13, b6 = 0 | b[6], bl6 = 8191 & b6, bh6 = b6 >>> 13, b7 = 0 | b[7], bl7 = 8191 & b7, bh7 = b7 >>> 13, b8 = 0 | b[8], bl8 = 8191 & b8, bh8 = b8 >>> 13, b9 = 0 | b[9], bl9 = 8191 & b9, bh9 = b9 >>> 13;
                    out.negative = self.negative ^ num.negative,
                    out.length = 19;
                    var w0 = (c + (lo = Math.imul(al0, bl0)) | 0) + ((8191 & (mid = (mid = Math.imul(al0, bh0)) + Math.imul(ah0, bl0) | 0)) << 13) | 0;
                    c = ((hi = Math.imul(ah0, bh0)) + (mid >>> 13) | 0) + (w0 >>> 26) | 0,
                    w0 &= 67108863,
                    lo = Math.imul(al1, bl0),
                    mid = (mid = Math.imul(al1, bh0)) + Math.imul(ah1, bl0) | 0,
                    hi = Math.imul(ah1, bh0);
                    var w1 = (c + (lo = lo + Math.imul(al0, bl1) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al0, bh1) | 0) + Math.imul(ah0, bl1) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah0, bh1) | 0) + (mid >>> 13) | 0) + (w1 >>> 26) | 0,
                    w1 &= 67108863,
                    lo = Math.imul(al2, bl0),
                    mid = (mid = Math.imul(al2, bh0)) + Math.imul(ah2, bl0) | 0,
                    hi = Math.imul(ah2, bh0),
                    lo = lo + Math.imul(al1, bl1) | 0,
                    mid = (mid = mid + Math.imul(al1, bh1) | 0) + Math.imul(ah1, bl1) | 0,
                    hi = hi + Math.imul(ah1, bh1) | 0;
                    var w2 = (c + (lo = lo + Math.imul(al0, bl2) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al0, bh2) | 0) + Math.imul(ah0, bl2) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah0, bh2) | 0) + (mid >>> 13) | 0) + (w2 >>> 26) | 0,
                    w2 &= 67108863,
                    lo = Math.imul(al3, bl0),
                    mid = (mid = Math.imul(al3, bh0)) + Math.imul(ah3, bl0) | 0,
                    hi = Math.imul(ah3, bh0),
                    lo = lo + Math.imul(al2, bl1) | 0,
                    mid = (mid = mid + Math.imul(al2, bh1) | 0) + Math.imul(ah2, bl1) | 0,
                    hi = hi + Math.imul(ah2, bh1) | 0,
                    lo = lo + Math.imul(al1, bl2) | 0,
                    mid = (mid = mid + Math.imul(al1, bh2) | 0) + Math.imul(ah1, bl2) | 0,
                    hi = hi + Math.imul(ah1, bh2) | 0;
                    var w3 = (c + (lo = lo + Math.imul(al0, bl3) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al0, bh3) | 0) + Math.imul(ah0, bl3) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah0, bh3) | 0) + (mid >>> 13) | 0) + (w3 >>> 26) | 0,
                    w3 &= 67108863,
                    lo = Math.imul(al4, bl0),
                    mid = (mid = Math.imul(al4, bh0)) + Math.imul(ah4, bl0) | 0,
                    hi = Math.imul(ah4, bh0),
                    lo = lo + Math.imul(al3, bl1) | 0,
                    mid = (mid = mid + Math.imul(al3, bh1) | 0) + Math.imul(ah3, bl1) | 0,
                    hi = hi + Math.imul(ah3, bh1) | 0,
                    lo = lo + Math.imul(al2, bl2) | 0,
                    mid = (mid = mid + Math.imul(al2, bh2) | 0) + Math.imul(ah2, bl2) | 0,
                    hi = hi + Math.imul(ah2, bh2) | 0,
                    lo = lo + Math.imul(al1, bl3) | 0,
                    mid = (mid = mid + Math.imul(al1, bh3) | 0) + Math.imul(ah1, bl3) | 0,
                    hi = hi + Math.imul(ah1, bh3) | 0;
                    var w4 = (c + (lo = lo + Math.imul(al0, bl4) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al0, bh4) | 0) + Math.imul(ah0, bl4) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah0, bh4) | 0) + (mid >>> 13) | 0) + (w4 >>> 26) | 0,
                    w4 &= 67108863,
                    lo = Math.imul(al5, bl0),
                    mid = (mid = Math.imul(al5, bh0)) + Math.imul(ah5, bl0) | 0,
                    hi = Math.imul(ah5, bh0),
                    lo = lo + Math.imul(al4, bl1) | 0,
                    mid = (mid = mid + Math.imul(al4, bh1) | 0) + Math.imul(ah4, bl1) | 0,
                    hi = hi + Math.imul(ah4, bh1) | 0,
                    lo = lo + Math.imul(al3, bl2) | 0,
                    mid = (mid = mid + Math.imul(al3, bh2) | 0) + Math.imul(ah3, bl2) | 0,
                    hi = hi + Math.imul(ah3, bh2) | 0,
                    lo = lo + Math.imul(al2, bl3) | 0,
                    mid = (mid = mid + Math.imul(al2, bh3) | 0) + Math.imul(ah2, bl3) | 0,
                    hi = hi + Math.imul(ah2, bh3) | 0,
                    lo = lo + Math.imul(al1, bl4) | 0,
                    mid = (mid = mid + Math.imul(al1, bh4) | 0) + Math.imul(ah1, bl4) | 0,
                    hi = hi + Math.imul(ah1, bh4) | 0;
                    var w5 = (c + (lo = lo + Math.imul(al0, bl5) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al0, bh5) | 0) + Math.imul(ah0, bl5) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah0, bh5) | 0) + (mid >>> 13) | 0) + (w5 >>> 26) | 0,
                    w5 &= 67108863,
                    lo = Math.imul(al6, bl0),
                    mid = (mid = Math.imul(al6, bh0)) + Math.imul(ah6, bl0) | 0,
                    hi = Math.imul(ah6, bh0),
                    lo = lo + Math.imul(al5, bl1) | 0,
                    mid = (mid = mid + Math.imul(al5, bh1) | 0) + Math.imul(ah5, bl1) | 0,
                    hi = hi + Math.imul(ah5, bh1) | 0,
                    lo = lo + Math.imul(al4, bl2) | 0,
                    mid = (mid = mid + Math.imul(al4, bh2) | 0) + Math.imul(ah4, bl2) | 0,
                    hi = hi + Math.imul(ah4, bh2) | 0,
                    lo = lo + Math.imul(al3, bl3) | 0,
                    mid = (mid = mid + Math.imul(al3, bh3) | 0) + Math.imul(ah3, bl3) | 0,
                    hi = hi + Math.imul(ah3, bh3) | 0,
                    lo = lo + Math.imul(al2, bl4) | 0,
                    mid = (mid = mid + Math.imul(al2, bh4) | 0) + Math.imul(ah2, bl4) | 0,
                    hi = hi + Math.imul(ah2, bh4) | 0,
                    lo = lo + Math.imul(al1, bl5) | 0,
                    mid = (mid = mid + Math.imul(al1, bh5) | 0) + Math.imul(ah1, bl5) | 0,
                    hi = hi + Math.imul(ah1, bh5) | 0;
                    var w6 = (c + (lo = lo + Math.imul(al0, bl6) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al0, bh6) | 0) + Math.imul(ah0, bl6) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah0, bh6) | 0) + (mid >>> 13) | 0) + (w6 >>> 26) | 0,
                    w6 &= 67108863,
                    lo = Math.imul(al7, bl0),
                    mid = (mid = Math.imul(al7, bh0)) + Math.imul(ah7, bl0) | 0,
                    hi = Math.imul(ah7, bh0),
                    lo = lo + Math.imul(al6, bl1) | 0,
                    mid = (mid = mid + Math.imul(al6, bh1) | 0) + Math.imul(ah6, bl1) | 0,
                    hi = hi + Math.imul(ah6, bh1) | 0,
                    lo = lo + Math.imul(al5, bl2) | 0,
                    mid = (mid = mid + Math.imul(al5, bh2) | 0) + Math.imul(ah5, bl2) | 0,
                    hi = hi + Math.imul(ah5, bh2) | 0,
                    lo = lo + Math.imul(al4, bl3) | 0,
                    mid = (mid = mid + Math.imul(al4, bh3) | 0) + Math.imul(ah4, bl3) | 0,
                    hi = hi + Math.imul(ah4, bh3) | 0,
                    lo = lo + Math.imul(al3, bl4) | 0,
                    mid = (mid = mid + Math.imul(al3, bh4) | 0) + Math.imul(ah3, bl4) | 0,
                    hi = hi + Math.imul(ah3, bh4) | 0,
                    lo = lo + Math.imul(al2, bl5) | 0,
                    mid = (mid = mid + Math.imul(al2, bh5) | 0) + Math.imul(ah2, bl5) | 0,
                    hi = hi + Math.imul(ah2, bh5) | 0,
                    lo = lo + Math.imul(al1, bl6) | 0,
                    mid = (mid = mid + Math.imul(al1, bh6) | 0) + Math.imul(ah1, bl6) | 0,
                    hi = hi + Math.imul(ah1, bh6) | 0;
                    var w7 = (c + (lo = lo + Math.imul(al0, bl7) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al0, bh7) | 0) + Math.imul(ah0, bl7) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah0, bh7) | 0) + (mid >>> 13) | 0) + (w7 >>> 26) | 0,
                    w7 &= 67108863,
                    lo = Math.imul(al8, bl0),
                    mid = (mid = Math.imul(al8, bh0)) + Math.imul(ah8, bl0) | 0,
                    hi = Math.imul(ah8, bh0),
                    lo = lo + Math.imul(al7, bl1) | 0,
                    mid = (mid = mid + Math.imul(al7, bh1) | 0) + Math.imul(ah7, bl1) | 0,
                    hi = hi + Math.imul(ah7, bh1) | 0,
                    lo = lo + Math.imul(al6, bl2) | 0,
                    mid = (mid = mid + Math.imul(al6, bh2) | 0) + Math.imul(ah6, bl2) | 0,
                    hi = hi + Math.imul(ah6, bh2) | 0,
                    lo = lo + Math.imul(al5, bl3) | 0,
                    mid = (mid = mid + Math.imul(al5, bh3) | 0) + Math.imul(ah5, bl3) | 0,
                    hi = hi + Math.imul(ah5, bh3) | 0,
                    lo = lo + Math.imul(al4, bl4) | 0,
                    mid = (mid = mid + Math.imul(al4, bh4) | 0) + Math.imul(ah4, bl4) | 0,
                    hi = hi + Math.imul(ah4, bh4) | 0,
                    lo = lo + Math.imul(al3, bl5) | 0,
                    mid = (mid = mid + Math.imul(al3, bh5) | 0) + Math.imul(ah3, bl5) | 0,
                    hi = hi + Math.imul(ah3, bh5) | 0,
                    lo = lo + Math.imul(al2, bl6) | 0,
                    mid = (mid = mid + Math.imul(al2, bh6) | 0) + Math.imul(ah2, bl6) | 0,
                    hi = hi + Math.imul(ah2, bh6) | 0,
                    lo = lo + Math.imul(al1, bl7) | 0,
                    mid = (mid = mid + Math.imul(al1, bh7) | 0) + Math.imul(ah1, bl7) | 0,
                    hi = hi + Math.imul(ah1, bh7) | 0;
                    var w8 = (c + (lo = lo + Math.imul(al0, bl8) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al0, bh8) | 0) + Math.imul(ah0, bl8) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah0, bh8) | 0) + (mid >>> 13) | 0) + (w8 >>> 26) | 0,
                    w8 &= 67108863,
                    lo = Math.imul(al9, bl0),
                    mid = (mid = Math.imul(al9, bh0)) + Math.imul(ah9, bl0) | 0,
                    hi = Math.imul(ah9, bh0),
                    lo = lo + Math.imul(al8, bl1) | 0,
                    mid = (mid = mid + Math.imul(al8, bh1) | 0) + Math.imul(ah8, bl1) | 0,
                    hi = hi + Math.imul(ah8, bh1) | 0,
                    lo = lo + Math.imul(al7, bl2) | 0,
                    mid = (mid = mid + Math.imul(al7, bh2) | 0) + Math.imul(ah7, bl2) | 0,
                    hi = hi + Math.imul(ah7, bh2) | 0,
                    lo = lo + Math.imul(al6, bl3) | 0,
                    mid = (mid = mid + Math.imul(al6, bh3) | 0) + Math.imul(ah6, bl3) | 0,
                    hi = hi + Math.imul(ah6, bh3) | 0,
                    lo = lo + Math.imul(al5, bl4) | 0,
                    mid = (mid = mid + Math.imul(al5, bh4) | 0) + Math.imul(ah5, bl4) | 0,
                    hi = hi + Math.imul(ah5, bh4) | 0,
                    lo = lo + Math.imul(al4, bl5) | 0,
                    mid = (mid = mid + Math.imul(al4, bh5) | 0) + Math.imul(ah4, bl5) | 0,
                    hi = hi + Math.imul(ah4, bh5) | 0,
                    lo = lo + Math.imul(al3, bl6) | 0,
                    mid = (mid = mid + Math.imul(al3, bh6) | 0) + Math.imul(ah3, bl6) | 0,
                    hi = hi + Math.imul(ah3, bh6) | 0,
                    lo = lo + Math.imul(al2, bl7) | 0,
                    mid = (mid = mid + Math.imul(al2, bh7) | 0) + Math.imul(ah2, bl7) | 0,
                    hi = hi + Math.imul(ah2, bh7) | 0,
                    lo = lo + Math.imul(al1, bl8) | 0,
                    mid = (mid = mid + Math.imul(al1, bh8) | 0) + Math.imul(ah1, bl8) | 0,
                    hi = hi + Math.imul(ah1, bh8) | 0;
                    var w9 = (c + (lo = lo + Math.imul(al0, bl9) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al0, bh9) | 0) + Math.imul(ah0, bl9) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah0, bh9) | 0) + (mid >>> 13) | 0) + (w9 >>> 26) | 0,
                    w9 &= 67108863,
                    lo = Math.imul(al9, bl1),
                    mid = (mid = Math.imul(al9, bh1)) + Math.imul(ah9, bl1) | 0,
                    hi = Math.imul(ah9, bh1),
                    lo = lo + Math.imul(al8, bl2) | 0,
                    mid = (mid = mid + Math.imul(al8, bh2) | 0) + Math.imul(ah8, bl2) | 0,
                    hi = hi + Math.imul(ah8, bh2) | 0,
                    lo = lo + Math.imul(al7, bl3) | 0,
                    mid = (mid = mid + Math.imul(al7, bh3) | 0) + Math.imul(ah7, bl3) | 0,
                    hi = hi + Math.imul(ah7, bh3) | 0,
                    lo = lo + Math.imul(al6, bl4) | 0,
                    mid = (mid = mid + Math.imul(al6, bh4) | 0) + Math.imul(ah6, bl4) | 0,
                    hi = hi + Math.imul(ah6, bh4) | 0,
                    lo = lo + Math.imul(al5, bl5) | 0,
                    mid = (mid = mid + Math.imul(al5, bh5) | 0) + Math.imul(ah5, bl5) | 0,
                    hi = hi + Math.imul(ah5, bh5) | 0,
                    lo = lo + Math.imul(al4, bl6) | 0,
                    mid = (mid = mid + Math.imul(al4, bh6) | 0) + Math.imul(ah4, bl6) | 0,
                    hi = hi + Math.imul(ah4, bh6) | 0,
                    lo = lo + Math.imul(al3, bl7) | 0,
                    mid = (mid = mid + Math.imul(al3, bh7) | 0) + Math.imul(ah3, bl7) | 0,
                    hi = hi + Math.imul(ah3, bh7) | 0,
                    lo = lo + Math.imul(al2, bl8) | 0,
                    mid = (mid = mid + Math.imul(al2, bh8) | 0) + Math.imul(ah2, bl8) | 0,
                    hi = hi + Math.imul(ah2, bh8) | 0;
                    var w10 = (c + (lo = lo + Math.imul(al1, bl9) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al1, bh9) | 0) + Math.imul(ah1, bl9) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah1, bh9) | 0) + (mid >>> 13) | 0) + (w10 >>> 26) | 0,
                    w10 &= 67108863,
                    lo = Math.imul(al9, bl2),
                    mid = (mid = Math.imul(al9, bh2)) + Math.imul(ah9, bl2) | 0,
                    hi = Math.imul(ah9, bh2),
                    lo = lo + Math.imul(al8, bl3) | 0,
                    mid = (mid = mid + Math.imul(al8, bh3) | 0) + Math.imul(ah8, bl3) | 0,
                    hi = hi + Math.imul(ah8, bh3) | 0,
                    lo = lo + Math.imul(al7, bl4) | 0,
                    mid = (mid = mid + Math.imul(al7, bh4) | 0) + Math.imul(ah7, bl4) | 0,
                    hi = hi + Math.imul(ah7, bh4) | 0,
                    lo = lo + Math.imul(al6, bl5) | 0,
                    mid = (mid = mid + Math.imul(al6, bh5) | 0) + Math.imul(ah6, bl5) | 0,
                    hi = hi + Math.imul(ah6, bh5) | 0,
                    lo = lo + Math.imul(al5, bl6) | 0,
                    mid = (mid = mid + Math.imul(al5, bh6) | 0) + Math.imul(ah5, bl6) | 0,
                    hi = hi + Math.imul(ah5, bh6) | 0,
                    lo = lo + Math.imul(al4, bl7) | 0,
                    mid = (mid = mid + Math.imul(al4, bh7) | 0) + Math.imul(ah4, bl7) | 0,
                    hi = hi + Math.imul(ah4, bh7) | 0,
                    lo = lo + Math.imul(al3, bl8) | 0,
                    mid = (mid = mid + Math.imul(al3, bh8) | 0) + Math.imul(ah3, bl8) | 0,
                    hi = hi + Math.imul(ah3, bh8) | 0;
                    var w11 = (c + (lo = lo + Math.imul(al2, bl9) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al2, bh9) | 0) + Math.imul(ah2, bl9) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah2, bh9) | 0) + (mid >>> 13) | 0) + (w11 >>> 26) | 0,
                    w11 &= 67108863,
                    lo = Math.imul(al9, bl3),
                    mid = (mid = Math.imul(al9, bh3)) + Math.imul(ah9, bl3) | 0,
                    hi = Math.imul(ah9, bh3),
                    lo = lo + Math.imul(al8, bl4) | 0,
                    mid = (mid = mid + Math.imul(al8, bh4) | 0) + Math.imul(ah8, bl4) | 0,
                    hi = hi + Math.imul(ah8, bh4) | 0,
                    lo = lo + Math.imul(al7, bl5) | 0,
                    mid = (mid = mid + Math.imul(al7, bh5) | 0) + Math.imul(ah7, bl5) | 0,
                    hi = hi + Math.imul(ah7, bh5) | 0,
                    lo = lo + Math.imul(al6, bl6) | 0,
                    mid = (mid = mid + Math.imul(al6, bh6) | 0) + Math.imul(ah6, bl6) | 0,
                    hi = hi + Math.imul(ah6, bh6) | 0,
                    lo = lo + Math.imul(al5, bl7) | 0,
                    mid = (mid = mid + Math.imul(al5, bh7) | 0) + Math.imul(ah5, bl7) | 0,
                    hi = hi + Math.imul(ah5, bh7) | 0,
                    lo = lo + Math.imul(al4, bl8) | 0,
                    mid = (mid = mid + Math.imul(al4, bh8) | 0) + Math.imul(ah4, bl8) | 0,
                    hi = hi + Math.imul(ah4, bh8) | 0;
                    var w12 = (c + (lo = lo + Math.imul(al3, bl9) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al3, bh9) | 0) + Math.imul(ah3, bl9) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah3, bh9) | 0) + (mid >>> 13) | 0) + (w12 >>> 26) | 0,
                    w12 &= 67108863,
                    lo = Math.imul(al9, bl4),
                    mid = (mid = Math.imul(al9, bh4)) + Math.imul(ah9, bl4) | 0,
                    hi = Math.imul(ah9, bh4),
                    lo = lo + Math.imul(al8, bl5) | 0,
                    mid = (mid = mid + Math.imul(al8, bh5) | 0) + Math.imul(ah8, bl5) | 0,
                    hi = hi + Math.imul(ah8, bh5) | 0,
                    lo = lo + Math.imul(al7, bl6) | 0,
                    mid = (mid = mid + Math.imul(al7, bh6) | 0) + Math.imul(ah7, bl6) | 0,
                    hi = hi + Math.imul(ah7, bh6) | 0,
                    lo = lo + Math.imul(al6, bl7) | 0,
                    mid = (mid = mid + Math.imul(al6, bh7) | 0) + Math.imul(ah6, bl7) | 0,
                    hi = hi + Math.imul(ah6, bh7) | 0,
                    lo = lo + Math.imul(al5, bl8) | 0,
                    mid = (mid = mid + Math.imul(al5, bh8) | 0) + Math.imul(ah5, bl8) | 0,
                    hi = hi + Math.imul(ah5, bh8) | 0;
                    var w13 = (c + (lo = lo + Math.imul(al4, bl9) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al4, bh9) | 0) + Math.imul(ah4, bl9) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah4, bh9) | 0) + (mid >>> 13) | 0) + (w13 >>> 26) | 0,
                    w13 &= 67108863,
                    lo = Math.imul(al9, bl5),
                    mid = (mid = Math.imul(al9, bh5)) + Math.imul(ah9, bl5) | 0,
                    hi = Math.imul(ah9, bh5),
                    lo = lo + Math.imul(al8, bl6) | 0,
                    mid = (mid = mid + Math.imul(al8, bh6) | 0) + Math.imul(ah8, bl6) | 0,
                    hi = hi + Math.imul(ah8, bh6) | 0,
                    lo = lo + Math.imul(al7, bl7) | 0,
                    mid = (mid = mid + Math.imul(al7, bh7) | 0) + Math.imul(ah7, bl7) | 0,
                    hi = hi + Math.imul(ah7, bh7) | 0,
                    lo = lo + Math.imul(al6, bl8) | 0,
                    mid = (mid = mid + Math.imul(al6, bh8) | 0) + Math.imul(ah6, bl8) | 0,
                    hi = hi + Math.imul(ah6, bh8) | 0;
                    var w14 = (c + (lo = lo + Math.imul(al5, bl9) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al5, bh9) | 0) + Math.imul(ah5, bl9) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah5, bh9) | 0) + (mid >>> 13) | 0) + (w14 >>> 26) | 0,
                    w14 &= 67108863,
                    lo = Math.imul(al9, bl6),
                    mid = (mid = Math.imul(al9, bh6)) + Math.imul(ah9, bl6) | 0,
                    hi = Math.imul(ah9, bh6),
                    lo = lo + Math.imul(al8, bl7) | 0,
                    mid = (mid = mid + Math.imul(al8, bh7) | 0) + Math.imul(ah8, bl7) | 0,
                    hi = hi + Math.imul(ah8, bh7) | 0,
                    lo = lo + Math.imul(al7, bl8) | 0,
                    mid = (mid = mid + Math.imul(al7, bh8) | 0) + Math.imul(ah7, bl8) | 0,
                    hi = hi + Math.imul(ah7, bh8) | 0;
                    var w15 = (c + (lo = lo + Math.imul(al6, bl9) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al6, bh9) | 0) + Math.imul(ah6, bl9) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah6, bh9) | 0) + (mid >>> 13) | 0) + (w15 >>> 26) | 0,
                    w15 &= 67108863,
                    lo = Math.imul(al9, bl7),
                    mid = (mid = Math.imul(al9, bh7)) + Math.imul(ah9, bl7) | 0,
                    hi = Math.imul(ah9, bh7),
                    lo = lo + Math.imul(al8, bl8) | 0,
                    mid = (mid = mid + Math.imul(al8, bh8) | 0) + Math.imul(ah8, bl8) | 0,
                    hi = hi + Math.imul(ah8, bh8) | 0;
                    var w16 = (c + (lo = lo + Math.imul(al7, bl9) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al7, bh9) | 0) + Math.imul(ah7, bl9) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah7, bh9) | 0) + (mid >>> 13) | 0) + (w16 >>> 26) | 0,
                    w16 &= 67108863,
                    lo = Math.imul(al9, bl8),
                    mid = (mid = Math.imul(al9, bh8)) + Math.imul(ah9, bl8) | 0,
                    hi = Math.imul(ah9, bh8);
                    var w17 = (c + (lo = lo + Math.imul(al8, bl9) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al8, bh9) | 0) + Math.imul(ah8, bl9) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah8, bh9) | 0) + (mid >>> 13) | 0) + (w17 >>> 26) | 0,
                    w17 &= 67108863;
                    var w18 = (c + (lo = Math.imul(al9, bl9)) | 0) + ((8191 & (mid = (mid = Math.imul(al9, bh9)) + Math.imul(ah9, bl9) | 0)) << 13) | 0;
                    return c = ((hi = Math.imul(ah9, bh9)) + (mid >>> 13) | 0) + (w18 >>> 26) | 0,
                    w18 &= 67108863,
                    o[0] = w0,
                    o[1] = w1,
                    o[2] = w2,
                    o[3] = w3,
                    o[4] = w4,
                    o[5] = w5,
                    o[6] = w6,
                    o[7] = w7,
                    o[8] = w8,
                    o[9] = w9,
                    o[10] = w10,
                    o[11] = w11,
                    o[12] = w12,
                    o[13] = w13,
                    o[14] = w14,
                    o[15] = w15,
                    o[16] = w16,
                    o[17] = w17,
                    o[18] = w18,
                    0 !== c && (o[19] = c,
                    out.length++),
                    out
                };
                function jumboMulTo(self, num, out) {
                    return (new FFTM).mulp(self, num, out)
                }
                function FFTM(x, y) {
                    this.x = x,
                    this.y = y
                }
                Math.imul || (comb10MulTo = smallMulTo),
                BN.prototype.mulTo = function(num, out) {
                    var res, len = this.length + num.length;
                    return res = 10 === this.length && 10 === num.length ? comb10MulTo(this, num, out) : len < 63 ? smallMulTo(this, num, out) : len < 1024 ? function(self, num, out) {
                        out.negative = num.negative ^ self.negative,
                        out.length = self.length + num.length;
                        for (var carry = 0, hncarry = 0, k = 0; k < out.length - 1; k++) {
                            var ncarry = hncarry;
                            hncarry = 0;
                            for (var rword = 67108863 & carry, maxJ = Math.min(k, num.length - 1), j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
                                var i = k - j
                                  , r = (0 | self.words[i]) * (0 | num.words[j])
                                  , lo = 67108863 & r;
                                rword = 67108863 & (lo = lo + rword | 0),
                                hncarry += (ncarry = (ncarry = ncarry + (r / 67108864 | 0) | 0) + (lo >>> 26) | 0) >>> 26,
                                ncarry &= 67108863
                            }
                            out.words[k] = rword,
                            carry = ncarry,
                            ncarry = hncarry
                        }
                        return 0 !== carry ? out.words[k] = carry : out.length--,
                        out.strip()
                    }(this, num, out) : jumboMulTo(this, num, out),
                    res
                }
                ,
                FFTM.prototype.makeRBT = function(N) {
                    for (var t = new Array(N), l = BN.prototype._countBits(N) - 1, i = 0; i < N; i++)
                        t[i] = this.revBin(i, l, N);
                    return t
                }
                ,
                FFTM.prototype.revBin = function(x, l, N) {
                    if (0 === x || x === N - 1)
                        return x;
                    for (var rb = 0, i = 0; i < l; i++)
                        rb |= (1 & x) << l - i - 1,
                        x >>= 1;
                    return rb
                }
                ,
                FFTM.prototype.permute = function(rbt, rws, iws, rtws, itws, N) {
                    for (var i = 0; i < N; i++)
                        rtws[i] = rws[rbt[i]],
                        itws[i] = iws[rbt[i]]
                }
                ,
                FFTM.prototype.transform = function(rws, iws, rtws, itws, N, rbt) {
                    this.permute(rbt, rws, iws, rtws, itws, N);
                    for (var s = 1; s < N; s <<= 1)
                        for (var l = s << 1, rtwdf = Math.cos(2 * Math.PI / l), itwdf = Math.sin(2 * Math.PI / l), p = 0; p < N; p += l)
                            for (var rtwdf_ = rtwdf, itwdf_ = itwdf, j = 0; j < s; j++) {
                                var re = rtws[p + j]
                                  , ie = itws[p + j]
                                  , ro = rtws[p + j + s]
                                  , io = itws[p + j + s]
                                  , rx = rtwdf_ * ro - itwdf_ * io;
                                io = rtwdf_ * io + itwdf_ * ro,
                                ro = rx,
                                rtws[p + j] = re + ro,
                                itws[p + j] = ie + io,
                                rtws[p + j + s] = re - ro,
                                itws[p + j + s] = ie - io,
                                j !== l && (rx = rtwdf * rtwdf_ - itwdf * itwdf_,
                                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_,
                                rtwdf_ = rx)
                            }
                }
                ,
                FFTM.prototype.guessLen13b = function(n, m) {
                    var N = 1 | Math.max(m, n)
                      , odd = 1 & N
                      , i = 0;
                    for (N = N / 2 | 0; N; N >>>= 1)
                        i++;
                    return 1 << i + 1 + odd
                }
                ,
                FFTM.prototype.conjugate = function(rws, iws, N) {
                    if (!(N <= 1))
                        for (var i = 0; i < N / 2; i++) {
                            var t = rws[i];
                            rws[i] = rws[N - i - 1],
                            rws[N - i - 1] = t,
                            t = iws[i],
                            iws[i] = -iws[N - i - 1],
                            iws[N - i - 1] = -t
                        }
                }
                ,
                FFTM.prototype.normalize13b = function(ws, N) {
                    for (var carry = 0, i = 0; i < N / 2; i++) {
                        var w = 8192 * Math.round(ws[2 * i + 1] / N) + Math.round(ws[2 * i] / N) + carry;
                        ws[i] = 67108863 & w,
                        carry = w < 67108864 ? 0 : w / 67108864 | 0
                    }
                    return ws
                }
                ,
                FFTM.prototype.convert13b = function(ws, len, rws, N) {
                    for (var carry = 0, i = 0; i < len; i++)
                        carry += 0 | ws[i],
                        rws[2 * i] = 8191 & carry,
                        carry >>>= 13,
                        rws[2 * i + 1] = 8191 & carry,
                        carry >>>= 13;
                    for (i = 2 * len; i < N; ++i)
                        rws[i] = 0;
                    assert(0 === carry),
                    assert(0 == (-8192 & carry))
                }
                ,
                FFTM.prototype.stub = function(N) {
                    for (var ph = new Array(N), i = 0; i < N; i++)
                        ph[i] = 0;
                    return ph
                }
                ,
                FFTM.prototype.mulp = function(x, y, out) {
                    var N = 2 * this.guessLen13b(x.length, y.length)
                      , rbt = this.makeRBT(N)
                      , _ = this.stub(N)
                      , rws = new Array(N)
                      , rwst = new Array(N)
                      , iwst = new Array(N)
                      , nrws = new Array(N)
                      , nrwst = new Array(N)
                      , niwst = new Array(N)
                      , rmws = out.words;
                    rmws.length = N,
                    this.convert13b(x.words, x.length, rws, N),
                    this.convert13b(y.words, y.length, nrws, N),
                    this.transform(rws, _, rwst, iwst, N, rbt),
                    this.transform(nrws, _, nrwst, niwst, N, rbt);
                    for (var i = 0; i < N; i++) {
                        var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
                        iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i],
                        rwst[i] = rx
                    }
                    return this.conjugate(rwst, iwst, N),
                    this.transform(rwst, iwst, rmws, _, N, rbt),
                    this.conjugate(rmws, _, N),
                    this.normalize13b(rmws, N),
                    out.negative = x.negative ^ y.negative,
                    out.length = x.length + y.length,
                    out.strip()
                }
                ,
                BN.prototype.mul = function(num) {
                    var out = new BN(null);
                    return out.words = new Array(this.length + num.length),
                    this.mulTo(num, out)
                }
                ,
                BN.prototype.mulf = function(num) {
                    var out = new BN(null);
                    return out.words = new Array(this.length + num.length),
                    jumboMulTo(this, num, out)
                }
                ,
                BN.prototype.imul = function(num) {
                    return this.clone().mulTo(num, this)
                }
                ,
                BN.prototype.imuln = function(num) {
                    assert("number" == typeof num),
                    assert(num < 67108864);
                    for (var carry = 0, i = 0; i < this.length; i++) {
                        var w = (0 | this.words[i]) * num
                          , lo = (67108863 & w) + (67108863 & carry);
                        carry >>= 26,
                        carry += w / 67108864 | 0,
                        carry += lo >>> 26,
                        this.words[i] = 67108863 & lo
                    }
                    return 0 !== carry && (this.words[i] = carry,
                    this.length++),
                    this
                }
                ,
                BN.prototype.muln = function(num) {
                    return this.clone().imuln(num)
                }
                ,
                BN.prototype.sqr = function() {
                    return this.mul(this)
                }
                ,
                BN.prototype.isqr = function() {
                    return this.imul(this.clone())
                }
                ,
                BN.prototype.pow = function(num) {
                    var w = function(num) {
                        for (var w = new Array(num.bitLength()), bit = 0; bit < w.length; bit++) {
                            var off = bit / 26 | 0
                              , wbit = bit % 26;
                            w[bit] = (num.words[off] & 1 << wbit) >>> wbit
                        }
                        return w
                    }(num);
                    if (0 === w.length)
                        return new BN(1);
                    for (var res = this, i = 0; i < w.length && 0 === w[i]; i++,
                    res = res.sqr())
                        ;
                    if (++i < w.length)
                        for (var q = res.sqr(); i < w.length; i++,
                        q = q.sqr())
                            0 !== w[i] && (res = res.mul(q));
                    return res
                }
                ,
                BN.prototype.iushln = function(bits) {
                    assert("number" == typeof bits && bits >= 0);
                    var i, r = bits % 26, s = (bits - r) / 26, carryMask = 67108863 >>> 26 - r << 26 - r;
                    if (0 !== r) {
                        var carry = 0;
                        for (i = 0; i < this.length; i++) {
                            var newCarry = this.words[i] & carryMask
                              , c = (0 | this.words[i]) - newCarry << r;
                            this.words[i] = c | carry,
                            carry = newCarry >>> 26 - r
                        }
                        carry && (this.words[i] = carry,
                        this.length++)
                    }
                    if (0 !== s) {
                        for (i = this.length - 1; i >= 0; i--)
                            this.words[i + s] = this.words[i];
                        for (i = 0; i < s; i++)
                            this.words[i] = 0;
                        this.length += s
                    }
                    return this.strip()
                }
                ,
                BN.prototype.ishln = function(bits) {
                    return assert(0 === this.negative),
                    this.iushln(bits)
                }
                ,
                BN.prototype.iushrn = function(bits, hint, extended) {
                    var h;
                    assert("number" == typeof bits && bits >= 0),
                    h = hint ? (hint - hint % 26) / 26 : 0;
                    var r = bits % 26
                      , s = Math.min((bits - r) / 26, this.length)
                      , mask = 67108863 ^ 67108863 >>> r << r
                      , maskedWords = extended;
                    if (h -= s,
                    h = Math.max(0, h),
                    maskedWords) {
                        for (var i = 0; i < s; i++)
                            maskedWords.words[i] = this.words[i];
                        maskedWords.length = s
                    }
                    if (0 === s)
                        ;
                    else if (this.length > s)
                        for (this.length -= s,
                        i = 0; i < this.length; i++)
                            this.words[i] = this.words[i + s];
                    else
                        this.words[0] = 0,
                        this.length = 1;
                    var carry = 0;
                    for (i = this.length - 1; i >= 0 && (0 !== carry || i >= h); i--) {
                        var word = 0 | this.words[i];
                        this.words[i] = carry << 26 - r | word >>> r,
                        carry = word & mask
                    }
                    return maskedWords && 0 !== carry && (maskedWords.words[maskedWords.length++] = carry),
                    0 === this.length && (this.words[0] = 0,
                    this.length = 1),
                    this.strip()
                }
                ,
                BN.prototype.ishrn = function(bits, hint, extended) {
                    return assert(0 === this.negative),
                    this.iushrn(bits, hint, extended)
                }
                ,
                BN.prototype.shln = function(bits) {
                    return this.clone().ishln(bits)
                }
                ,
                BN.prototype.ushln = function(bits) {
                    return this.clone().iushln(bits)
                }
                ,
                BN.prototype.shrn = function(bits) {
                    return this.clone().ishrn(bits)
                }
                ,
                BN.prototype.ushrn = function(bits) {
                    return this.clone().iushrn(bits)
                }
                ,
                BN.prototype.testn = function(bit) {
                    assert("number" == typeof bit && bit >= 0);
                    var r = bit % 26
                      , s = (bit - r) / 26
                      , q = 1 << r;
                    return !(this.length <= s) && !!(this.words[s] & q)
                }
                ,
                BN.prototype.imaskn = function(bits) {
                    assert("number" == typeof bits && bits >= 0);
                    var r = bits % 26
                      , s = (bits - r) / 26;
                    if (assert(0 === this.negative, "imaskn works only with positive numbers"),
                    this.length <= s)
                        return this;
                    if (0 !== r && s++,
                    this.length = Math.min(s, this.length),
                    0 !== r) {
                        var mask = 67108863 ^ 67108863 >>> r << r;
                        this.words[this.length - 1] &= mask
                    }
                    return this.strip()
                }
                ,
                BN.prototype.maskn = function(bits) {
                    return this.clone().imaskn(bits)
                }
                ,
                BN.prototype.iaddn = function(num) {
                    return assert("number" == typeof num),
                    assert(num < 67108864),
                    num < 0 ? this.isubn(-num) : 0 !== this.negative ? 1 === this.length && (0 | this.words[0]) < num ? (this.words[0] = num - (0 | this.words[0]),
                    this.negative = 0,
                    this) : (this.negative = 0,
                    this.isubn(num),
                    this.negative = 1,
                    this) : this._iaddn(num)
                }
                ,
                BN.prototype._iaddn = function(num) {
                    this.words[0] += num;
                    for (var i = 0; i < this.length && this.words[i] >= 67108864; i++)
                        this.words[i] -= 67108864,
                        i === this.length - 1 ? this.words[i + 1] = 1 : this.words[i + 1]++;
                    return this.length = Math.max(this.length, i + 1),
                    this
                }
                ,
                BN.prototype.isubn = function(num) {
                    if (assert("number" == typeof num),
                    assert(num < 67108864),
                    num < 0)
                        return this.iaddn(-num);
                    if (0 !== this.negative)
                        return this.negative = 0,
                        this.iaddn(num),
                        this.negative = 1,
                        this;
                    if (this.words[0] -= num,
                    1 === this.length && this.words[0] < 0)
                        this.words[0] = -this.words[0],
                        this.negative = 1;
                    else
                        for (var i = 0; i < this.length && this.words[i] < 0; i++)
                            this.words[i] += 67108864,
                            this.words[i + 1] -= 1;
                    return this.strip()
                }
                ,
                BN.prototype.addn = function(num) {
                    return this.clone().iaddn(num)
                }
                ,
                BN.prototype.subn = function(num) {
                    return this.clone().isubn(num)
                }
                ,
                BN.prototype.iabs = function() {
                    return this.negative = 0,
                    this
                }
                ,
                BN.prototype.abs = function() {
                    return this.clone().iabs()
                }
                ,
                BN.prototype._ishlnsubmul = function(num, mul, shift) {
                    var i, w, len = num.length + shift;
                    this._expand(len);
                    var carry = 0;
                    for (i = 0; i < num.length; i++) {
                        w = (0 | this.words[i + shift]) + carry;
                        var right = (0 | num.words[i]) * mul;
                        carry = ((w -= 67108863 & right) >> 26) - (right / 67108864 | 0),
                        this.words[i + shift] = 67108863 & w
                    }
                    for (; i < this.length - shift; i++)
                        carry = (w = (0 | this.words[i + shift]) + carry) >> 26,
                        this.words[i + shift] = 67108863 & w;
                    if (0 === carry)
                        return this.strip();
                    for (assert(-1 === carry),
                    carry = 0,
                    i = 0; i < this.length; i++)
                        carry = (w = -(0 | this.words[i]) + carry) >> 26,
                        this.words[i] = 67108863 & w;
                    return this.negative = 1,
                    this.strip()
                }
                ,
                BN.prototype._wordDiv = function(num, mode) {
                    var shift = (this.length,
                    num.length)
                      , a = this.clone()
                      , b = num
                      , bhi = 0 | b.words[b.length - 1];
                    0 !== (shift = 26 - this._countBits(bhi)) && (b = b.ushln(shift),
                    a.iushln(shift),
                    bhi = 0 | b.words[b.length - 1]);
                    var q, m = a.length - b.length;
                    if ("mod" !== mode) {
                        (q = new BN(null)).length = m + 1,
                        q.words = new Array(q.length);
                        for (var i = 0; i < q.length; i++)
                            q.words[i] = 0
                    }
                    var diff = a.clone()._ishlnsubmul(b, 1, m);
                    0 === diff.negative && (a = diff,
                    q && (q.words[m] = 1));
                    for (var j = m - 1; j >= 0; j--) {
                        var qj = 67108864 * (0 | a.words[b.length + j]) + (0 | a.words[b.length + j - 1]);
                        for (qj = Math.min(qj / bhi | 0, 67108863),
                        a._ishlnsubmul(b, qj, j); 0 !== a.negative; )
                            qj--,
                            a.negative = 0,
                            a._ishlnsubmul(b, 1, j),
                            a.isZero() || (a.negative ^= 1);
                        q && (q.words[j] = qj)
                    }
                    return q && q.strip(),
                    a.strip(),
                    "div" !== mode && 0 !== shift && a.iushrn(shift),
                    {
                        div: q || null,
                        mod: a
                    }
                }
                ,
                BN.prototype.divmod = function(num, mode, positive) {
                    return assert(!num.isZero()),
                    this.isZero() ? {
                        div: new BN(0),
                        mod: new BN(0)
                    } : 0 !== this.negative && 0 === num.negative ? (res = this.neg().divmod(num, mode),
                    "mod" !== mode && (div = res.div.neg()),
                    "div" !== mode && (mod = res.mod.neg(),
                    positive && 0 !== mod.negative && mod.iadd(num)),
                    {
                        div,
                        mod
                    }) : 0 === this.negative && 0 !== num.negative ? (res = this.divmod(num.neg(), mode),
                    "mod" !== mode && (div = res.div.neg()),
                    {
                        div,
                        mod: res.mod
                    }) : 0 != (this.negative & num.negative) ? (res = this.neg().divmod(num.neg(), mode),
                    "div" !== mode && (mod = res.mod.neg(),
                    positive && 0 !== mod.negative && mod.isub(num)),
                    {
                        div: res.div,
                        mod
                    }) : num.length > this.length || this.cmp(num) < 0 ? {
                        div: new BN(0),
                        mod: this
                    } : 1 === num.length ? "div" === mode ? {
                        div: this.divn(num.words[0]),
                        mod: null
                    } : "mod" === mode ? {
                        div: null,
                        mod: new BN(this.modn(num.words[0]))
                    } : {
                        div: this.divn(num.words[0]),
                        mod: new BN(this.modn(num.words[0]))
                    } : this._wordDiv(num, mode);
                    var div, mod, res
                }
                ,
                BN.prototype.div = function(num) {
                    return this.divmod(num, "div", !1).div
                }
                ,
                BN.prototype.mod = function(num) {
                    return this.divmod(num, "mod", !1).mod
                }
                ,
                BN.prototype.umod = function(num) {
                    return this.divmod(num, "mod", !0).mod
                }
                ,
                BN.prototype.divRound = function(num) {
                    var dm = this.divmod(num);
                    if (dm.mod.isZero())
                        return dm.div;
                    var mod = 0 !== dm.div.negative ? dm.mod.isub(num) : dm.mod
                      , half = num.ushrn(1)
                      , r2 = num.andln(1)
                      , cmp = mod.cmp(half);
                    return cmp < 0 || 1 === r2 && 0 === cmp ? dm.div : 0 !== dm.div.negative ? dm.div.isubn(1) : dm.div.iaddn(1)
                }
                ,
                BN.prototype.modn = function(num) {
                    assert(num <= 67108863);
                    for (var p = (1 << 26) % num, acc = 0, i = this.length - 1; i >= 0; i--)
                        acc = (p * acc + (0 | this.words[i])) % num;
                    return acc
                }
                ,
                BN.prototype.idivn = function(num) {
                    assert(num <= 67108863);
                    for (var carry = 0, i = this.length - 1; i >= 0; i--) {
                        var w = (0 | this.words[i]) + 67108864 * carry;
                        this.words[i] = w / num | 0,
                        carry = w % num
                    }
                    return this.strip()
                }
                ,
                BN.prototype.divn = function(num) {
                    return this.clone().idivn(num)
                }
                ,
                BN.prototype.egcd = function(p) {
                    assert(0 === p.negative),
                    assert(!p.isZero());
                    var x = this
                      , y = p.clone();
                    x = 0 !== x.negative ? x.umod(p) : x.clone();
                    for (var A = new BN(1), B = new BN(0), C = new BN(0), D = new BN(1), g = 0; x.isEven() && y.isEven(); )
                        x.iushrn(1),
                        y.iushrn(1),
                        ++g;
                    for (var yp = y.clone(), xp = x.clone(); !x.isZero(); ) {
                        for (var i = 0, im = 1; 0 == (x.words[0] & im) && i < 26; ++i,
                        im <<= 1)
                            ;
                        if (i > 0)
                            for (x.iushrn(i); i-- > 0; )
                                (A.isOdd() || B.isOdd()) && (A.iadd(yp),
                                B.isub(xp)),
                                A.iushrn(1),
                                B.iushrn(1);
                        for (var j = 0, jm = 1; 0 == (y.words[0] & jm) && j < 26; ++j,
                        jm <<= 1)
                            ;
                        if (j > 0)
                            for (y.iushrn(j); j-- > 0; )
                                (C.isOdd() || D.isOdd()) && (C.iadd(yp),
                                D.isub(xp)),
                                C.iushrn(1),
                                D.iushrn(1);
                        x.cmp(y) >= 0 ? (x.isub(y),
                        A.isub(C),
                        B.isub(D)) : (y.isub(x),
                        C.isub(A),
                        D.isub(B))
                    }
                    return {
                        a: C,
                        b: D,
                        gcd: y.iushln(g)
                    }
                }
                ,
                BN.prototype._invmp = function(p) {
                    assert(0 === p.negative),
                    assert(!p.isZero());
                    var a = this
                      , b = p.clone();
                    a = 0 !== a.negative ? a.umod(p) : a.clone();
                    for (var res, x1 = new BN(1), x2 = new BN(0), delta = b.clone(); a.cmpn(1) > 0 && b.cmpn(1) > 0; ) {
                        for (var i = 0, im = 1; 0 == (a.words[0] & im) && i < 26; ++i,
                        im <<= 1)
                            ;
                        if (i > 0)
                            for (a.iushrn(i); i-- > 0; )
                                x1.isOdd() && x1.iadd(delta),
                                x1.iushrn(1);
                        for (var j = 0, jm = 1; 0 == (b.words[0] & jm) && j < 26; ++j,
                        jm <<= 1)
                            ;
                        if (j > 0)
                            for (b.iushrn(j); j-- > 0; )
                                x2.isOdd() && x2.iadd(delta),
                                x2.iushrn(1);
                        a.cmp(b) >= 0 ? (a.isub(b),
                        x1.isub(x2)) : (b.isub(a),
                        x2.isub(x1))
                    }
                    return (res = 0 === a.cmpn(1) ? x1 : x2).cmpn(0) < 0 && res.iadd(p),
                    res
                }
                ,
                BN.prototype.gcd = function(num) {
                    if (this.isZero())
                        return num.abs();
                    if (num.isZero())
                        return this.abs();
                    var a = this.clone()
                      , b = num.clone();
                    a.negative = 0,
                    b.negative = 0;
                    for (var shift = 0; a.isEven() && b.isEven(); shift++)
                        a.iushrn(1),
                        b.iushrn(1);
                    for (; ; ) {
                        for (; a.isEven(); )
                            a.iushrn(1);
                        for (; b.isEven(); )
                            b.iushrn(1);
                        var r = a.cmp(b);
                        if (r < 0) {
                            var t = a;
                            a = b,
                            b = t
                        } else if (0 === r || 0 === b.cmpn(1))
                            break;
                        a.isub(b)
                    }
                    return b.iushln(shift)
                }
                ,
                BN.prototype.invm = function(num) {
                    return this.egcd(num).a.umod(num)
                }
                ,
                BN.prototype.isEven = function() {
                    return 0 == (1 & this.words[0])
                }
                ,
                BN.prototype.isOdd = function() {
                    return 1 == (1 & this.words[0])
                }
                ,
                BN.prototype.andln = function(num) {
                    return this.words[0] & num
                }
                ,
                BN.prototype.bincn = function(bit) {
                    assert("number" == typeof bit);
                    var r = bit % 26
                      , s = (bit - r) / 26
                      , q = 1 << r;
                    if (this.length <= s)
                        return this._expand(s + 1),
                        this.words[s] |= q,
                        this;
                    for (var carry = q, i = s; 0 !== carry && i < this.length; i++) {
                        var w = 0 | this.words[i];
                        carry = (w += carry) >>> 26,
                        w &= 67108863,
                        this.words[i] = w
                    }
                    return 0 !== carry && (this.words[i] = carry,
                    this.length++),
                    this
                }
                ,
                BN.prototype.isZero = function() {
                    return 1 === this.length && 0 === this.words[0]
                }
                ,
                BN.prototype.cmpn = function(num) {
                    var res, negative = num < 0;
                    if (0 !== this.negative && !negative)
                        return -1;
                    if (0 === this.negative && negative)
                        return 1;
                    if (this.strip(),
                    this.length > 1)
                        res = 1;
                    else {
                        negative && (num = -num),
                        assert(num <= 67108863, "Number is too big");
                        var w = 0 | this.words[0];
                        res = w === num ? 0 : w < num ? -1 : 1
                    }
                    return 0 !== this.negative ? 0 | -res : res
                }
                ,
                BN.prototype.cmp = function(num) {
                    if (0 !== this.negative && 0 === num.negative)
                        return -1;
                    if (0 === this.negative && 0 !== num.negative)
                        return 1;
                    var res = this.ucmp(num);
                    return 0 !== this.negative ? 0 | -res : res
                }
                ,
                BN.prototype.ucmp = function(num) {
                    if (this.length > num.length)
                        return 1;
                    if (this.length < num.length)
                        return -1;
                    for (var res = 0, i = this.length - 1; i >= 0; i--) {
                        var a = 0 | this.words[i]
                          , b = 0 | num.words[i];
                        if (a !== b) {
                            a < b ? res = -1 : a > b && (res = 1);
                            break
                        }
                    }
                    return res
                }
                ,
                BN.prototype.gtn = function(num) {
                    return 1 === this.cmpn(num)
                }
                ,
                BN.prototype.gt = function(num) {
                    return 1 === this.cmp(num)
                }
                ,
                BN.prototype.gten = function(num) {
                    return this.cmpn(num) >= 0
                }
                ,
                BN.prototype.gte = function(num) {
                    return this.cmp(num) >= 0
                }
                ,
                BN.prototype.ltn = function(num) {
                    return -1 === this.cmpn(num)
                }
                ,
                BN.prototype.lt = function(num) {
                    return -1 === this.cmp(num)
                }
                ,
                BN.prototype.lten = function(num) {
                    return this.cmpn(num) <= 0
                }
                ,
                BN.prototype.lte = function(num) {
                    return this.cmp(num) <= 0
                }
                ,
                BN.prototype.eqn = function(num) {
                    return 0 === this.cmpn(num)
                }
                ,
                BN.prototype.eq = function(num) {
                    return 0 === this.cmp(num)
                }
                ,
                BN.red = function(num) {
                    return new Red(num)
                }
                ,
                BN.prototype.toRed = function(ctx) {
                    return assert(!this.red, "Already a number in reduction context"),
                    assert(0 === this.negative, "red works only with positives"),
                    ctx.convertTo(this)._forceRed(ctx)
                }
                ,
                BN.prototype.fromRed = function() {
                    return assert(this.red, "fromRed works only with numbers in reduction context"),
                    this.red.convertFrom(this)
                }
                ,
                BN.prototype._forceRed = function(ctx) {
                    return this.red = ctx,
                    this
                }
                ,
                BN.prototype.forceRed = function(ctx) {
                    return assert(!this.red, "Already a number in reduction context"),
                    this._forceRed(ctx)
                }
                ,
                BN.prototype.redAdd = function(num) {
                    return assert(this.red, "redAdd works only with red numbers"),
                    this.red.add(this, num)
                }
                ,
                BN.prototype.redIAdd = function(num) {
                    return assert(this.red, "redIAdd works only with red numbers"),
                    this.red.iadd(this, num)
                }
                ,
                BN.prototype.redSub = function(num) {
                    return assert(this.red, "redSub works only with red numbers"),
                    this.red.sub(this, num)
                }
                ,
                BN.prototype.redISub = function(num) {
                    return assert(this.red, "redISub works only with red numbers"),
                    this.red.isub(this, num)
                }
                ,
                BN.prototype.redShl = function(num) {
                    return assert(this.red, "redShl works only with red numbers"),
                    this.red.shl(this, num)
                }
                ,
                BN.prototype.redMul = function(num) {
                    return assert(this.red, "redMul works only with red numbers"),
                    this.red._verify2(this, num),
                    this.red.mul(this, num)
                }
                ,
                BN.prototype.redIMul = function(num) {
                    return assert(this.red, "redMul works only with red numbers"),
                    this.red._verify2(this, num),
                    this.red.imul(this, num)
                }
                ,
                BN.prototype.redSqr = function() {
                    return assert(this.red, "redSqr works only with red numbers"),
                    this.red._verify1(this),
                    this.red.sqr(this)
                }
                ,
                BN.prototype.redISqr = function() {
                    return assert(this.red, "redISqr works only with red numbers"),
                    this.red._verify1(this),
                    this.red.isqr(this)
                }
                ,
                BN.prototype.redSqrt = function() {
                    return assert(this.red, "redSqrt works only with red numbers"),
                    this.red._verify1(this),
                    this.red.sqrt(this)
                }
                ,
                BN.prototype.redInvm = function() {
                    return assert(this.red, "redInvm works only with red numbers"),
                    this.red._verify1(this),
                    this.red.invm(this)
                }
                ,
                BN.prototype.redNeg = function() {
                    return assert(this.red, "redNeg works only with red numbers"),
                    this.red._verify1(this),
                    this.red.neg(this)
                }
                ,
                BN.prototype.redPow = function(num) {
                    return assert(this.red && !num.red, "redPow(normalNum)"),
                    this.red._verify1(this),
                    this.red.pow(this, num)
                }
                ;
                var primes = {
                    k256: null,
                    p224: null,
                    p192: null,
                    p25519: null
                };
                function MPrime(name, p) {
                    this.name = name,
                    this.p = new BN(p,16),
                    this.n = this.p.bitLength(),
                    this.k = new BN(1).iushln(this.n).isub(this.p),
                    this.tmp = this._tmp()
                }
                function K256() {
                    MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
                }
                function P224() {
                    MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
                }
                function P192() {
                    MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
                }
                function P25519() {
                    MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
                }
                function Red(m) {
                    if ("string" == typeof m) {
                        var prime = BN._prime(m);
                        this.m = prime.p,
                        this.prime = prime
                    } else
                        assert(m.gtn(1), "modulus must be greater than 1"),
                        this.m = m,
                        this.prime = null
                }
                function Mont(m) {
                    Red.call(this, m),
                    this.shift = this.m.bitLength(),
                    this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26),
                    this.r = new BN(1).iushln(this.shift),
                    this.r2 = this.imod(this.r.sqr()),
                    this.rinv = this.r._invmp(this.m),
                    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m),
                    this.minv = this.minv.umod(this.r),
                    this.minv = this.r.sub(this.minv)
                }
                MPrime.prototype._tmp = function() {
                    var tmp = new BN(null);
                    return tmp.words = new Array(Math.ceil(this.n / 13)),
                    tmp
                }
                ,
                MPrime.prototype.ireduce = function(num) {
                    var rlen, r = num;
                    do {
                        this.split(r, this.tmp),
                        rlen = (r = (r = this.imulK(r)).iadd(this.tmp)).bitLength()
                    } while (rlen > this.n);
                    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
                    return 0 === cmp ? (r.words[0] = 0,
                    r.length = 1) : cmp > 0 ? r.isub(this.p) : void 0 !== r.strip ? r.strip() : r._strip(),
                    r
                }
                ,
                MPrime.prototype.split = function(input, out) {
                    input.iushrn(this.n, 0, out)
                }
                ,
                MPrime.prototype.imulK = function(num) {
                    return num.imul(this.k)
                }
                ,
                inherits(K256, MPrime),
                K256.prototype.split = function(input, output) {
                    for (var outLen = Math.min(input.length, 9), i = 0; i < outLen; i++)
                        output.words[i] = input.words[i];
                    if (output.length = outLen,
                    input.length <= 9)
                        return input.words[0] = 0,
                        void (input.length = 1);
                    var prev = input.words[9];
                    for (output.words[output.length++] = 4194303 & prev,
                    i = 10; i < input.length; i++) {
                        var next = 0 | input.words[i];
                        input.words[i - 10] = (4194303 & next) << 4 | prev >>> 22,
                        prev = next
                    }
                    prev >>>= 22,
                    input.words[i - 10] = prev,
                    0 === prev && input.length > 10 ? input.length -= 10 : input.length -= 9
                }
                ,
                K256.prototype.imulK = function(num) {
                    num.words[num.length] = 0,
                    num.words[num.length + 1] = 0,
                    num.length += 2;
                    for (var lo = 0, i = 0; i < num.length; i++) {
                        var w = 0 | num.words[i];
                        lo += 977 * w,
                        num.words[i] = 67108863 & lo,
                        lo = 64 * w + (lo / 67108864 | 0)
                    }
                    return 0 === num.words[num.length - 1] && (num.length--,
                    0 === num.words[num.length - 1] && num.length--),
                    num
                }
                ,
                inherits(P224, MPrime),
                inherits(P192, MPrime),
                inherits(P25519, MPrime),
                P25519.prototype.imulK = function(num) {
                    for (var carry = 0, i = 0; i < num.length; i++) {
                        var hi = 19 * (0 | num.words[i]) + carry
                          , lo = 67108863 & hi;
                        hi >>>= 26,
                        num.words[i] = lo,
                        carry = hi
                    }
                    return 0 !== carry && (num.words[num.length++] = carry),
                    num
                }
                ,
                BN._prime = function(name) {
                    if (primes[name])
                        return primes[name];
                    var prime;
                    if ("k256" === name)
                        prime = new K256;
                    else if ("p224" === name)
                        prime = new P224;
                    else if ("p192" === name)
                        prime = new P192;
                    else {
                        if ("p25519" !== name)
                            throw new Error("Unknown prime " + name);
                        prime = new P25519
                    }
                    return primes[name] = prime,
                    prime
                }
                ,
                Red.prototype._verify1 = function(a) {
                    assert(0 === a.negative, "red works only with positives"),
                    assert(a.red, "red works only with red numbers")
                }
                ,
                Red.prototype._verify2 = function(a, b) {
                    assert(0 == (a.negative | b.negative), "red works only with positives"),
                    assert(a.red && a.red === b.red, "red works only with red numbers")
                }
                ,
                Red.prototype.imod = function(a) {
                    return this.prime ? this.prime.ireduce(a)._forceRed(this) : a.umod(this.m)._forceRed(this)
                }
                ,
                Red.prototype.neg = function(a) {
                    return a.isZero() ? a.clone() : this.m.sub(a)._forceRed(this)
                }
                ,
                Red.prototype.add = function(a, b) {
                    this._verify2(a, b);
                    var res = a.add(b);
                    return res.cmp(this.m) >= 0 && res.isub(this.m),
                    res._forceRed(this)
                }
                ,
                Red.prototype.iadd = function(a, b) {
                    this._verify2(a, b);
                    var res = a.iadd(b);
                    return res.cmp(this.m) >= 0 && res.isub(this.m),
                    res
                }
                ,
                Red.prototype.sub = function(a, b) {
                    this._verify2(a, b);
                    var res = a.sub(b);
                    return res.cmpn(0) < 0 && res.iadd(this.m),
                    res._forceRed(this)
                }
                ,
                Red.prototype.isub = function(a, b) {
                    this._verify2(a, b);
                    var res = a.isub(b);
                    return res.cmpn(0) < 0 && res.iadd(this.m),
                    res
                }
                ,
                Red.prototype.shl = function(a, num) {
                    return this._verify1(a),
                    this.imod(a.ushln(num))
                }
                ,
                Red.prototype.imul = function(a, b) {
                    return this._verify2(a, b),
                    this.imod(a.imul(b))
                }
                ,
                Red.prototype.mul = function(a, b) {
                    return this._verify2(a, b),
                    this.imod(a.mul(b))
                }
                ,
                Red.prototype.isqr = function(a) {
                    return this.imul(a, a.clone())
                }
                ,
                Red.prototype.sqr = function(a) {
                    return this.mul(a, a)
                }
                ,
                Red.prototype.sqrt = function(a) {
                    if (a.isZero())
                        return a.clone();
                    var mod3 = this.m.andln(3);
                    if (assert(mod3 % 2 == 1),
                    3 === mod3) {
                        var pow = this.m.add(new BN(1)).iushrn(2);
                        return this.pow(a, pow)
                    }
                    for (var q = this.m.subn(1), s = 0; !q.isZero() && 0 === q.andln(1); )
                        s++,
                        q.iushrn(1);
                    assert(!q.isZero());
                    var one = new BN(1).toRed(this)
                      , nOne = one.redNeg()
                      , lpow = this.m.subn(1).iushrn(1)
                      , z = this.m.bitLength();
                    for (z = new BN(2 * z * z).toRed(this); 0 !== this.pow(z, lpow).cmp(nOne); )
                        z.redIAdd(nOne);
                    for (var c = this.pow(z, q), r = this.pow(a, q.addn(1).iushrn(1)), t = this.pow(a, q), m = s; 0 !== t.cmp(one); ) {
                        for (var tmp = t, i = 0; 0 !== tmp.cmp(one); i++)
                            tmp = tmp.redSqr();
                        assert(i < m);
                        var b = this.pow(c, new BN(1).iushln(m - i - 1));
                        r = r.redMul(b),
                        c = b.redSqr(),
                        t = t.redMul(c),
                        m = i
                    }
                    return r
                }
                ,
                Red.prototype.invm = function(a) {
                    var inv = a._invmp(this.m);
                    return 0 !== inv.negative ? (inv.negative = 0,
                    this.imod(inv).redNeg()) : this.imod(inv)
                }
                ,
                Red.prototype.pow = function(a, num) {
                    if (num.isZero())
                        return new BN(1).toRed(this);
                    if (0 === num.cmpn(1))
                        return a.clone();
                    var wnd = new Array(16);
                    wnd[0] = new BN(1).toRed(this),
                    wnd[1] = a;
                    for (var i = 2; i < wnd.length; i++)
                        wnd[i] = this.mul(wnd[i - 1], a);
                    var res = wnd[0]
                      , current = 0
                      , currentLen = 0
                      , start = num.bitLength() % 26;
                    for (0 === start && (start = 26),
                    i = num.length - 1; i >= 0; i--) {
                        for (var word = num.words[i], j = start - 1; j >= 0; j--) {
                            var bit = word >> j & 1;
                            res !== wnd[0] && (res = this.sqr(res)),
                            0 !== bit || 0 !== current ? (current <<= 1,
                            current |= bit,
                            (4 === ++currentLen || 0 === i && 0 === j) && (res = this.mul(res, wnd[current]),
                            currentLen = 0,
                            current = 0)) : currentLen = 0
                        }
                        start = 26
                    }
                    return res
                }
                ,
                Red.prototype.convertTo = function(num) {
                    var r = num.umod(this.m);
                    return r === num ? r.clone() : r
                }
                ,
                Red.prototype.convertFrom = function(num) {
                    var res = num.clone();
                    return res.red = null,
                    res
                }
                ,
                BN.mont = function(num) {
                    return new Mont(num)
                }
                ,
                inherits(Mont, Red),
                Mont.prototype.convertTo = function(num) {
                    return this.imod(num.ushln(this.shift))
                }
                ,
                Mont.prototype.convertFrom = function(num) {
                    var r = this.imod(num.mul(this.rinv));
                    return r.red = null,
                    r
                }
                ,
                Mont.prototype.imul = function(a, b) {
                    if (a.isZero() || b.isZero())
                        return a.words[0] = 0,
                        a.length = 1,
                        a;
                    var t = a.imul(b)
                      , c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
                      , u = t.isub(c).iushrn(this.shift)
                      , res = u;
                    return u.cmp(this.m) >= 0 ? res = u.isub(this.m) : u.cmpn(0) < 0 && (res = u.iadd(this.m)),
                    res._forceRed(this)
                }
                ,
                Mont.prototype.mul = function(a, b) {
                    if (a.isZero() || b.isZero())
                        return new BN(0)._forceRed(this);
                    var t = a.mul(b)
                      , c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
                      , u = t.isub(c).iushrn(this.shift)
                      , res = u;
                    return u.cmp(this.m) >= 0 ? res = u.isub(this.m) : u.cmpn(0) < 0 && (res = u.iadd(this.m)),
                    res._forceRed(this)
                }
                ,
                Mont.prototype.invm = function(a) {
                    return this.imod(a._invmp(this.m).mul(this.r2))._forceRed(this)
                }
            }(module = __webpack_require__.nmd(module), this)
        },
        29931: (module,__unused_webpack_exports,__webpack_require__)=>{
            var r;
            function Rand(rand) {
                this.rand = rand
            }
            if (module.exports = function(len) {
                return r || (r = new Rand(null)),
                r.generate(len)
            }
            ,
            module.exports.Rand = Rand,
            Rand.prototype.generate = function(len) {
                return this._rand(len)
            }
            ,
            Rand.prototype._rand = function(n) {
                if (this.rand.getBytes)
                    return this.rand.getBytes(n);
                for (var res = new Uint8Array(n), i = 0; i < res.length; i++)
                    res[i] = this.rand.getByte();
                return res
            }
            ,
            "object" == typeof self)
                self.crypto && self.crypto.getRandomValues ? Rand.prototype._rand = function(n) {
                    var arr = new Uint8Array(n);
                    return self.crypto.getRandomValues(arr),
                    arr
                }
                : self.msCrypto && self.msCrypto.getRandomValues ? Rand.prototype._rand = function(n) {
                    var arr = new Uint8Array(n);
                    return self.msCrypto.getRandomValues(arr),
                    arr
                }
                : "object" == typeof window && (Rand.prototype._rand = function() {
                    throw new Error("Not implemented yet")
                }
                );
            else
                try {
                    var crypto = __webpack_require__(89214);
                    if ("function" != typeof crypto.randomBytes)
                        throw new Error("Not supported");
                    Rand.prototype._rand = function(n) {
                        return crypto.randomBytes(n)
                    }
                } catch (e) {}
        }
        ,
        48764: (__unused_webpack_module,exports,__webpack_require__)=>{
            "use strict";
            const base64 = __webpack_require__(79742)
              , ieee754 = __webpack_require__(80645)
              , customInspectSymbol = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
            exports.Buffer = Buffer,
            exports.INSPECT_MAX_BYTES = 50;
            const K_MAX_LENGTH = 2147483647;
            function createBuffer(length) {
                if (length > K_MAX_LENGTH)
                    throw new RangeError('The value "' + length + '" is invalid for option "size"');
                const buf = new Uint8Array(length);
                return Object.setPrototypeOf(buf, Buffer.prototype),
                buf
            }
            function Buffer(arg, encodingOrOffset, length) {
                if ("number" == typeof arg) {
                    if ("string" == typeof encodingOrOffset)
                        throw new TypeError('The "string" argument must be of type string. Received type number');
                    return allocUnsafe(arg)
                }
                return from(arg, encodingOrOffset, length)
            }
            function from(value, encodingOrOffset, length) {
                if ("string" == typeof value)
                    return function(string, encoding) {
                        "string" == typeof encoding && "" !== encoding || (encoding = "utf8");
                        if (!Buffer.isEncoding(encoding))
                            throw new TypeError("Unknown encoding: " + encoding);
                        const length = 0 | byteLength(string, encoding);
                        let buf = createBuffer(length);
                        const actual = buf.write(string, encoding);
                        actual !== length && (buf = buf.slice(0, actual));
                        return buf
                    }(value, encodingOrOffset);
                if (ArrayBuffer.isView(value))
                    return function(arrayView) {
                        if (isInstance(arrayView, Uint8Array)) {
                            const copy = new Uint8Array(arrayView);
                            return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
                        }
                        return fromArrayLike(arrayView)
                    }(value);
                if (null == value)
                    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
                if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer))
                    return fromArrayBuffer(value, encodingOrOffset, length);
                if ("undefined" != typeof SharedArrayBuffer && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer)))
                    return fromArrayBuffer(value, encodingOrOffset, length);
                if ("number" == typeof value)
                    throw new TypeError('The "value" argument must not be of type number. Received type number');
                const valueOf = value.valueOf && value.valueOf();
                if (null != valueOf && valueOf !== value)
                    return Buffer.from(valueOf, encodingOrOffset, length);
                const b = function(obj) {
                    if (Buffer.isBuffer(obj)) {
                        const len = 0 | checked(obj.length)
                          , buf = createBuffer(len);
                        return 0 === buf.length || obj.copy(buf, 0, 0, len),
                        buf
                    }
                    if (void 0 !== obj.length)
                        return "number" != typeof obj.length || numberIsNaN(obj.length) ? createBuffer(0) : fromArrayLike(obj);
                    if ("Buffer" === obj.type && Array.isArray(obj.data))
                        return fromArrayLike(obj.data)
                }(value);
                if (b)
                    return b;
                if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof value[Symbol.toPrimitive])
                    return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
                throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value)
            }
            function assertSize(size) {
                if ("number" != typeof size)
                    throw new TypeError('"size" argument must be of type number');
                if (size < 0)
                    throw new RangeError('The value "' + size + '" is invalid for option "size"')
            }
            function allocUnsafe(size) {
                return assertSize(size),
                createBuffer(size < 0 ? 0 : 0 | checked(size))
            }
            function fromArrayLike(array) {
                const length = array.length < 0 ? 0 : 0 | checked(array.length)
                  , buf = createBuffer(length);
                for (let i = 0; i < length; i += 1)
                    buf[i] = 255 & array[i];
                return buf
            }
            function fromArrayBuffer(array, byteOffset, length) {
                if (byteOffset < 0 || array.byteLength < byteOffset)
                    throw new RangeError('"offset" is outside of buffer bounds');
                if (array.byteLength < byteOffset + (length || 0))
                    throw new RangeError('"length" is outside of buffer bounds');
                let buf;
                return buf = void 0 === byteOffset && void 0 === length ? new Uint8Array(array) : void 0 === length ? new Uint8Array(array,byteOffset) : new Uint8Array(array,byteOffset,length),
                Object.setPrototypeOf(buf, Buffer.prototype),
                buf
            }
            function checked(length) {
                if (length >= K_MAX_LENGTH)
                    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
                return 0 | length
            }
            function byteLength(string, encoding) {
                if (Buffer.isBuffer(string))
                    return string.length;
                if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer))
                    return string.byteLength;
                if ("string" != typeof string)
                    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
                const len = string.length
                  , mustMatch = arguments.length > 2 && !0 === arguments[2];
                if (!mustMatch && 0 === len)
                    return 0;
                let loweredCase = !1;
                for (; ; )
                    switch (encoding) {
                    case "ascii":
                    case "latin1":
                    case "binary":
                        return len;
                    case "utf8":
                    case "utf-8":
                        return utf8ToBytes(string).length;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return 2 * len;
                    case "hex":
                        return len >>> 1;
                    case "base64":
                        return base64ToBytes(string).length;
                    default:
                        if (loweredCase)
                            return mustMatch ? -1 : utf8ToBytes(string).length;
                        encoding = ("" + encoding).toLowerCase(),
                        loweredCase = !0
                    }
            }
            function slowToString(encoding, start, end) {
                let loweredCase = !1;
                if ((void 0 === start || start < 0) && (start = 0),
                start > this.length)
                    return "";
                if ((void 0 === end || end > this.length) && (end = this.length),
                end <= 0)
                    return "";
                if ((end >>>= 0) <= (start >>>= 0))
                    return "";
                for (encoding || (encoding = "utf8"); ; )
                    switch (encoding) {
                    case "hex":
                        return hexSlice(this, start, end);
                    case "utf8":
                    case "utf-8":
                        return utf8Slice(this, start, end);
                    case "ascii":
                        return asciiSlice(this, start, end);
                    case "latin1":
                    case "binary":
                        return latin1Slice(this, start, end);
                    case "base64":
                        return base64Slice(this, start, end);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return utf16leSlice(this, start, end);
                    default:
                        if (loweredCase)
                            throw new TypeError("Unknown encoding: " + encoding);
                        encoding = (encoding + "").toLowerCase(),
                        loweredCase = !0
                    }
            }
            function swap(b, n, m) {
                const i = b[n];
                b[n] = b[m],
                b[m] = i
            }
            function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
                if (0 === buffer.length)
                    return -1;
                if ("string" == typeof byteOffset ? (encoding = byteOffset,
                byteOffset = 0) : byteOffset > 2147483647 ? byteOffset = 2147483647 : byteOffset < -2147483648 && (byteOffset = -2147483648),
                numberIsNaN(byteOffset = +byteOffset) && (byteOffset = dir ? 0 : buffer.length - 1),
                byteOffset < 0 && (byteOffset = buffer.length + byteOffset),
                byteOffset >= buffer.length) {
                    if (dir)
                        return -1;
                    byteOffset = buffer.length - 1
                } else if (byteOffset < 0) {
                    if (!dir)
                        return -1;
                    byteOffset = 0
                }
                if ("string" == typeof val && (val = Buffer.from(val, encoding)),
                Buffer.isBuffer(val))
                    return 0 === val.length ? -1 : arrayIndexOf(buffer, val, byteOffset, encoding, dir);
                if ("number" == typeof val)
                    return val &= 255,
                    "function" == typeof Uint8Array.prototype.indexOf ? dir ? Uint8Array.prototype.indexOf.call(buffer, val, byteOffset) : Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset) : arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
                throw new TypeError("val must be string, number or Buffer")
            }
            function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
                let i, indexSize = 1, arrLength = arr.length, valLength = val.length;
                if (void 0 !== encoding && ("ucs2" === (encoding = String(encoding).toLowerCase()) || "ucs-2" === encoding || "utf16le" === encoding || "utf-16le" === encoding)) {
                    if (arr.length < 2 || val.length < 2)
                        return -1;
                    indexSize = 2,
                    arrLength /= 2,
                    valLength /= 2,
                    byteOffset /= 2
                }
                function read(buf, i) {
                    return 1 === indexSize ? buf[i] : buf.readUInt16BE(i * indexSize)
                }
                if (dir) {
                    let foundIndex = -1;
                    for (i = byteOffset; i < arrLength; i++)
                        if (read(arr, i) === read(val, -1 === foundIndex ? 0 : i - foundIndex)) {
                            if (-1 === foundIndex && (foundIndex = i),
                            i - foundIndex + 1 === valLength)
                                return foundIndex * indexSize
                        } else
                            -1 !== foundIndex && (i -= i - foundIndex),
                            foundIndex = -1
                } else
                    for (byteOffset + valLength > arrLength && (byteOffset = arrLength - valLength),
                    i = byteOffset; i >= 0; i--) {
                        let found = !0;
                        for (let j = 0; j < valLength; j++)
                            if (read(arr, i + j) !== read(val, j)) {
                                found = !1;
                                break
                            }
                        if (found)
                            return i
                    }
                return -1
            }
            function hexWrite(buf, string, offset, length) {
                offset = Number(offset) || 0;
                const remaining = buf.length - offset;
                length ? (length = Number(length)) > remaining && (length = remaining) : length = remaining;
                const strLen = string.length;
                let i;
                for (length > strLen / 2 && (length = strLen / 2),
                i = 0; i < length; ++i) {
                    const parsed = parseInt(string.substr(2 * i, 2), 16);
                    if (numberIsNaN(parsed))
                        return i;
                    buf[offset + i] = parsed
                }
                return i
            }
            function utf8Write(buf, string, offset, length) {
                return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
            }
            function asciiWrite(buf, string, offset, length) {
                return blitBuffer(function(str) {
                    const byteArray = [];
                    for (let i = 0; i < str.length; ++i)
                        byteArray.push(255 & str.charCodeAt(i));
                    return byteArray
                }(string), buf, offset, length)
            }
            function base64Write(buf, string, offset, length) {
                return blitBuffer(base64ToBytes(string), buf, offset, length)
            }
            function ucs2Write(buf, string, offset, length) {
                return blitBuffer(function(str, units) {
                    let c, hi, lo;
                    const byteArray = [];
                    for (let i = 0; i < str.length && !((units -= 2) < 0); ++i)
                        c = str.charCodeAt(i),
                        hi = c >> 8,
                        lo = c % 256,
                        byteArray.push(lo),
                        byteArray.push(hi);
                    return byteArray
                }(string, buf.length - offset), buf, offset, length)
            }
            function base64Slice(buf, start, end) {
                return 0 === start && end === buf.length ? base64.fromByteArray(buf) : base64.fromByteArray(buf.slice(start, end))
            }
            function utf8Slice(buf, start, end) {
                end = Math.min(buf.length, end);
                const res = [];
                let i = start;
                for (; i < end; ) {
                    const firstByte = buf[i];
                    let codePoint = null
                      , bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
                    if (i + bytesPerSequence <= end) {
                        let secondByte, thirdByte, fourthByte, tempCodePoint;
                        switch (bytesPerSequence) {
                        case 1:
                            firstByte < 128 && (codePoint = firstByte);
                            break;
                        case 2:
                            secondByte = buf[i + 1],
                            128 == (192 & secondByte) && (tempCodePoint = (31 & firstByte) << 6 | 63 & secondByte,
                            tempCodePoint > 127 && (codePoint = tempCodePoint));
                            break;
                        case 3:
                            secondByte = buf[i + 1],
                            thirdByte = buf[i + 2],
                            128 == (192 & secondByte) && 128 == (192 & thirdByte) && (tempCodePoint = (15 & firstByte) << 12 | (63 & secondByte) << 6 | 63 & thirdByte,
                            tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343) && (codePoint = tempCodePoint));
                            break;
                        case 4:
                            secondByte = buf[i + 1],
                            thirdByte = buf[i + 2],
                            fourthByte = buf[i + 3],
                            128 == (192 & secondByte) && 128 == (192 & thirdByte) && 128 == (192 & fourthByte) && (tempCodePoint = (15 & firstByte) << 18 | (63 & secondByte) << 12 | (63 & thirdByte) << 6 | 63 & fourthByte,
                            tempCodePoint > 65535 && tempCodePoint < 1114112 && (codePoint = tempCodePoint))
                        }
                    }
                    null === codePoint ? (codePoint = 65533,
                    bytesPerSequence = 1) : codePoint > 65535 && (codePoint -= 65536,
                    res.push(codePoint >>> 10 & 1023 | 55296),
                    codePoint = 56320 | 1023 & codePoint),
                    res.push(codePoint),
                    i += bytesPerSequence
                }
                return function(codePoints) {
                    const len = codePoints.length;
                    if (len <= MAX_ARGUMENTS_LENGTH)
                        return String.fromCharCode.apply(String, codePoints);
                    let res = ""
                      , i = 0;
                    for (; i < len; )
                        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
                    return res
                }(res)
            }
            Buffer.TYPED_ARRAY_SUPPORT = function() {
                try {
                    const arr = new Uint8Array(1)
                      , proto = {
                        foo: function() {
                            return 42
                        }
                    };
                    return Object.setPrototypeOf(proto, Uint8Array.prototype),
                    Object.setPrototypeOf(arr, proto),
                    42 === arr.foo()
                } catch (e) {
                    return !1
                }
            }(),
            !Buffer.TYPED_ARRAY_SUPPORT && "undefined" != typeof console && console.error,
            Object.defineProperty(Buffer.prototype, "parent", {
                enumerable: !0,
                get: function() {
                    if (Buffer.isBuffer(this))
                        return this.buffer
                }
            }),
            Object.defineProperty(Buffer.prototype, "offset", {
                enumerable: !0,
                get: function() {
                    if (Buffer.isBuffer(this))
                        return this.byteOffset
                }
            }),
            Buffer.poolSize = 8192,
            Buffer.from = function(value, encodingOrOffset, length) {
                return from(value, encodingOrOffset, length)
            }
            ,
            Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype),
            Object.setPrototypeOf(Buffer, Uint8Array),
            Buffer.alloc = function(size, fill, encoding) {
                return function(size, fill, encoding) {
                    return assertSize(size),
                    size <= 0 ? createBuffer(size) : void 0 !== fill ? "string" == typeof encoding ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill) : createBuffer(size)
                }(size, fill, encoding)
            }
            ,
            Buffer.allocUnsafe = function(size) {
                return allocUnsafe(size)
            }
            ,
            Buffer.allocUnsafeSlow = function(size) {
                return allocUnsafe(size)
            }
            ,
            Buffer.isBuffer = function(b) {
                return null != b && !0 === b._isBuffer && b !== Buffer.prototype
            }
            ,
            Buffer.compare = function(a, b) {
                if (isInstance(a, Uint8Array) && (a = Buffer.from(a, a.offset, a.byteLength)),
                isInstance(b, Uint8Array) && (b = Buffer.from(b, b.offset, b.byteLength)),
                !Buffer.isBuffer(a) || !Buffer.isBuffer(b))
                    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                if (a === b)
                    return 0;
                let x = a.length
                  , y = b.length;
                for (let i = 0, len = Math.min(x, y); i < len; ++i)
                    if (a[i] !== b[i]) {
                        x = a[i],
                        y = b[i];
                        break
                    }
                return x < y ? -1 : y < x ? 1 : 0
            }
            ,
            Buffer.isEncoding = function(encoding) {
                switch (String(encoding).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return !0;
                default:
                    return !1
                }
            }
            ,
            Buffer.concat = function(list, length) {
                if (!Array.isArray(list))
                    throw new TypeError('"list" argument must be an Array of Buffers');
                if (0 === list.length)
                    return Buffer.alloc(0);
                let i;
                if (void 0 === length)
                    for (length = 0,
                    i = 0; i < list.length; ++i)
                        length += list[i].length;
                const buffer = Buffer.allocUnsafe(length);
                let pos = 0;
                for (i = 0; i < list.length; ++i) {
                    let buf = list[i];
                    if (isInstance(buf, Uint8Array))
                        pos + buf.length > buffer.length ? (Buffer.isBuffer(buf) || (buf = Buffer.from(buf)),
                        buf.copy(buffer, pos)) : Uint8Array.prototype.set.call(buffer, buf, pos);
                    else {
                        if (!Buffer.isBuffer(buf))
                            throw new TypeError('"list" argument must be an Array of Buffers');
                        buf.copy(buffer, pos)
                    }
                    pos += buf.length
                }
                return buffer
            }
            ,
            Buffer.byteLength = byteLength,
            Buffer.prototype._isBuffer = !0,
            Buffer.prototype.swap16 = function() {
                const len = this.length;
                if (len % 2 != 0)
                    throw new RangeError("Buffer size must be a multiple of 16-bits");
                for (let i = 0; i < len; i += 2)
                    swap(this, i, i + 1);
                return this
            }
            ,
            Buffer.prototype.swap32 = function() {
                const len = this.length;
                if (len % 4 != 0)
                    throw new RangeError("Buffer size must be a multiple of 32-bits");
                for (let i = 0; i < len; i += 4)
                    swap(this, i, i + 3),
                    swap(this, i + 1, i + 2);
                return this
            }
            ,
            Buffer.prototype.swap64 = function() {
                const len = this.length;
                if (len % 8 != 0)
                    throw new RangeError("Buffer size must be a multiple of 64-bits");
                for (let i = 0; i < len; i += 8)
                    swap(this, i, i + 7),
                    swap(this, i + 1, i + 6),
                    swap(this, i + 2, i + 5),
                    swap(this, i + 3, i + 4);
                return this
            }
            ,
            Buffer.prototype.toString = function() {
                const length = this.length;
                return 0 === length ? "" : 0 === arguments.length ? utf8Slice(this, 0, length) : slowToString.apply(this, arguments)
            }
            ,
            Buffer.prototype.toLocaleString = Buffer.prototype.toString,
            Buffer.prototype.equals = function(b) {
                if (!Buffer.isBuffer(b))
                    throw new TypeError("Argument must be a Buffer");
                return this === b || 0 === Buffer.compare(this, b)
            }
            ,
            Buffer.prototype.inspect = function() {
                let str = "";
                const max = exports.INSPECT_MAX_BYTES;
                return str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim(),
                this.length > max && (str += " ... "),
                "<Buffer " + str + ">"
            }
            ,
            customInspectSymbol && (Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect),
            Buffer.prototype.compare = function(target, start, end, thisStart, thisEnd) {
                if (isInstance(target, Uint8Array) && (target = Buffer.from(target, target.offset, target.byteLength)),
                !Buffer.isBuffer(target))
                    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
                if (void 0 === start && (start = 0),
                void 0 === end && (end = target ? target.length : 0),
                void 0 === thisStart && (thisStart = 0),
                void 0 === thisEnd && (thisEnd = this.length),
                start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length)
                    throw new RangeError("out of range index");
                if (thisStart >= thisEnd && start >= end)
                    return 0;
                if (thisStart >= thisEnd)
                    return -1;
                if (start >= end)
                    return 1;
                if (this === target)
                    return 0;
                let x = (thisEnd >>>= 0) - (thisStart >>>= 0)
                  , y = (end >>>= 0) - (start >>>= 0);
                const len = Math.min(x, y)
                  , thisCopy = this.slice(thisStart, thisEnd)
                  , targetCopy = target.slice(start, end);
                for (let i = 0; i < len; ++i)
                    if (thisCopy[i] !== targetCopy[i]) {
                        x = thisCopy[i],
                        y = targetCopy[i];
                        break
                    }
                return x < y ? -1 : y < x ? 1 : 0
            }
            ,
            Buffer.prototype.includes = function(val, byteOffset, encoding) {
                return -1 !== this.indexOf(val, byteOffset, encoding)
            }
            ,
            Buffer.prototype.indexOf = function(val, byteOffset, encoding) {
                return bidirectionalIndexOf(this, val, byteOffset, encoding, !0)
            }
            ,
            Buffer.prototype.lastIndexOf = function(val, byteOffset, encoding) {
                return bidirectionalIndexOf(this, val, byteOffset, encoding, !1)
            }
            ,
            Buffer.prototype.write = function(string, offset, length, encoding) {
                if (void 0 === offset)
                    encoding = "utf8",
                    length = this.length,
                    offset = 0;
                else if (void 0 === length && "string" == typeof offset)
                    encoding = offset,
                    length = this.length,
                    offset = 0;
                else {
                    if (!isFinite(offset))
                        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                    offset >>>= 0,
                    isFinite(length) ? (length >>>= 0,
                    void 0 === encoding && (encoding = "utf8")) : (encoding = length,
                    length = void 0)
                }
                const remaining = this.length - offset;
                if ((void 0 === length || length > remaining) && (length = remaining),
                string.length > 0 && (length < 0 || offset < 0) || offset > this.length)
                    throw new RangeError("Attempt to write outside buffer bounds");
                encoding || (encoding = "utf8");
                let loweredCase = !1;
                for (; ; )
                    switch (encoding) {
                    case "hex":
                        return hexWrite(this, string, offset, length);
                    case "utf8":
                    case "utf-8":
                        return utf8Write(this, string, offset, length);
                    case "ascii":
                    case "latin1":
                    case "binary":
                        return asciiWrite(this, string, offset, length);
                    case "base64":
                        return base64Write(this, string, offset, length);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return ucs2Write(this, string, offset, length);
                    default:
                        if (loweredCase)
                            throw new TypeError("Unknown encoding: " + encoding);
                        encoding = ("" + encoding).toLowerCase(),
                        loweredCase = !0
                    }
            }
            ,
            Buffer.prototype.toJSON = function() {
                return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0)
                }
            }
            ;
            const MAX_ARGUMENTS_LENGTH = 4096;
            function asciiSlice(buf, start, end) {
                let ret = "";
                end = Math.min(buf.length, end);
                for (let i = start; i < end; ++i)
                    ret += String.fromCharCode(127 & buf[i]);
                return ret
            }
            function latin1Slice(buf, start, end) {
                let ret = "";
                end = Math.min(buf.length, end);
                for (let i = start; i < end; ++i)
                    ret += String.fromCharCode(buf[i]);
                return ret
            }
            function hexSlice(buf, start, end) {
                const len = buf.length;
                (!start || start < 0) && (start = 0),
                (!end || end < 0 || end > len) && (end = len);
                let out = "";
                for (let i = start; i < end; ++i)
                    out += hexSliceLookupTable[buf[i]];
                return out
            }
            function utf16leSlice(buf, start, end) {
                const bytes = buf.slice(start, end);
                let res = "";
                for (let i = 0; i < bytes.length - 1; i += 2)
                    res += String.fromCharCode(bytes[i] + 256 * bytes[i + 1]);
                return res
            }
            function checkOffset(offset, ext, length) {
                if (offset % 1 != 0 || offset < 0)
                    throw new RangeError("offset is not uint");
                if (offset + ext > length)
                    throw new RangeError("Trying to access beyond buffer length")
            }
            function checkInt(buf, value, offset, ext, max, min) {
                if (!Buffer.isBuffer(buf))
                    throw new TypeError('"buffer" argument must be a Buffer instance');
                if (value > max || value < min)
                    throw new RangeError('"value" argument is out of bounds');
                if (offset + ext > buf.length)
                    throw new RangeError("Index out of range")
            }
            function wrtBigUInt64LE(buf, value, offset, min, max) {
                checkIntBI(value, min, max, buf, offset, 7);
                let lo = Number(value & BigInt(4294967295));
                buf[offset++] = lo,
                lo >>= 8,
                buf[offset++] = lo,
                lo >>= 8,
                buf[offset++] = lo,
                lo >>= 8,
                buf[offset++] = lo;
                let hi = Number(value >> BigInt(32) & BigInt(4294967295));
                return buf[offset++] = hi,
                hi >>= 8,
                buf[offset++] = hi,
                hi >>= 8,
                buf[offset++] = hi,
                hi >>= 8,
                buf[offset++] = hi,
                offset
            }
            function wrtBigUInt64BE(buf, value, offset, min, max) {
                checkIntBI(value, min, max, buf, offset, 7);
                let lo = Number(value & BigInt(4294967295));
                buf[offset + 7] = lo,
                lo >>= 8,
                buf[offset + 6] = lo,
                lo >>= 8,
                buf[offset + 5] = lo,
                lo >>= 8,
                buf[offset + 4] = lo;
                let hi = Number(value >> BigInt(32) & BigInt(4294967295));
                return buf[offset + 3] = hi,
                hi >>= 8,
                buf[offset + 2] = hi,
                hi >>= 8,
                buf[offset + 1] = hi,
                hi >>= 8,
                buf[offset] = hi,
                offset + 8
            }
            function checkIEEE754(buf, value, offset, ext, max, min) {
                if (offset + ext > buf.length)
                    throw new RangeError("Index out of range");
                if (offset < 0)
                    throw new RangeError("Index out of range")
            }
            function writeFloat(buf, value, offset, littleEndian, noAssert) {
                return value = +value,
                offset >>>= 0,
                noAssert || checkIEEE754(buf, 0, offset, 4),
                ieee754.write(buf, value, offset, littleEndian, 23, 4),
                offset + 4
            }
            function writeDouble(buf, value, offset, littleEndian, noAssert) {
                return value = +value,
                offset >>>= 0,
                noAssert || checkIEEE754(buf, 0, offset, 8),
                ieee754.write(buf, value, offset, littleEndian, 52, 8),
                offset + 8
            }
            Buffer.prototype.slice = function(start, end) {
                const len = this.length;
                (start = ~~start) < 0 ? (start += len) < 0 && (start = 0) : start > len && (start = len),
                (end = void 0 === end ? len : ~~end) < 0 ? (end += len) < 0 && (end = 0) : end > len && (end = len),
                end < start && (end = start);
                const newBuf = this.subarray(start, end);
                return Object.setPrototypeOf(newBuf, Buffer.prototype),
                newBuf
            }
            ,
            Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function(offset, byteLength, noAssert) {
                offset >>>= 0,
                byteLength >>>= 0,
                noAssert || checkOffset(offset, byteLength, this.length);
                let val = this[offset]
                  , mul = 1
                  , i = 0;
                for (; ++i < byteLength && (mul *= 256); )
                    val += this[offset + i] * mul;
                return val
            }
            ,
            Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function(offset, byteLength, noAssert) {
                offset >>>= 0,
                byteLength >>>= 0,
                noAssert || checkOffset(offset, byteLength, this.length);
                let val = this[offset + --byteLength]
                  , mul = 1;
                for (; byteLength > 0 && (mul *= 256); )
                    val += this[offset + --byteLength] * mul;
                return val
            }
            ,
            Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function(offset, noAssert) {
                return offset >>>= 0,
                noAssert || checkOffset(offset, 1, this.length),
                this[offset]
            }
            ,
            Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function(offset, noAssert) {
                return offset >>>= 0,
                noAssert || checkOffset(offset, 2, this.length),
                this[offset] | this[offset + 1] << 8
            }
            ,
            Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function(offset, noAssert) {
                return offset >>>= 0,
                noAssert || checkOffset(offset, 2, this.length),
                this[offset] << 8 | this[offset + 1]
            }
            ,
            Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function(offset, noAssert) {
                return offset >>>= 0,
                noAssert || checkOffset(offset, 4, this.length),
                (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + 16777216 * this[offset + 3]
            }
            ,
            Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function(offset, noAssert) {
                return offset >>>= 0,
                noAssert || checkOffset(offset, 4, this.length),
                16777216 * this[offset] + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3])
            }
            ,
            Buffer.prototype.readBigUInt64LE = defineBigIntMethod((function(offset) {
                validateNumber(offset >>>= 0, "offset");
                const first = this[offset]
                  , last = this[offset + 7];
                void 0 !== first && void 0 !== last || boundsError(offset, this.length - 8);
                const lo = first + 256 * this[++offset] + 65536 * this[++offset] + this[++offset] * 2 ** 24
                  , hi = this[++offset] + 256 * this[++offset] + 65536 * this[++offset] + last * 2 ** 24;
                return BigInt(lo) + (BigInt(hi) << BigInt(32))
            }
            )),
            Buffer.prototype.readBigUInt64BE = defineBigIntMethod((function(offset) {
                validateNumber(offset >>>= 0, "offset");
                const first = this[offset]
                  , last = this[offset + 7];
                void 0 !== first && void 0 !== last || boundsError(offset, this.length - 8);
                const hi = first * 2 ** 24 + 65536 * this[++offset] + 256 * this[++offset] + this[++offset]
                  , lo = this[++offset] * 2 ** 24 + 65536 * this[++offset] + 256 * this[++offset] + last;
                return (BigInt(hi) << BigInt(32)) + BigInt(lo)
            }
            )),
            Buffer.prototype.readIntLE = function(offset, byteLength, noAssert) {
                offset >>>= 0,
                byteLength >>>= 0,
                noAssert || checkOffset(offset, byteLength, this.length);
                let val = this[offset]
                  , mul = 1
                  , i = 0;
                for (; ++i < byteLength && (mul *= 256); )
                    val += this[offset + i] * mul;
                return mul *= 128,
                val >= mul && (val -= Math.pow(2, 8 * byteLength)),
                val
            }
            ,
            Buffer.prototype.readIntBE = function(offset, byteLength, noAssert) {
                offset >>>= 0,
                byteLength >>>= 0,
                noAssert || checkOffset(offset, byteLength, this.length);
                let i = byteLength
                  , mul = 1
                  , val = this[offset + --i];
                for (; i > 0 && (mul *= 256); )
                    val += this[offset + --i] * mul;
                return mul *= 128,
                val >= mul && (val -= Math.pow(2, 8 * byteLength)),
                val
            }
            ,
            Buffer.prototype.readInt8 = function(offset, noAssert) {
                return offset >>>= 0,
                noAssert || checkOffset(offset, 1, this.length),
                128 & this[offset] ? -1 * (255 - this[offset] + 1) : this[offset]
            }
            ,
            Buffer.prototype.readInt16LE = function(offset, noAssert) {
                offset >>>= 0,
                noAssert || checkOffset(offset, 2, this.length);
                const val = this[offset] | this[offset + 1] << 8;
                return 32768 & val ? 4294901760 | val : val
            }
            ,
            Buffer.prototype.readInt16BE = function(offset, noAssert) {
                offset >>>= 0,
                noAssert || checkOffset(offset, 2, this.length);
                const val = this[offset + 1] | this[offset] << 8;
                return 32768 & val ? 4294901760 | val : val
            }
            ,
            Buffer.prototype.readInt32LE = function(offset, noAssert) {
                return offset >>>= 0,
                noAssert || checkOffset(offset, 4, this.length),
                this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24
            }
            ,
            Buffer.prototype.readInt32BE = function(offset, noAssert) {
                return offset >>>= 0,
                noAssert || checkOffset(offset, 4, this.length),
                this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]
            }
            ,
            Buffer.prototype.readBigInt64LE = defineBigIntMethod((function(offset) {
                validateNumber(offset >>>= 0, "offset");
                const first = this[offset]
                  , last = this[offset + 7];
                void 0 !== first && void 0 !== last || boundsError(offset, this.length - 8);
                const val = this[offset + 4] + 256 * this[offset + 5] + 65536 * this[offset + 6] + (last << 24);
                return (BigInt(val) << BigInt(32)) + BigInt(first + 256 * this[++offset] + 65536 * this[++offset] + this[++offset] * 2 ** 24)
            }
            )),
            Buffer.prototype.readBigInt64BE = defineBigIntMethod((function(offset) {
                validateNumber(offset >>>= 0, "offset");
                const first = this[offset]
                  , last = this[offset + 7];
                void 0 !== first && void 0 !== last || boundsError(offset, this.length - 8);
                const val = (first << 24) + 65536 * this[++offset] + 256 * this[++offset] + this[++offset];
                return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + 65536 * this[++offset] + 256 * this[++offset] + last)
            }
            )),
            Buffer.prototype.readFloatLE = function(offset, noAssert) {
                return offset >>>= 0,
                noAssert || checkOffset(offset, 4, this.length),
                ieee754.read(this, offset, !0, 23, 4)
            }
            ,
            Buffer.prototype.readFloatBE = function(offset, noAssert) {
                return offset >>>= 0,
                noAssert || checkOffset(offset, 4, this.length),
                ieee754.read(this, offset, !1, 23, 4)
            }
            ,
            Buffer.prototype.readDoubleLE = function(offset, noAssert) {
                return offset >>>= 0,
                noAssert || checkOffset(offset, 8, this.length),
                ieee754.read(this, offset, !0, 52, 8)
            }
            ,
            Buffer.prototype.readDoubleBE = function(offset, noAssert) {
                return offset >>>= 0,
                noAssert || checkOffset(offset, 8, this.length),
                ieee754.read(this, offset, !1, 52, 8)
            }
            ,
            Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function(value, offset, byteLength, noAssert) {
                if (value = +value,
                offset >>>= 0,
                byteLength >>>= 0,
                !noAssert) {
                    checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength) - 1, 0)
                }
                let mul = 1
                  , i = 0;
                for (this[offset] = 255 & value; ++i < byteLength && (mul *= 256); )
                    this[offset + i] = value / mul & 255;
                return offset + byteLength
            }
            ,
            Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function(value, offset, byteLength, noAssert) {
                if (value = +value,
                offset >>>= 0,
                byteLength >>>= 0,
                !noAssert) {
                    checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength) - 1, 0)
                }
                let i = byteLength - 1
                  , mul = 1;
                for (this[offset + i] = 255 & value; --i >= 0 && (mul *= 256); )
                    this[offset + i] = value / mul & 255;
                return offset + byteLength
            }
            ,
            Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
                return value = +value,
                offset >>>= 0,
                noAssert || checkInt(this, value, offset, 1, 255, 0),
                this[offset] = 255 & value,
                offset + 1
            }
            ,
            Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
                return value = +value,
                offset >>>= 0,
                noAssert || checkInt(this, value, offset, 2, 65535, 0),
                this[offset] = 255 & value,
                this[offset + 1] = value >>> 8,
                offset + 2
            }
            ,
            Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
                return value = +value,
                offset >>>= 0,
                noAssert || checkInt(this, value, offset, 2, 65535, 0),
                this[offset] = value >>> 8,
                this[offset + 1] = 255 & value,
                offset + 2
            }
            ,
            Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
                return value = +value,
                offset >>>= 0,
                noAssert || checkInt(this, value, offset, 4, 4294967295, 0),
                this[offset + 3] = value >>> 24,
                this[offset + 2] = value >>> 16,
                this[offset + 1] = value >>> 8,
                this[offset] = 255 & value,
                offset + 4
            }
            ,
            Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
                return value = +value,
                offset >>>= 0,
                noAssert || checkInt(this, value, offset, 4, 4294967295, 0),
                this[offset] = value >>> 24,
                this[offset + 1] = value >>> 16,
                this[offset + 2] = value >>> 8,
                this[offset + 3] = 255 & value,
                offset + 4
            }
            ,
            Buffer.prototype.writeBigUInt64LE = defineBigIntMethod((function(value, offset=0) {
                return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"))
            }
            )),
            Buffer.prototype.writeBigUInt64BE = defineBigIntMethod((function(value, offset=0) {
                return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"))
            }
            )),
            Buffer.prototype.writeIntLE = function(value, offset, byteLength, noAssert) {
                if (value = +value,
                offset >>>= 0,
                !noAssert) {
                    const limit = Math.pow(2, 8 * byteLength - 1);
                    checkInt(this, value, offset, byteLength, limit - 1, -limit)
                }
                let i = 0
                  , mul = 1
                  , sub = 0;
                for (this[offset] = 255 & value; ++i < byteLength && (mul *= 256); )
                    value < 0 && 0 === sub && 0 !== this[offset + i - 1] && (sub = 1),
                    this[offset + i] = (value / mul >> 0) - sub & 255;
                return offset + byteLength
            }
            ,
            Buffer.prototype.writeIntBE = function(value, offset, byteLength, noAssert) {
                if (value = +value,
                offset >>>= 0,
                !noAssert) {
                    const limit = Math.pow(2, 8 * byteLength - 1);
                    checkInt(this, value, offset, byteLength, limit - 1, -limit)
                }
                let i = byteLength - 1
                  , mul = 1
                  , sub = 0;
                for (this[offset + i] = 255 & value; --i >= 0 && (mul *= 256); )
                    value < 0 && 0 === sub && 0 !== this[offset + i + 1] && (sub = 1),
                    this[offset + i] = (value / mul >> 0) - sub & 255;
                return offset + byteLength
            }
            ,
            Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
                return value = +value,
                offset >>>= 0,
                noAssert || checkInt(this, value, offset, 1, 127, -128),
                value < 0 && (value = 255 + value + 1),
                this[offset] = 255 & value,
                offset + 1
            }
            ,
            Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
                return value = +value,
                offset >>>= 0,
                noAssert || checkInt(this, value, offset, 2, 32767, -32768),
                this[offset] = 255 & value,
                this[offset + 1] = value >>> 8,
                offset + 2
            }
            ,
            Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
                return value = +value,
                offset >>>= 0,
                noAssert || checkInt(this, value, offset, 2, 32767, -32768),
                this[offset] = value >>> 8,
                this[offset + 1] = 255 & value,
                offset + 2
            }
            ,
            Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
                return value = +value,
                offset >>>= 0,
                noAssert || checkInt(this, value, offset, 4, 2147483647, -2147483648),
                this[offset] = 255 & value,
                this[offset + 1] = value >>> 8,
                this[offset + 2] = value >>> 16,
                this[offset + 3] = value >>> 24,
                offset + 4
            }
            ,
            Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
                return value = +value,
                offset >>>= 0,
                noAssert || checkInt(this, value, offset, 4, 2147483647, -2147483648),
                value < 0 && (value = 4294967295 + value + 1),
                this[offset] = value >>> 24,
                this[offset + 1] = value >>> 16,
                this[offset + 2] = value >>> 8,
                this[offset + 3] = 255 & value,
                offset + 4
            }
            ,
            Buffer.prototype.writeBigInt64LE = defineBigIntMethod((function(value, offset=0) {
                return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
            }
            )),
            Buffer.prototype.writeBigInt64BE = defineBigIntMethod((function(value, offset=0) {
                return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
            }
            )),
            Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
                return writeFloat(this, value, offset, !0, noAssert)
            }
            ,
            Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
                return writeFloat(this, value, offset, !1, noAssert)
            }
            ,
            Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
                return writeDouble(this, value, offset, !0, noAssert)
            }
            ,
            Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
                return writeDouble(this, value, offset, !1, noAssert)
            }
            ,
            Buffer.prototype.copy = function(target, targetStart, start, end) {
                if (!Buffer.isBuffer(target))
                    throw new TypeError("argument should be a Buffer");
                if (start || (start = 0),
                end || 0 === end || (end = this.length),
                targetStart >= target.length && (targetStart = target.length),
                targetStart || (targetStart = 0),
                end > 0 && end < start && (end = start),
                end === start)
                    return 0;
                if (0 === target.length || 0 === this.length)
                    return 0;
                if (targetStart < 0)
                    throw new RangeError("targetStart out of bounds");
                if (start < 0 || start >= this.length)
                    throw new RangeError("Index out of range");
                if (end < 0)
                    throw new RangeError("sourceEnd out of bounds");
                end > this.length && (end = this.length),
                target.length - targetStart < end - start && (end = target.length - targetStart + start);
                const len = end - start;
                return this === target && "function" == typeof Uint8Array.prototype.copyWithin ? this.copyWithin(targetStart, start, end) : Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart),
                len
            }
            ,
            Buffer.prototype.fill = function(val, start, end, encoding) {
                if ("string" == typeof val) {
                    if ("string" == typeof start ? (encoding = start,
                    start = 0,
                    end = this.length) : "string" == typeof end && (encoding = end,
                    end = this.length),
                    void 0 !== encoding && "string" != typeof encoding)
                        throw new TypeError("encoding must be a string");
                    if ("string" == typeof encoding && !Buffer.isEncoding(encoding))
                        throw new TypeError("Unknown encoding: " + encoding);
                    if (1 === val.length) {
                        const code = val.charCodeAt(0);
                        ("utf8" === encoding && code < 128 || "latin1" === encoding) && (val = code)
                    }
                } else
                    "number" == typeof val ? val &= 255 : "boolean" == typeof val && (val = Number(val));
                if (start < 0 || this.length < start || this.length < end)
                    throw new RangeError("Out of range index");
                if (end <= start)
                    return this;
                let i;
                if (start >>>= 0,
                end = void 0 === end ? this.length : end >>> 0,
                val || (val = 0),
                "number" == typeof val)
                    for (i = start; i < end; ++i)
                        this[i] = val;
                else {
                    const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding)
                      , len = bytes.length;
                    if (0 === len)
                        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
                    for (i = 0; i < end - start; ++i)
                        this[i + start] = bytes[i % len]
                }
                return this
            }
            ;
            const errors = {};
            function E(sym, getMessage, Base) {
                errors[sym] = class extends Base {
                    constructor() {
                        super(),
                        Object.defineProperty(this, "message", {
                            value: getMessage.apply(this, arguments),
                            writable: !0,
                            configurable: !0
                        }),
                        this.name = `${this.name} [${sym}]`,
                        this.stack,
                        delete this.name
                    }
                    get code() {
                        return sym
                    }
                    set code(value) {
                        Object.defineProperty(this, "code", {
                            configurable: !0,
                            enumerable: !0,
                            value,
                            writable: !0
                        })
                    }
                    toString() {
                        return `${this.name} [${sym}]: ${this.message}`
                    }
                }
            }
            function addNumericalSeparator(val) {
                let res = ""
                  , i = val.length;
                const start = "-" === val[0] ? 1 : 0;
                for (; i >= start + 4; i -= 3)
                    res = `_${val.slice(i - 3, i)}${res}`;
                return `${val.slice(0, i)}${res}`
            }
            function checkIntBI(value, min, max, buf, offset, byteLength) {
                if (value > max || value < min) {
                    const n = "bigint" == typeof min ? "n" : "";
                    let range;
                    throw range = byteLength > 3 ? 0 === min || min === BigInt(0) ? `>= 0${n} and < 2${n} ** ${8 * (byteLength + 1)}${n}` : `>= -(2${n} ** ${8 * (byteLength + 1) - 1}${n}) and < 2 ** ${8 * (byteLength + 1) - 1}${n}` : `>= ${min}${n} and <= ${max}${n}`,
                    new errors.ERR_OUT_OF_RANGE("value",range,value)
                }
                !function(buf, offset, byteLength) {
                    validateNumber(offset, "offset"),
                    void 0 !== buf[offset] && void 0 !== buf[offset + byteLength] || boundsError(offset, buf.length - (byteLength + 1))
                }(buf, offset, byteLength)
            }
            function validateNumber(value, name) {
                if ("number" != typeof value)
                    throw new errors.ERR_INVALID_ARG_TYPE(name,"number",value)
            }
            function boundsError(value, length, type) {
                if (Math.floor(value) !== value)
                    throw validateNumber(value, type),
                    new errors.ERR_OUT_OF_RANGE(type || "offset","an integer",value);
                if (length < 0)
                    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS;
                throw new errors.ERR_OUT_OF_RANGE(type || "offset",`>= ${type ? 1 : 0} and <= ${length}`,value)
            }
            E("ERR_BUFFER_OUT_OF_BOUNDS", (function(name) {
                return name ? `${name} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
            }
            ), RangeError),
            E("ERR_INVALID_ARG_TYPE", (function(name, actual) {
                return `The "${name}" argument must be of type number. Received type ${typeof actual}`
            }
            ), TypeError),
            E("ERR_OUT_OF_RANGE", (function(str, range, input) {
                let msg = `The value of "${str}" is out of range.`
                  , received = input;
                return Number.isInteger(input) && Math.abs(input) > 2 ** 32 ? received = addNumericalSeparator(String(input)) : "bigint" == typeof input && (received = String(input),
                (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) && (received = addNumericalSeparator(received)),
                received += "n"),
                msg += ` It must be ${range}. Received ${received}`,
                msg
            }
            ), RangeError);
            const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
            function utf8ToBytes(string, units) {
                let codePoint;
                units = units || 1 / 0;
                const length = string.length;
                let leadSurrogate = null;
                const bytes = [];
                for (let i = 0; i < length; ++i) {
                    if (codePoint = string.charCodeAt(i),
                    codePoint > 55295 && codePoint < 57344) {
                        if (!leadSurrogate) {
                            if (codePoint > 56319) {
                                (units -= 3) > -1 && bytes.push(239, 191, 189);
                                continue
                            }
                            if (i + 1 === length) {
                                (units -= 3) > -1 && bytes.push(239, 191, 189);
                                continue
                            }
                            leadSurrogate = codePoint;
                            continue
                        }
                        if (codePoint < 56320) {
                            (units -= 3) > -1 && bytes.push(239, 191, 189),
                            leadSurrogate = codePoint;
                            continue
                        }
                        codePoint = 65536 + (leadSurrogate - 55296 << 10 | codePoint - 56320)
                    } else
                        leadSurrogate && (units -= 3) > -1 && bytes.push(239, 191, 189);
                    if (leadSurrogate = null,
                    codePoint < 128) {
                        if ((units -= 1) < 0)
                            break;
                        bytes.push(codePoint)
                    } else if (codePoint < 2048) {
                        if ((units -= 2) < 0)
                            break;
                        bytes.push(codePoint >> 6 | 192, 63 & codePoint | 128)
                    } else if (codePoint < 65536) {
                        if ((units -= 3) < 0)
                            break;
                        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, 63 & codePoint | 128)
                    } else {
                        if (!(codePoint < 1114112))
                            throw new Error("Invalid code point");
                        if ((units -= 4) < 0)
                            break;
                        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, 63 & codePoint | 128)
                    }
                }
                return bytes
            }
            function base64ToBytes(str) {
                return base64.toByteArray(function(str) {
                    if ((str = (str = str.split("=")[0]).trim().replace(INVALID_BASE64_RE, "")).length < 2)
                        return "";
                    for (; str.length % 4 != 0; )
                        str += "=";
                    return str
                }(str))
            }
            function blitBuffer(src, dst, offset, length) {
                let i;
                for (i = 0; i < length && !(i + offset >= dst.length || i >= src.length); ++i)
                    dst[i + offset] = src[i];
                return i
            }
            function isInstance(obj, type) {
                return obj instanceof type || null != obj && null != obj.constructor && null != obj.constructor.name && obj.constructor.name === type.name
            }
            function numberIsNaN(obj) {
                return obj != obj
            }
            const hexSliceLookupTable = function() {
                const table = new Array(256);
                for (let i = 0; i < 16; ++i) {
                    const i16 = 16 * i;
                    for (let j = 0; j < 16; ++j)
                        table[i16 + j] = "0123456789abcdef"[i] + "0123456789abcdef"[j]
                }
                return table
            }();
            function defineBigIntMethod(fn) {
                return "undefined" == typeof BigInt ? BufferBigIntNotDefined : fn
            }
            function BufferBigIntNotDefined() {
                throw new Error("BigInt not supported")
            }
        }
        ,
        86266: (__unused_webpack_module,exports,__webpack_require__)=>{
            "use strict";
            var elliptic = exports;
            elliptic.version = __webpack_require__(18597).i8,
            elliptic.utils = __webpack_require__(80953),
            elliptic.rand = __webpack_require__(29931),
            elliptic.curve = __webpack_require__(88254),
            elliptic.curves = __webpack_require__(45427),
            elliptic.ec = __webpack_require__(57954),
            elliptic.eddsa = __webpack_require__(65980)
        }
        ,
        4918: (module,__unused_webpack_exports,__webpack_require__)=>{
            "use strict";
            var BN = __webpack_require__(13550)
              , utils = __webpack_require__(80953)
              , getNAF = utils.getNAF
              , getJSF = utils.getJSF
              , assert = utils.assert;
            function BaseCurve(type, conf) {
                this.type = type,
                this.p = new BN(conf.p,16),
                this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p),
                this.zero = new BN(0).toRed(this.red),
                this.one = new BN(1).toRed(this.red),
                this.two = new BN(2).toRed(this.red),
                this.n = conf.n && new BN(conf.n,16),
                this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed),
                this._wnafT1 = new Array(4),
                this._wnafT2 = new Array(4),
                this._wnafT3 = new Array(4),
                this._wnafT4 = new Array(4),
                this._bitLength = this.n ? this.n.bitLength() : 0;
                var adjustCount = this.n && this.p.div(this.n);
                !adjustCount || adjustCount.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0,
                this.redN = this.n.toRed(this.red))
            }
            function BasePoint(curve, type) {
                this.curve = curve,
                this.type = type,
                this.precomputed = null
            }
            module.exports = BaseCurve,
            BaseCurve.prototype.point = function() {
                throw new Error("Not implemented")
            }
            ,
            BaseCurve.prototype.validate = function() {
                throw new Error("Not implemented")
            }
            ,
            BaseCurve.prototype._fixedNafMul = function(p, k) {
                assert(p.precomputed);
                var doubles = p._getDoubles()
                  , naf = getNAF(k, 1, this._bitLength)
                  , I = (1 << doubles.step + 1) - (doubles.step % 2 == 0 ? 2 : 1);
                I /= 3;
                var j, nafW, repr = [];
                for (j = 0; j < naf.length; j += doubles.step) {
                    nafW = 0;
                    for (var l = j + doubles.step - 1; l >= j; l--)
                        nafW = (nafW << 1) + naf[l];
                    repr.push(nafW)
                }
                for (var a = this.jpoint(null, null, null), b = this.jpoint(null, null, null), i = I; i > 0; i--) {
                    for (j = 0; j < repr.length; j++)
                        (nafW = repr[j]) === i ? b = b.mixedAdd(doubles.points[j]) : nafW === -i && (b = b.mixedAdd(doubles.points[j].neg()));
                    a = a.add(b)
                }
                return a.toP()
            }
            ,
            BaseCurve.prototype._wnafMul = function(p, k) {
                var w = 4
                  , nafPoints = p._getNAFPoints(w);
                w = nafPoints.wnd;
                for (var wnd = nafPoints.points, naf = getNAF(k, w, this._bitLength), acc = this.jpoint(null, null, null), i = naf.length - 1; i >= 0; i--) {
                    for (var l = 0; i >= 0 && 0 === naf[i]; i--)
                        l++;
                    if (i >= 0 && l++,
                    acc = acc.dblp(l),
                    i < 0)
                        break;
                    var z = naf[i];
                    assert(0 !== z),
                    acc = "affine" === p.type ? z > 0 ? acc.mixedAdd(wnd[z - 1 >> 1]) : acc.mixedAdd(wnd[-z - 1 >> 1].neg()) : z > 0 ? acc.add(wnd[z - 1 >> 1]) : acc.add(wnd[-z - 1 >> 1].neg())
                }
                return "affine" === p.type ? acc.toP() : acc
            }
            ,
            BaseCurve.prototype._wnafMulAdd = function(defW, points, coeffs, len, jacobianResult) {
                var i, j, p, wndWidth = this._wnafT1, wnd = this._wnafT2, naf = this._wnafT3, max = 0;
                for (i = 0; i < len; i++) {
                    var nafPoints = (p = points[i])._getNAFPoints(defW);
                    wndWidth[i] = nafPoints.wnd,
                    wnd[i] = nafPoints.points
                }
                for (i = len - 1; i >= 1; i -= 2) {
                    var a = i - 1
                      , b = i;
                    if (1 === wndWidth[a] && 1 === wndWidth[b]) {
                        var comb = [points[a], null, null, points[b]];
                        0 === points[a].y.cmp(points[b].y) ? (comb[1] = points[a].add(points[b]),
                        comb[2] = points[a].toJ().mixedAdd(points[b].neg())) : 0 === points[a].y.cmp(points[b].y.redNeg()) ? (comb[1] = points[a].toJ().mixedAdd(points[b]),
                        comb[2] = points[a].add(points[b].neg())) : (comb[1] = points[a].toJ().mixedAdd(points[b]),
                        comb[2] = points[a].toJ().mixedAdd(points[b].neg()));
                        var index = [-3, -1, -5, -7, 0, 7, 5, 1, 3]
                          , jsf = getJSF(coeffs[a], coeffs[b]);
                        for (max = Math.max(jsf[0].length, max),
                        naf[a] = new Array(max),
                        naf[b] = new Array(max),
                        j = 0; j < max; j++) {
                            var ja = 0 | jsf[0][j]
                              , jb = 0 | jsf[1][j];
                            naf[a][j] = index[3 * (ja + 1) + (jb + 1)],
                            naf[b][j] = 0,
                            wnd[a] = comb
                        }
                    } else
                        naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength),
                        naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength),
                        max = Math.max(naf[a].length, max),
                        max = Math.max(naf[b].length, max)
                }
                var acc = this.jpoint(null, null, null)
                  , tmp = this._wnafT4;
                for (i = max; i >= 0; i--) {
                    for (var k = 0; i >= 0; ) {
                        var zero = !0;
                        for (j = 0; j < len; j++)
                            tmp[j] = 0 | naf[j][i],
                            0 !== tmp[j] && (zero = !1);
                        if (!zero)
                            break;
                        k++,
                        i--
                    }
                    if (i >= 0 && k++,
                    acc = acc.dblp(k),
                    i < 0)
                        break;
                    for (j = 0; j < len; j++) {
                        var z = tmp[j];
                        0 !== z && (z > 0 ? p = wnd[j][z - 1 >> 1] : z < 0 && (p = wnd[j][-z - 1 >> 1].neg()),
                        acc = "affine" === p.type ? acc.mixedAdd(p) : acc.add(p))
                    }
                }
                for (i = 0; i < len; i++)
                    wnd[i] = null;
                return jacobianResult ? acc : acc.toP()
            }
            ,
            BaseCurve.BasePoint = BasePoint,
            BasePoint.prototype.eq = function() {
                throw new Error("Not implemented")
            }
            ,
            BasePoint.prototype.validate = function() {
                return this.curve.validate(this)
            }
            ,
            BaseCurve.prototype.decodePoint = function(bytes, enc) {
                bytes = utils.toArray(bytes, enc);
                var len = this.p.byteLength();
                if ((4 === bytes[0] || 6 === bytes[0] || 7 === bytes[0]) && bytes.length - 1 == 2 * len)
                    return 6 === bytes[0] ? assert(bytes[bytes.length - 1] % 2 == 0) : 7 === bytes[0] && assert(bytes[bytes.length - 1] % 2 == 1),
                    this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
                if ((2 === bytes[0] || 3 === bytes[0]) && bytes.length - 1 === len)
                    return this.pointFromX(bytes.slice(1, 1 + len), 3 === bytes[0]);
                throw new Error("Unknown point format")
            }
            ,
            BasePoint.prototype.encodeCompressed = function(enc) {
                return this.encode(enc, !0)
            }
            ,
            BasePoint.prototype._encode = function(compact) {
                var len = this.curve.p.byteLength()
                  , x = this.getX().toArray("be", len);
                return compact ? [this.getY().isEven() ? 2 : 3].concat(x) : [4].concat(x, this.getY().toArray("be", len))
            }
            ,
            BasePoint.prototype.encode = function(enc, compact) {
                return utils.encode(this._encode(compact), enc)
            }
            ,
            BasePoint.prototype.precompute = function(power) {
                if (this.precomputed)
                    return this;
                var precomputed = {
                    doubles: null,
                    naf: null,
                    beta: null
                };
                return precomputed.naf = this._getNAFPoints(8),
                precomputed.doubles = this._getDoubles(4, power),
                precomputed.beta = this._getBeta(),
                this.precomputed = precomputed,
                this
            }
            ,
            BasePoint.prototype._hasDoubles = function(k) {
                if (!this.precomputed)
                    return !1;
                var doubles = this.precomputed.doubles;
                return !!doubles && doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step)
            }
            ,
            BasePoint.prototype._getDoubles = function(step, power) {
                if (this.precomputed && this.precomputed.doubles)
                    return this.precomputed.doubles;
                for (var doubles = [this], acc = this, i = 0; i < power; i += step) {
                    for (var j = 0; j < step; j++)
                        acc = acc.dbl();
                    doubles.push(acc)
                }
                return {
                    step,
                    points: doubles
                }
            }
            ,
            BasePoint.prototype._getNAFPoints = function(wnd) {
                if (this.precomputed && this.precomputed.naf)
                    return this.precomputed.naf;
                for (var res = [this], max = (1 << wnd) - 1, dbl = 1 === max ? null : this.dbl(), i = 1; i < max; i++)
                    res[i] = res[i - 1].add(dbl);
                return {
                    wnd,
                    points: res
                }
            }
            ,
            BasePoint.prototype._getBeta = function() {
                return null
            }
            ,
            BasePoint.prototype.dblp = function(k) {
                for (var r = this, i = 0; i < k; i++)
                    r = r.dbl();
                return r
            }
        }
        ,
        31138: (module,__unused_webpack_exports,__webpack_require__)=>{
            "use strict";
            var utils = __webpack_require__(80953)
              , BN = __webpack_require__(13550)
              , inherits = __webpack_require__(35717)
              , Base = __webpack_require__(4918)
              , assert = utils.assert;
            function EdwardsCurve(conf) {
                this.twisted = 1 != (0 | conf.a),
                this.mOneA = this.twisted && -1 == (0 | conf.a),
                this.extended = this.mOneA,
                Base.call(this, "edwards", conf),
                this.a = new BN(conf.a,16).umod(this.red.m),
                this.a = this.a.toRed(this.red),
                this.c = new BN(conf.c,16).toRed(this.red),
                this.c2 = this.c.redSqr(),
                this.d = new BN(conf.d,16).toRed(this.red),
                this.dd = this.d.redAdd(this.d),
                assert(!this.twisted || 0 === this.c.fromRed().cmpn(1)),
                this.oneC = 1 == (0 | conf.c)
            }
            function Point(curve, x, y, z, t) {
                Base.BasePoint.call(this, curve, "projective"),
                null === x && null === y && null === z ? (this.x = this.curve.zero,
                this.y = this.curve.one,
                this.z = this.curve.one,
                this.t = this.curve.zero,
                this.zOne = !0) : (this.x = new BN(x,16),
                this.y = new BN(y,16),
                this.z = z ? new BN(z,16) : this.curve.one,
                this.t = t && new BN(t,16),
                this.x.red || (this.x = this.x.toRed(this.curve.red)),
                this.y.red || (this.y = this.y.toRed(this.curve.red)),
                this.z.red || (this.z = this.z.toRed(this.curve.red)),
                this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)),
                this.zOne = this.z === this.curve.one,
                this.curve.extended && !this.t && (this.t = this.x.redMul(this.y),
                this.zOne || (this.t = this.t.redMul(this.z.redInvm()))))
            }
            inherits(EdwardsCurve, Base),
            module.exports = EdwardsCurve,
            EdwardsCurve.prototype._mulA = function(num) {
                return this.mOneA ? num.redNeg() : this.a.redMul(num)
            }
            ,
            EdwardsCurve.prototype._mulC = function(num) {
                return this.oneC ? num : this.c.redMul(num)
            }
            ,
            EdwardsCurve.prototype.jpoint = function(x, y, z, t) {
                return this.point(x, y, z, t)
            }
            ,
            EdwardsCurve.prototype.pointFromX = function(x, odd) {
                (x = new BN(x,16)).red || (x = x.toRed(this.red));
                var x2 = x.redSqr()
                  , rhs = this.c2.redSub(this.a.redMul(x2))
                  , lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2))
                  , y2 = rhs.redMul(lhs.redInvm())
                  , y = y2.redSqrt();
                if (0 !== y.redSqr().redSub(y2).cmp(this.zero))
                    throw new Error("invalid point");
                var isOdd = y.fromRed().isOdd();
                return (odd && !isOdd || !odd && isOdd) && (y = y.redNeg()),
                this.point(x, y)
            }
            ,
            EdwardsCurve.prototype.pointFromY = function(y, odd) {
                (y = new BN(y,16)).red || (y = y.toRed(this.red));
                var y2 = y.redSqr()
                  , lhs = y2.redSub(this.c2)
                  , rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a)
                  , x2 = lhs.redMul(rhs.redInvm());
                if (0 === x2.cmp(this.zero)) {
                    if (odd)
                        throw new Error("invalid point");
                    return this.point(this.zero, y)
                }
                var x = x2.redSqrt();
                if (0 !== x.redSqr().redSub(x2).cmp(this.zero))
                    throw new Error("invalid point");
                return x.fromRed().isOdd() !== odd && (x = x.redNeg()),
                this.point(x, y)
            }
            ,
            EdwardsCurve.prototype.validate = function(point) {
                if (point.isInfinity())
                    return !0;
                point.normalize();
                var x2 = point.x.redSqr()
                  , y2 = point.y.redSqr()
                  , lhs = x2.redMul(this.a).redAdd(y2)
                  , rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
                return 0 === lhs.cmp(rhs)
            }
            ,
            inherits(Point, Base.BasePoint),
            EdwardsCurve.prototype.pointFromJSON = function(obj) {
                return Point.fromJSON(this, obj)
            }
            ,
            EdwardsCurve.prototype.point = function(x, y, z, t) {
                return new Point(this,x,y,z,t)
            }
            ,
            Point.fromJSON = function(curve, obj) {
                return new Point(curve,obj[0],obj[1],obj[2])
            }
            ,
            Point.prototype.inspect = function() {
                return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">"
            }
            ,
            Point.prototype.isInfinity = function() {
                return 0 === this.x.cmpn(0) && (0 === this.y.cmp(this.z) || this.zOne && 0 === this.y.cmp(this.curve.c))
            }
            ,
            Point.prototype._extDbl = function() {
                var a = this.x.redSqr()
                  , b = this.y.redSqr()
                  , c = this.z.redSqr();
                c = c.redIAdd(c);
                var d = this.curve._mulA(a)
                  , e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b)
                  , g = d.redAdd(b)
                  , f = g.redSub(c)
                  , h = d.redSub(b)
                  , nx = e.redMul(f)
                  , ny = g.redMul(h)
                  , nt = e.redMul(h)
                  , nz = f.redMul(g);
                return this.curve.point(nx, ny, nz, nt)
            }
            ,
            Point.prototype._projDbl = function() {
                var nx, ny, nz, e, h, j, b = this.x.redAdd(this.y).redSqr(), c = this.x.redSqr(), d = this.y.redSqr();
                if (this.curve.twisted) {
                    var f = (e = this.curve._mulA(c)).redAdd(d);
                    this.zOne ? (nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two)),
                    ny = f.redMul(e.redSub(d)),
                    nz = f.redSqr().redSub(f).redSub(f)) : (h = this.z.redSqr(),
                    j = f.redSub(h).redISub(h),
                    nx = b.redSub(c).redISub(d).redMul(j),
                    ny = f.redMul(e.redSub(d)),
                    nz = f.redMul(j))
                } else
                    e = c.redAdd(d),
                    h = this.curve._mulC(this.z).redSqr(),
                    j = e.redSub(h).redSub(h),
                    nx = this.curve._mulC(b.redISub(e)).redMul(j),
                    ny = this.curve._mulC(e).redMul(c.redISub(d)),
                    nz = e.redMul(j);
                return this.curve.point(nx, ny, nz)
            }
            ,
            Point.prototype.dbl = function() {
                return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl()
            }
            ,
            Point.prototype._extAdd = function(p) {
                var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x))
                  , b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x))
                  , c = this.t.redMul(this.curve.dd).redMul(p.t)
                  , d = this.z.redMul(p.z.redAdd(p.z))
                  , e = b.redSub(a)
                  , f = d.redSub(c)
                  , g = d.redAdd(c)
                  , h = b.redAdd(a)
                  , nx = e.redMul(f)
                  , ny = g.redMul(h)
                  , nt = e.redMul(h)
                  , nz = f.redMul(g);
                return this.curve.point(nx, ny, nz, nt)
            }
            ,
            Point.prototype._projAdd = function(p) {
                var ny, nz, a = this.z.redMul(p.z), b = a.redSqr(), c = this.x.redMul(p.x), d = this.y.redMul(p.y), e = this.curve.d.redMul(c).redMul(d), f = b.redSub(e), g = b.redAdd(e), tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d), nx = a.redMul(f).redMul(tmp);
                return this.curve.twisted ? (ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c))),
                nz = f.redMul(g)) : (ny = a.redMul(g).redMul(d.redSub(c)),
                nz = this.curve._mulC(f).redMul(g)),
                this.curve.point(nx, ny, nz)
            }
            ,
            Point.prototype.add = function(p) {
                return this.isInfinity() ? p : p.isInfinity() ? this : this.curve.extended ? this._extAdd(p) : this._projAdd(p)
            }
            ,
            Point.prototype.mul = function(k) {
                return this._hasDoubles(k) ? this.curve._fixedNafMul(this, k) : this.curve._wnafMul(this, k)
            }
            ,
            Point.prototype.mulAdd = function(k1, p, k2) {
                return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, !1)
            }
            ,
            Point.prototype.jmulAdd = function(k1, p, k2) {
                return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, !0)
            }
            ,
            Point.prototype.normalize = function() {
                if (this.zOne)
                    return this;
                var zi = this.z.redInvm();
                return this.x = this.x.redMul(zi),
                this.y = this.y.redMul(zi),
                this.t && (this.t = this.t.redMul(zi)),
                this.z = this.curve.one,
                this.zOne = !0,
                this
            }
            ,
            Point.prototype.neg = function() {
                return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg())
            }
            ,
            Point.prototype.getX = function() {
                return this.normalize(),
                this.x.fromRed()
            }
            ,
            Point.prototype.getY = function() {
                return this.normalize(),
                this.y.fromRed()
            }
            ,
            Point.prototype.eq = function(other) {
                return this === other || 0 === this.getX().cmp(other.getX()) && 0 === this.getY().cmp(other.getY())
            }
            ,
            Point.prototype.eqXToP = function(x) {
                var rx = x.toRed(this.curve.red).redMul(this.z);
                if (0 === this.x.cmp(rx))
                    return !0;
                for (var xc = x.clone(), t = this.curve.redN.redMul(this.z); ; ) {
                    if (xc.iadd(this.curve.n),
                    xc.cmp(this.curve.p) >= 0)
                        return !1;
                    if (rx.redIAdd(t),
                    0 === this.x.cmp(rx))
                        return !0
                }
            }
            ,
            Point.prototype.toP = Point.prototype.normalize,
            Point.prototype.mixedAdd = Point.prototype.add
        }
        ,
        88254: (__unused_webpack_module,exports,__webpack_require__)=>{
            "use strict";
            var curve = exports;
            curve.base = __webpack_require__(4918),
            curve.short = __webpack_require__(6673),
            curve.mont = __webpack_require__(22881),
            curve.edwards = __webpack_require__(31138)
        }
        ,
        22881: (module,__unused_webpack_exports,__webpack_require__)=>{
            "use strict";
            var BN = __webpack_require__(13550)
              , inherits = __webpack_require__(35717)
              , Base = __webpack_require__(4918)
              , utils = __webpack_require__(80953);
            function MontCurve(conf) {
                Base.call(this, "mont", conf),
                this.a = new BN(conf.a,16).toRed(this.red),
                this.b = new BN(conf.b,16).toRed(this.red),
                this.i4 = new BN(4).toRed(this.red).redInvm(),
                this.two = new BN(2).toRed(this.red),
                this.a24 = this.i4.redMul(this.a.redAdd(this.two))
            }
            function Point(curve, x, z) {
                Base.BasePoint.call(this, curve, "projective"),
                null === x && null === z ? (this.x = this.curve.one,
                this.z = this.curve.zero) : (this.x = new BN(x,16),
                this.z = new BN(z,16),
                this.x.red || (this.x = this.x.toRed(this.curve.red)),
                this.z.red || (this.z = this.z.toRed(this.curve.red)))
            }
            inherits(MontCurve, Base),
            module.exports = MontCurve,
            MontCurve.prototype.validate = function(point) {
                var x = point.normalize().x
                  , x2 = x.redSqr()
                  , rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
                return 0 === rhs.redSqrt().redSqr().cmp(rhs)
            }
            ,
            inherits(Point, Base.BasePoint),
            MontCurve.prototype.decodePoint = function(bytes, enc) {
                return this.point(utils.toArray(bytes, enc), 1)
            }
            ,
            MontCurve.prototype.point = function(x, z) {
                return new Point(this,x,z)
            }
            ,
            MontCurve.prototype.pointFromJSON = function(obj) {
                return Point.fromJSON(this, obj)
            }
            ,
            Point.prototype.precompute = function() {}
            ,
            Point.prototype._encode = function() {
                return this.getX().toArray("be", this.curve.p.byteLength())
            }
            ,
            Point.fromJSON = function(curve, obj) {
                return new Point(curve,obj[0],obj[1] || curve.one)
            }
            ,
            Point.prototype.inspect = function() {
                return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">"
            }
            ,
            Point.prototype.isInfinity = function() {
                return 0 === this.z.cmpn(0)
            }
            ,
            Point.prototype.dbl = function() {
                var aa = this.x.redAdd(this.z).redSqr()
                  , bb = this.x.redSub(this.z).redSqr()
                  , c = aa.redSub(bb)
                  , nx = aa.redMul(bb)
                  , nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
                return this.curve.point(nx, nz)
            }
            ,
            Point.prototype.add = function() {
                throw new Error("Not supported on Montgomery curve")
            }
            ,
            Point.prototype.diffAdd = function(p, diff) {
                var a = this.x.redAdd(this.z)
                  , b = this.x.redSub(this.z)
                  , c = p.x.redAdd(p.z)
                  , da = p.x.redSub(p.z).redMul(a)
                  , cb = c.redMul(b)
                  , nx = diff.z.redMul(da.redAdd(cb).redSqr())
                  , nz = diff.x.redMul(da.redISub(cb).redSqr());
                return this.curve.point(nx, nz)
            }
            ,
            Point.prototype.mul = function(k) {
                for (var t = k.clone(), a = this, b = this.curve.point(null, null), bits = []; 0 !== t.cmpn(0); t.iushrn(1))
                    bits.push(t.andln(1));
                for (var i = bits.length - 1; i >= 0; i--)
                    0 === bits[i] ? (a = a.diffAdd(b, this),
                    b = b.dbl()) : (b = a.diffAdd(b, this),
                    a = a.dbl());
                return b
            }
            ,
            Point.prototype.mulAdd = function() {
                throw new Error("Not supported on Montgomery curve")
            }
            ,
            Point.prototype.jumlAdd = function() {
                throw new Error("Not supported on Montgomery curve")
            }
            ,
            Point.prototype.eq = function(other) {
                return 0 === this.getX().cmp(other.getX())
            }
            ,
            Point.prototype.normalize = function() {
                return this.x = this.x.redMul(this.z.redInvm()),
                this.z = this.curve.one,
                this
            }
            ,
            Point.prototype.getX = function() {
                return this.normalize(),
                this.x.fromRed()
            }
        }
        ,
        6673: (module,__unused_webpack_exports,__webpack_require__)=>{
            "use strict";
            var utils = __webpack_require__(80953)
              , BN = __webpack_require__(13550)
              , inherits = __webpack_require__(35717)
              , Base = __webpack_require__(4918)
              , assert = utils.assert;
            function ShortCurve(conf) {
                Base.call(this, "short", conf),
                this.a = new BN(conf.a,16).toRed(this.red),
                this.b = new BN(conf.b,16).toRed(this.red),
                this.tinv = this.two.redInvm(),
                this.zeroA = 0 === this.a.fromRed().cmpn(0),
                this.threeA = 0 === this.a.fromRed().sub(this.p).cmpn(-3),
                this.endo = this._getEndomorphism(conf),
                this._endoWnafT1 = new Array(4),
                this._endoWnafT2 = new Array(4)
            }
            function Point(curve, x, y, isRed) {
                Base.BasePoint.call(this, curve, "affine"),
                null === x && null === y ? (this.x = null,
                this.y = null,
                this.inf = !0) : (this.x = new BN(x,16),
                this.y = new BN(y,16),
                isRed && (this.x.forceRed(this.curve.red),
                this.y.forceRed(this.curve.red)),
                this.x.red || (this.x = this.x.toRed(this.curve.red)),
                this.y.red || (this.y = this.y.toRed(this.curve.red)),
                this.inf = !1)
            }
            function JPoint(curve, x, y, z) {
                Base.BasePoint.call(this, curve, "jacobian"),
                null === x && null === y && null === z ? (this.x = this.curve.one,
                this.y = this.curve.one,
                this.z = new BN(0)) : (this.x = new BN(x,16),
                this.y = new BN(y,16),
                this.z = new BN(z,16)),
                this.x.red || (this.x = this.x.toRed(this.curve.red)),
                this.y.red || (this.y = this.y.toRed(this.curve.red)),
                this.z.red || (this.z = this.z.toRed(this.curve.red)),
                this.zOne = this.z === this.curve.one
            }
            inherits(ShortCurve, Base),
            module.exports = ShortCurve,
            ShortCurve.prototype._getEndomorphism = function(conf) {
                if (this.zeroA && this.g && this.n && 1 === this.p.modn(3)) {
                    var beta, lambda;
                    if (conf.beta)
                        beta = new BN(conf.beta,16).toRed(this.red);
                    else {
                        var betas = this._getEndoRoots(this.p);
                        beta = (beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1]).toRed(this.red)
                    }
                    if (conf.lambda)
                        lambda = new BN(conf.lambda,16);
                    else {
                        var lambdas = this._getEndoRoots(this.n);
                        0 === this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) ? lambda = lambdas[0] : (lambda = lambdas[1],
                        assert(0 === this.g.mul(lambda).x.cmp(this.g.x.redMul(beta))))
                    }
                    return {
                        beta,
                        lambda,
                        basis: conf.basis ? conf.basis.map((function(vec) {
                            return {
                                a: new BN(vec.a,16),
                                b: new BN(vec.b,16)
                            }
                        }
                        )) : this._getEndoBasis(lambda)
                    }
                }
            }
            ,
            ShortCurve.prototype._getEndoRoots = function(num) {
                var red = num === this.p ? this.red : BN.mont(num)
                  , tinv = new BN(2).toRed(red).redInvm()
                  , ntinv = tinv.redNeg()
                  , s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
                return [ntinv.redAdd(s).fromRed(), ntinv.redSub(s).fromRed()]
            }
            ,
            ShortCurve.prototype._getEndoBasis = function(lambda) {
                for (var a0, b0, a1, b1, a2, b2, prevR, r, x, aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), u = lambda, v = this.n.clone(), x1 = new BN(1), y1 = new BN(0), x2 = new BN(0), y2 = new BN(1), i = 0; 0 !== u.cmpn(0); ) {
                    var q = v.div(u);
                    r = v.sub(q.mul(u)),
                    x = x2.sub(q.mul(x1));
                    var y = y2.sub(q.mul(y1));
                    if (!a1 && r.cmp(aprxSqrt) < 0)
                        a0 = prevR.neg(),
                        b0 = x1,
                        a1 = r.neg(),
                        b1 = x;
                    else if (a1 && 2 == ++i)
                        break;
                    prevR = r,
                    v = u,
                    u = r,
                    x2 = x1,
                    x1 = x,
                    y2 = y1,
                    y1 = y
                }
                a2 = r.neg(),
                b2 = x;
                var len1 = a1.sqr().add(b1.sqr());
                return a2.sqr().add(b2.sqr()).cmp(len1) >= 0 && (a2 = a0,
                b2 = b0),
                a1.negative && (a1 = a1.neg(),
                b1 = b1.neg()),
                a2.negative && (a2 = a2.neg(),
                b2 = b2.neg()),
                [{
                    a: a1,
                    b: b1
                }, {
                    a: a2,
                    b: b2
                }]
            }
            ,
            ShortCurve.prototype._endoSplit = function(k) {
                var basis = this.endo.basis
                  , v1 = basis[0]
                  , v2 = basis[1]
                  , c1 = v2.b.mul(k).divRound(this.n)
                  , c2 = v1.b.neg().mul(k).divRound(this.n)
                  , p1 = c1.mul(v1.a)
                  , p2 = c2.mul(v2.a)
                  , q1 = c1.mul(v1.b)
                  , q2 = c2.mul(v2.b);
                return {
                    k1: k.sub(p1).sub(p2),
                    k2: q1.add(q2).neg()
                }
            }
            ,
            ShortCurve.prototype.pointFromX = function(x, odd) {
                (x = new BN(x,16)).red || (x = x.toRed(this.red));
                var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b)
                  , y = y2.redSqrt();
                if (0 !== y.redSqr().redSub(y2).cmp(this.zero))
                    throw new Error("invalid point");
                var isOdd = y.fromRed().isOdd();
                return (odd && !isOdd || !odd && isOdd) && (y = y.redNeg()),
                this.point(x, y)
            }
            ,
            ShortCurve.prototype.validate = function(point) {
                if (point.inf)
                    return !0;
                var x = point.x
                  , y = point.y
                  , ax = this.a.redMul(x)
                  , rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
                return 0 === y.redSqr().redISub(rhs).cmpn(0)
            }
            ,
            ShortCurve.prototype._endoWnafMulAdd = function(points, coeffs, jacobianResult) {
                for (var npoints = this._endoWnafT1, ncoeffs = this._endoWnafT2, i = 0; i < points.length; i++) {
                    var split = this._endoSplit(coeffs[i])
                      , p = points[i]
                      , beta = p._getBeta();
                    split.k1.negative && (split.k1.ineg(),
                    p = p.neg(!0)),
                    split.k2.negative && (split.k2.ineg(),
                    beta = beta.neg(!0)),
                    npoints[2 * i] = p,
                    npoints[2 * i + 1] = beta,
                    ncoeffs[2 * i] = split.k1,
                    ncoeffs[2 * i + 1] = split.k2
                }
                for (var res = this._wnafMulAdd(1, npoints, ncoeffs, 2 * i, jacobianResult), j = 0; j < 2 * i; j++)
                    npoints[j] = null,
                    ncoeffs[j] = null;
                return res
            }
            ,
            inherits(Point, Base.BasePoint),
            ShortCurve.prototype.point = function(x, y, isRed) {
                return new Point(this,x,y,isRed)
            }
            ,
            ShortCurve.prototype.pointFromJSON = function(obj, red) {
                return Point.fromJSON(this, obj, red)
            }
            ,
            Point.prototype._getBeta = function() {
                if (this.curve.endo) {
                    var pre = this.precomputed;
                    if (pre && pre.beta)
                        return pre.beta;
                    var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
                    if (pre) {
                        var curve = this.curve
                          , endoMul = function(p) {
                            return curve.point(p.x.redMul(curve.endo.beta), p.y)
                        };
                        pre.beta = beta,
                        beta.precomputed = {
                            beta: null,
                            naf: pre.naf && {
                                wnd: pre.naf.wnd,
                                points: pre.naf.points.map(endoMul)
                            },
                            doubles: pre.doubles && {
                                step: pre.doubles.step,
                                points: pre.doubles.points.map(endoMul)
                            }
                        }
                    }
                    return beta
                }
            }
            ,
            Point.prototype.toJSON = function() {
                return this.precomputed ? [this.x, this.y, this.precomputed && {
                    doubles: this.precomputed.doubles && {
                        step: this.precomputed.doubles.step,
                        points: this.precomputed.doubles.points.slice(1)
                    },
                    naf: this.precomputed.naf && {
                        wnd: this.precomputed.naf.wnd,
                        points: this.precomputed.naf.points.slice(1)
                    }
                }] : [this.x, this.y]
            }
            ,
            Point.fromJSON = function(curve, obj, red) {
                "string" == typeof obj && (obj = JSON.parse(obj));
                var res = curve.point(obj[0], obj[1], red);
                if (!obj[2])
                    return res;
                function obj2point(obj) {
                    return curve.point(obj[0], obj[1], red)
                }
                var pre = obj[2];
                return res.precomputed = {
                    beta: null,
                    doubles: pre.doubles && {
                        step: pre.doubles.step,
                        points: [res].concat(pre.doubles.points.map(obj2point))
                    },
                    naf: pre.naf && {
                        wnd: pre.naf.wnd,
                        points: [res].concat(pre.naf.points.map(obj2point))
                    }
                },
                res
            }
            ,
            Point.prototype.inspect = function() {
                return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">"
            }
            ,
            Point.prototype.isInfinity = function() {
                return this.inf
            }
            ,
            Point.prototype.add = function(p) {
                if (this.inf)
                    return p;
                if (p.inf)
                    return this;
                if (this.eq(p))
                    return this.dbl();
                if (this.neg().eq(p))
                    return this.curve.point(null, null);
                if (0 === this.x.cmp(p.x))
                    return this.curve.point(null, null);
                var c = this.y.redSub(p.y);
                0 !== c.cmpn(0) && (c = c.redMul(this.x.redSub(p.x).redInvm()));
                var nx = c.redSqr().redISub(this.x).redISub(p.x)
                  , ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
                return this.curve.point(nx, ny)
            }
            ,
            Point.prototype.dbl = function() {
                if (this.inf)
                    return this;
                var ys1 = this.y.redAdd(this.y);
                if (0 === ys1.cmpn(0))
                    return this.curve.point(null, null);
                var a = this.curve.a
                  , x2 = this.x.redSqr()
                  , dyinv = ys1.redInvm()
                  , c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv)
                  , nx = c.redSqr().redISub(this.x.redAdd(this.x))
                  , ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
                return this.curve.point(nx, ny)
            }
            ,
            Point.prototype.getX = function() {
                return this.x.fromRed()
            }
            ,
            Point.prototype.getY = function() {
                return this.y.fromRed()
            }
            ,
            Point.prototype.mul = function(k) {
                return k = new BN(k,16),
                this.isInfinity() ? this : this._hasDoubles(k) ? this.curve._fixedNafMul(this, k) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [k]) : this.curve._wnafMul(this, k)
            }
            ,
            Point.prototype.mulAdd = function(k1, p2, k2) {
                var points = [this, p2]
                  , coeffs = [k1, k2];
                return this.curve.endo ? this.curve._endoWnafMulAdd(points, coeffs) : this.curve._wnafMulAdd(1, points, coeffs, 2)
            }
            ,
            Point.prototype.jmulAdd = function(k1, p2, k2) {
                var points = [this, p2]
                  , coeffs = [k1, k2];
                return this.curve.endo ? this.curve._endoWnafMulAdd(points, coeffs, !0) : this.curve._wnafMulAdd(1, points, coeffs, 2, !0)
            }
            ,
            Point.prototype.eq = function(p) {
                return this === p || this.inf === p.inf && (this.inf || 0 === this.x.cmp(p.x) && 0 === this.y.cmp(p.y))
            }
            ,
            Point.prototype.neg = function(_precompute) {
                if (this.inf)
                    return this;
                var res = this.curve.point(this.x, this.y.redNeg());
                if (_precompute && this.precomputed) {
                    var pre = this.precomputed
                      , negate = function(p) {
                        return p.neg()
                    };
                    res.precomputed = {
                        naf: pre.naf && {
                            wnd: pre.naf.wnd,
                            points: pre.naf.points.map(negate)
                        },
                        doubles: pre.doubles && {
                            step: pre.doubles.step,
                            points: pre.doubles.points.map(negate)
                        }
                    }
                }
                return res
            }
            ,
            Point.prototype.toJ = function() {
                return this.inf ? this.curve.jpoint(null, null, null) : this.curve.jpoint(this.x, this.y, this.curve.one)
            }
            ,
            inherits(JPoint, Base.BasePoint),
            ShortCurve.prototype.jpoint = function(x, y, z) {
                return new JPoint(this,x,y,z)
            }
            ,
            JPoint.prototype.toP = function() {
                if (this.isInfinity())
                    return this.curve.point(null, null);
                var zinv = this.z.redInvm()
                  , zinv2 = zinv.redSqr()
                  , ax = this.x.redMul(zinv2)
                  , ay = this.y.redMul(zinv2).redMul(zinv);
                return this.curve.point(ax, ay)
            }
            ,
            JPoint.prototype.neg = function() {
                return this.curve.jpoint(this.x, this.y.redNeg(), this.z)
            }
            ,
            JPoint.prototype.add = function(p) {
                if (this.isInfinity())
                    return p;
                if (p.isInfinity())
                    return this;
                var pz2 = p.z.redSqr()
                  , z2 = this.z.redSqr()
                  , u1 = this.x.redMul(pz2)
                  , u2 = p.x.redMul(z2)
                  , s1 = this.y.redMul(pz2.redMul(p.z))
                  , s2 = p.y.redMul(z2.redMul(this.z))
                  , h = u1.redSub(u2)
                  , r = s1.redSub(s2);
                if (0 === h.cmpn(0))
                    return 0 !== r.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl();
                var h2 = h.redSqr()
                  , h3 = h2.redMul(h)
                  , v = u1.redMul(h2)
                  , nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v)
                  , ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3))
                  , nz = this.z.redMul(p.z).redMul(h);
                return this.curve.jpoint(nx, ny, nz)
            }
            ,
            JPoint.prototype.mixedAdd = function(p) {
                if (this.isInfinity())
                    return p.toJ();
                if (p.isInfinity())
                    return this;
                var z2 = this.z.redSqr()
                  , u1 = this.x
                  , u2 = p.x.redMul(z2)
                  , s1 = this.y
                  , s2 = p.y.redMul(z2).redMul(this.z)
                  , h = u1.redSub(u2)
                  , r = s1.redSub(s2);
                if (0 === h.cmpn(0))
                    return 0 !== r.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl();
                var h2 = h.redSqr()
                  , h3 = h2.redMul(h)
                  , v = u1.redMul(h2)
                  , nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v)
                  , ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3))
                  , nz = this.z.redMul(h);
                return this.curve.jpoint(nx, ny, nz)
            }
            ,
            JPoint.prototype.dblp = function(pow) {
                if (0 === pow)
                    return this;
                if (this.isInfinity())
                    return this;
                if (!pow)
                    return this.dbl();
                var i;
                if (this.curve.zeroA || this.curve.threeA) {
                    var r = this;
                    for (i = 0; i < pow; i++)
                        r = r.dbl();
                    return r
                }
                var a = this.curve.a
                  , tinv = this.curve.tinv
                  , jx = this.x
                  , jy = this.y
                  , jz = this.z
                  , jz4 = jz.redSqr().redSqr()
                  , jyd = jy.redAdd(jy);
                for (i = 0; i < pow; i++) {
                    var jx2 = jx.redSqr()
                      , jyd2 = jyd.redSqr()
                      , jyd4 = jyd2.redSqr()
                      , c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4))
                      , t1 = jx.redMul(jyd2)
                      , nx = c.redSqr().redISub(t1.redAdd(t1))
                      , t2 = t1.redISub(nx)
                      , dny = c.redMul(t2);
                    dny = dny.redIAdd(dny).redISub(jyd4);
                    var nz = jyd.redMul(jz);
                    i + 1 < pow && (jz4 = jz4.redMul(jyd4)),
                    jx = nx,
                    jz = nz,
                    jyd = dny
                }
                return this.curve.jpoint(jx, jyd.redMul(tinv), jz)
            }
            ,
            JPoint.prototype.dbl = function() {
                return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl()
            }
            ,
            JPoint.prototype._zeroDbl = function() {
                var nx, ny, nz;
                if (this.zOne) {
                    var xx = this.x.redSqr()
                      , yy = this.y.redSqr()
                      , yyyy = yy.redSqr()
                      , s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
                    s = s.redIAdd(s);
                    var m = xx.redAdd(xx).redIAdd(xx)
                      , t = m.redSqr().redISub(s).redISub(s)
                      , yyyy8 = yyyy.redIAdd(yyyy);
                    yyyy8 = (yyyy8 = yyyy8.redIAdd(yyyy8)).redIAdd(yyyy8),
                    nx = t,
                    ny = m.redMul(s.redISub(t)).redISub(yyyy8),
                    nz = this.y.redAdd(this.y)
                } else {
                    var a = this.x.redSqr()
                      , b = this.y.redSqr()
                      , c = b.redSqr()
                      , d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
                    d = d.redIAdd(d);
                    var e = a.redAdd(a).redIAdd(a)
                      , f = e.redSqr()
                      , c8 = c.redIAdd(c);
                    c8 = (c8 = c8.redIAdd(c8)).redIAdd(c8),
                    nx = f.redISub(d).redISub(d),
                    ny = e.redMul(d.redISub(nx)).redISub(c8),
                    nz = (nz = this.y.redMul(this.z)).redIAdd(nz)
                }
                return this.curve.jpoint(nx, ny, nz)
            }
            ,
            JPoint.prototype._threeDbl = function() {
                var nx, ny, nz;
                if (this.zOne) {
                    var xx = this.x.redSqr()
                      , yy = this.y.redSqr()
                      , yyyy = yy.redSqr()
                      , s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
                    s = s.redIAdd(s);
                    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a)
                      , t = m.redSqr().redISub(s).redISub(s);
                    nx = t;
                    var yyyy8 = yyyy.redIAdd(yyyy);
                    yyyy8 = (yyyy8 = yyyy8.redIAdd(yyyy8)).redIAdd(yyyy8),
                    ny = m.redMul(s.redISub(t)).redISub(yyyy8),
                    nz = this.y.redAdd(this.y)
                } else {
                    var delta = this.z.redSqr()
                      , gamma = this.y.redSqr()
                      , beta = this.x.redMul(gamma)
                      , alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
                    alpha = alpha.redAdd(alpha).redIAdd(alpha);
                    var beta4 = beta.redIAdd(beta)
                      , beta8 = (beta4 = beta4.redIAdd(beta4)).redAdd(beta4);
                    nx = alpha.redSqr().redISub(beta8),
                    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
                    var ggamma8 = gamma.redSqr();
                    ggamma8 = (ggamma8 = (ggamma8 = ggamma8.redIAdd(ggamma8)).redIAdd(ggamma8)).redIAdd(ggamma8),
                    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8)
                }
                return this.curve.jpoint(nx, ny, nz)
            }
            ,
            JPoint.prototype._dbl = function() {
                var a = this.curve.a
                  , jx = this.x
                  , jy = this.y
                  , jz = this.z
                  , jz4 = jz.redSqr().redSqr()
                  , jx2 = jx.redSqr()
                  , jy2 = jy.redSqr()
                  , c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4))
                  , jxd4 = jx.redAdd(jx)
                  , t1 = (jxd4 = jxd4.redIAdd(jxd4)).redMul(jy2)
                  , nx = c.redSqr().redISub(t1.redAdd(t1))
                  , t2 = t1.redISub(nx)
                  , jyd8 = jy2.redSqr();
                jyd8 = (jyd8 = (jyd8 = jyd8.redIAdd(jyd8)).redIAdd(jyd8)).redIAdd(jyd8);
                var ny = c.redMul(t2).redISub(jyd8)
                  , nz = jy.redAdd(jy).redMul(jz);
                return this.curve.jpoint(nx, ny, nz)
            }
            ,
            JPoint.prototype.trpl = function() {
                if (!this.curve.zeroA)
                    return this.dbl().add(this);
                var xx = this.x.redSqr()
                  , yy = this.y.redSqr()
                  , zz = this.z.redSqr()
                  , yyyy = yy.redSqr()
                  , m = xx.redAdd(xx).redIAdd(xx)
                  , mm = m.redSqr()
                  , e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy)
                  , ee = (e = (e = (e = e.redIAdd(e)).redAdd(e).redIAdd(e)).redISub(mm)).redSqr()
                  , t = yyyy.redIAdd(yyyy);
                t = (t = (t = t.redIAdd(t)).redIAdd(t)).redIAdd(t);
                var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t)
                  , yyu4 = yy.redMul(u);
                yyu4 = (yyu4 = yyu4.redIAdd(yyu4)).redIAdd(yyu4);
                var nx = this.x.redMul(ee).redISub(yyu4);
                nx = (nx = nx.redIAdd(nx)).redIAdd(nx);
                var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
                ny = (ny = (ny = ny.redIAdd(ny)).redIAdd(ny)).redIAdd(ny);
                var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
                return this.curve.jpoint(nx, ny, nz)
            }
            ,
            JPoint.prototype.mul = function(k, kbase) {
                return k = new BN(k,kbase),
                this.curve._wnafMul(this, k)
            }
            ,
            JPoint.prototype.eq = function(p) {
                if ("affine" === p.type)
                    return this.eq(p.toJ());
                if (this === p)
                    return !0;
                var z2 = this.z.redSqr()
                  , pz2 = p.z.redSqr();
                if (0 !== this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0))
                    return !1;
                var z3 = z2.redMul(this.z)
                  , pz3 = pz2.redMul(p.z);
                return 0 === this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0)
            }
            ,
            JPoint.prototype.eqXToP = function(x) {
                var zs = this.z.redSqr()
                  , rx = x.toRed(this.curve.red).redMul(zs);
                if (0 === this.x.cmp(rx))
                    return !0;
                for (var xc = x.clone(), t = this.curve.redN.redMul(zs); ; ) {
                    if (xc.iadd(this.curve.n),
                    xc.cmp(this.curve.p) >= 0)
                        return !1;
                    if (rx.redIAdd(t),
                    0 === this.x.cmp(rx))
                        return !0
                }
            }
            ,
            JPoint.prototype.inspect = function() {
                return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">"
            }
            ,
            JPoint.prototype.isInfinity = function() {
                return 0 === this.z.cmpn(0)
            }
        }
        ,
        45427: (__unused_webpack_module,exports,__webpack_require__)=>{
            "use strict";
            var pre, curves = exports, hash = __webpack_require__(33715), curve = __webpack_require__(88254), assert = __webpack_require__(80953).assert;
            function PresetCurve(options) {
                "short" === options.type ? this.curve = new curve.short(options) : "edwards" === options.type ? this.curve = new curve.edwards(options) : this.curve = new curve.mont(options),
                this.g = this.curve.g,
                this.n = this.curve.n,
                this.hash = options.hash,
                assert(this.g.validate(), "Invalid curve"),
                assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O")
            }
            function defineCurve(name, options) {
                Object.defineProperty(curves, name, {
                    configurable: !0,
                    enumerable: !0,
                    get: function() {
                        var curve = new PresetCurve(options);
                        return Object.defineProperty(curves, name, {
                            configurable: !0,
                            enumerable: !0,
                            value: curve
                        }),
                        curve
                    }
                })
            }
            curves.PresetCurve = PresetCurve,
            defineCurve("p192", {
                type: "short",
                prime: "p192",
                p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
                a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
                b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
                n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
                hash: hash.sha256,
                gRed: !1,
                g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]
            }),
            defineCurve("p224", {
                type: "short",
                prime: "p224",
                p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
                a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
                b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
                n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
                hash: hash.sha256,
                gRed: !1,
                g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]
            }),
            defineCurve("p256", {
                type: "short",
                prime: null,
                p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
                a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
                b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
                n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
                hash: hash.sha256,
                gRed: !1,
                g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]
            }),
            defineCurve("p384", {
                type: "short",
                prime: null,
                p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
                a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
                b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
                n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
                hash: hash.sha384,
                gRed: !1,
                g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]
            }),
            defineCurve("p521", {
                type: "short",
                prime: null,
                p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
                a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
                b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
                n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
                hash: hash.sha512,
                gRed: !1,
                g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]
            }),
            defineCurve("curve25519", {
                type: "mont",
                prime: "p25519",
                p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
                a: "76d06",
                b: "1",
                n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
                hash: hash.sha256,
                gRed: !1,
                g: ["9"]
            }),
            defineCurve("ed25519", {
                type: "edwards",
                prime: "p25519",
                p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
                a: "-1",
                c: "1",
                d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
                n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
                hash: hash.sha256,
                gRed: !1,
                g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"]
            });
            try {
                pre = __webpack_require__(91037)
            } catch (e) {
                pre = void 0
            }
            defineCurve("secp256k1", {
                type: "short",
                prime: "k256",
                p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
                a: "0",
                b: "7",
                n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
                h: "1",
                hash: hash.sha256,
                beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
                lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
                basis: [{
                    a: "3086d221a7d46bcde86c90e49284eb15",
                    b: "-e4437ed6010e88286f547fa90abfe4c3"
                }, {
                    a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
                    b: "3086d221a7d46bcde86c90e49284eb15"
                }],
                gRed: !1,
                g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", pre]
            })
        }
        ,
        57954: (module,__unused_webpack_exports,__webpack_require__)=>{
            "use strict";
            var BN = __webpack_require__(13550)
              , HmacDRBG = __webpack_require__(2156)
              , utils = __webpack_require__(80953)
              , curves = __webpack_require__(45427)
              , rand = __webpack_require__(29931)
              , assert = utils.assert
              , KeyPair = __webpack_require__(31251)
              , Signature = __webpack_require__(90611);
            function EC(options) {
                if (!(this instanceof EC))
                    return new EC(options);
                "string" == typeof options && (assert(Object.prototype.hasOwnProperty.call(curves, options), "Unknown curve " + options),
                options = curves[options]),
                options instanceof curves.PresetCurve && (options = {
                    curve: options
                }),
                this.curve = options.curve.curve,
                this.n = this.curve.n,
                this.nh = this.n.ushrn(1),
                this.g = this.curve.g,
                this.g = options.curve.g,
                this.g.precompute(options.curve.n.bitLength() + 1),
                this.hash = options.hash || options.curve.hash
            }
            module.exports = EC,
            EC.prototype.keyPair = function(options) {
                return new KeyPair(this,options)
            }
            ,
            EC.prototype.keyFromPrivate = function(priv, enc) {
                return KeyPair.fromPrivate(this, priv, enc)
            }
            ,
            EC.prototype.keyFromPublic = function(pub, enc) {
                return KeyPair.fromPublic(this, pub, enc)
            }
            ,
            EC.prototype.genKeyPair = function(options) {
                options || (options = {});
                for (var drbg = new HmacDRBG({
                    hash: this.hash,
                    pers: options.pers,
                    persEnc: options.persEnc || "utf8",
                    entropy: options.entropy || rand(this.hash.hmacStrength),
                    entropyEnc: options.entropy && options.entropyEnc || "utf8",
                    nonce: this.n.toArray()
                }), bytes = this.n.byteLength(), ns2 = this.n.sub(new BN(2)); ; ) {
                    var priv = new BN(drbg.generate(bytes));
                    if (!(priv.cmp(ns2) > 0))
                        return priv.iaddn(1),
                        this.keyFromPrivate(priv)
                }
            }
            ,
            EC.prototype._truncateToN = function(msg, truncOnly) {
                var delta = 8 * msg.byteLength() - this.n.bitLength();
                return delta > 0 && (msg = msg.ushrn(delta)),
                !truncOnly && msg.cmp(this.n) >= 0 ? msg.sub(this.n) : msg
            }
            ,
            EC.prototype.sign = function(msg, key, enc, options) {
                "object" == typeof enc && (options = enc,
                enc = null),
                options || (options = {}),
                key = this.keyFromPrivate(key, enc),
                msg = this._truncateToN(new BN(msg,16));
                for (var bytes = this.n.byteLength(), bkey = key.getPrivate().toArray("be", bytes), nonce = msg.toArray("be", bytes), drbg = new HmacDRBG({
                    hash: this.hash,
                    entropy: bkey,
                    nonce,
                    pers: options.pers,
                    persEnc: options.persEnc || "utf8"
                }), ns1 = this.n.sub(new BN(1)), iter = 0; ; iter++) {
                    var k = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
                    if (!((k = this._truncateToN(k, !0)).cmpn(1) <= 0 || k.cmp(ns1) >= 0)) {
                        var kp = this.g.mul(k);
                        if (!kp.isInfinity()) {
                            var kpX = kp.getX()
                              , r = kpX.umod(this.n);
                            if (0 !== r.cmpn(0)) {
                                var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
                                if (0 !== (s = s.umod(this.n)).cmpn(0)) {
                                    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (0 !== kpX.cmp(r) ? 2 : 0);
                                    return options.canonical && s.cmp(this.nh) > 0 && (s = this.n.sub(s),
                                    recoveryParam ^= 1),
                                    new Signature({
                                        r,
                                        s,
                                        recoveryParam
                                    })
                                }
                            }
                        }
                    }
                }
            }
            ,
            EC.prototype.verify = function(msg, signature, key, enc) {
                msg = this._truncateToN(new BN(msg,16)),
                key = this.keyFromPublic(key, enc);
                var r = (signature = new Signature(signature,"hex")).r
                  , s = signature.s;
                if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
                    return !1;
                if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
                    return !1;
                var p, sinv = s.invm(this.n), u1 = sinv.mul(msg).umod(this.n), u2 = sinv.mul(r).umod(this.n);
                return this.curve._maxwellTrick ? !(p = this.g.jmulAdd(u1, key.getPublic(), u2)).isInfinity() && p.eqXToP(r) : !(p = this.g.mulAdd(u1, key.getPublic(), u2)).isInfinity() && 0 === p.getX().umod(this.n).cmp(r)
            }
            ,
            EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
                assert((3 & j) === j, "The recovery param is more than two bits"),
                signature = new Signature(signature,enc);
                var n = this.n
                  , e = new BN(msg)
                  , r = signature.r
                  , s = signature.s
                  , isYOdd = 1 & j
                  , isSecondKey = j >> 1;
                if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
                    throw new Error("Unable to find sencond key candinate");
                r = isSecondKey ? this.curve.pointFromX(r.add(this.curve.n), isYOdd) : this.curve.pointFromX(r, isYOdd);
                var rInv = signature.r.invm(n)
                  , s1 = n.sub(e).mul(rInv).umod(n)
                  , s2 = s.mul(rInv).umod(n);
                return this.g.mulAdd(s1, r, s2)
            }
            ,
            EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
                if (null !== (signature = new Signature(signature,enc)).recoveryParam)
                    return signature.recoveryParam;
                for (var i = 0; i < 4; i++) {
                    var Qprime;
                    try {
                        Qprime = this.recoverPubKey(e, signature, i)
                    } catch (e) {
                        continue
                    }
                    if (Qprime.eq(Q))
                        return i
                }
                throw new Error("Unable to find valid recovery factor")
            }
        }
        ,
        31251: (module,__unused_webpack_exports,__webpack_require__)=>{
            "use strict";
            var BN = __webpack_require__(13550)
              , assert = __webpack_require__(80953).assert;
            function KeyPair(ec, options) {
                this.ec = ec,
                this.priv = null,
                this.pub = null,
                options.priv && this._importPrivate(options.priv, options.privEnc),
                options.pub && this._importPublic(options.pub, options.pubEnc)
            }
            module.exports = KeyPair,
            KeyPair.fromPublic = function(ec, pub, enc) {
                return pub instanceof KeyPair ? pub : new KeyPair(ec,{
                    pub,
                    pubEnc: enc
                })
            }
            ,
            KeyPair.fromPrivate = function(ec, priv, enc) {
                return priv instanceof KeyPair ? priv : new KeyPair(ec,{
                    priv,
                    privEnc: enc
                })
            }
            ,
            KeyPair.prototype.validate = function() {
                var pub = this.getPublic();
                return pub.isInfinity() ? {
                    result: !1,
                    reason: "Invalid public key"
                } : pub.validate() ? pub.mul(this.ec.curve.n).isInfinity() ? {
                    result: !0,
                    reason: null
                } : {
                    result: !1,
                    reason: "Public key * N != O"
                } : {
                    result: !1,
                    reason: "Public key is not a point"
                }
            }
            ,
            KeyPair.prototype.getPublic = function(compact, enc) {
                return "string" == typeof compact && (enc = compact,
                compact = null),
                this.pub || (this.pub = this.ec.g.mul(this.priv)),
                enc ? this.pub.encode(enc, compact) : this.pub
            }
            ,
            KeyPair.prototype.getPrivate = function(enc) {
                return "hex" === enc ? this.priv.toString(16, 2) : this.priv
            }
            ,
            KeyPair.prototype._importPrivate = function(key, enc) {
                this.priv = new BN(key,enc || 16),
                this.priv = this.priv.umod(this.ec.curve.n)
            }
            ,
            KeyPair.prototype._importPublic = function(key, enc) {
                if (key.x || key.y)
                    return "mont" === this.ec.curve.type ? assert(key.x, "Need x coordinate") : "short" !== this.ec.curve.type && "edwards" !== this.ec.curve.type || assert(key.x && key.y, "Need both x and y coordinate"),
                    void (this.pub = this.ec.curve.point(key.x, key.y));
                this.pub = this.ec.curve.decodePoint(key, enc)
            }
            ,
            KeyPair.prototype.derive = function(pub) {
                return pub.validate() || assert(pub.validate(), "public point not validated"),
                pub.mul(this.priv).getX()
            }
            ,
            KeyPair.prototype.sign = function(msg, enc, options) {
                return this.ec.sign(msg, this, enc, options)
            }
            ,
            KeyPair.prototype.verify = function(msg, signature) {
                return this.ec.verify(msg, signature, this)
            }
            ,
            KeyPair.prototype.inspect = function() {
                return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >"
            }
        }
        ,
        90611: (module,__unused_webpack_exports,__webpack_require__)=>{
            "use strict";
            var BN = __webpack_require__(13550)
              , utils = __webpack_require__(80953)
              , assert = utils.assert;
            function Signature(options, enc) {
                if (options instanceof Signature)
                    return options;
                this._importDER(options, enc) || (assert(options.r && options.s, "Signature without r or s"),
                this.r = new BN(options.r,16),
                this.s = new BN(options.s,16),
                void 0 === options.recoveryParam ? this.recoveryParam = null : this.recoveryParam = options.recoveryParam)
            }
            function Position() {
                this.place = 0
            }
            function getLength(buf, p) {
                var initial = buf[p.place++];
                if (!(128 & initial))
                    return initial;
                var octetLen = 15 & initial;
                if (0 === octetLen || octetLen > 4)
                    return !1;
                for (var val = 0, i = 0, off = p.place; i < octetLen; i++,
                off++)
                    val <<= 8,
                    val |= buf[off],
                    val >>>= 0;
                return !(val <= 127) && (p.place = off,
                val)
            }
            function rmPadding(buf) {
                for (var i = 0, len = buf.length - 1; !buf[i] && !(128 & buf[i + 1]) && i < len; )
                    i++;
                return 0 === i ? buf : buf.slice(i)
            }
            function constructLength(arr, len) {
                if (len < 128)
                    arr.push(len);
                else {
                    var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
                    for (arr.push(128 | octets); --octets; )
                        arr.push(len >>> (octets << 3) & 255);
                    arr.push(len)
                }
            }
            module.exports = Signature,
            Signature.prototype._importDER = function(data, enc) {
                data = utils.toArray(data, enc);
                var p = new Position;
                if (48 !== data[p.place++])
                    return !1;
                var len = getLength(data, p);
                if (!1 === len)
                    return !1;
                if (len + p.place !== data.length)
                    return !1;
                if (2 !== data[p.place++])
                    return !1;
                var rlen = getLength(data, p);
                if (!1 === rlen)
                    return !1;
                var r = data.slice(p.place, rlen + p.place);
                if (p.place += rlen,
                2 !== data[p.place++])
                    return !1;
                var slen = getLength(data, p);
                if (!1 === slen)
                    return !1;
                if (data.length !== slen + p.place)
                    return !1;
                var s = data.slice(p.place, slen + p.place);
                if (0 === r[0]) {
                    if (!(128 & r[1]))
                        return !1;
                    r = r.slice(1)
                }
                if (0 === s[0]) {
                    if (!(128 & s[1]))
                        return !1;
                    s = s.slice(1)
                }
                return this.r = new BN(r),
                this.s = new BN(s),
                this.recoveryParam = null,
                !0
            }
            ,
            Signature.prototype.toDER = function(enc) {
                var r = this.r.toArray()
                  , s = this.s.toArray();
                for (128 & r[0] && (r = [0].concat(r)),
                128 & s[0] && (s = [0].concat(s)),
                r = rmPadding(r),
                s = rmPadding(s); !(s[0] || 128 & s[1]); )
                    s = s.slice(1);
                var arr = [2];
                constructLength(arr, r.length),
                (arr = arr.concat(r)).push(2),
                constructLength(arr, s.length);
                var backHalf = arr.concat(s)
                  , res = [48];
                return constructLength(res, backHalf.length),
                res = res.concat(backHalf),
                utils.encode(res, enc)
            }
        }
        ,
        65980: (module,__unused_webpack_exports,__webpack_require__)=>{
            "use strict";
            var hash = __webpack_require__(33715)
              , curves = __webpack_require__(45427)
              , utils = __webpack_require__(80953)
              , assert = utils.assert
              , parseBytes = utils.parseBytes
              , KeyPair = __webpack_require__(79087)
              , Signature = __webpack_require__(23622);
            function EDDSA(curve) {
                if (assert("ed25519" === curve, "only tested with ed25519 so far"),
                !(this instanceof EDDSA))
                    return new EDDSA(curve);
                curve = curves[curve].curve,
                this.curve = curve,
                this.g = curve.g,
                this.g.precompute(curve.n.bitLength() + 1),
                this.pointClass = curve.point().constructor,
                this.encodingLength = Math.ceil(curve.n.bitLength() / 8),
                this.hash = hash.sha512
            }
            module.exports = EDDSA,
            EDDSA.prototype.sign = function(message, secret) {
                message = parseBytes(message);
                var key = this.keyFromSecret(secret)
                  , r = this.hashInt(key.messagePrefix(), message)
                  , R = this.g.mul(r)
                  , Rencoded = this.encodePoint(R)
                  , s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv())
                  , S = r.add(s_).umod(this.curve.n);
                return this.makeSignature({
                    R,
                    S,
                    Rencoded
                })
            }
            ,
            EDDSA.prototype.verify = function(message, sig, pub) {
                message = parseBytes(message),
                sig = this.makeSignature(sig);
                var key = this.keyFromPublic(pub)
                  , h = this.hashInt(sig.Rencoded(), key.pubBytes(), message)
                  , SG = this.g.mul(sig.S());
                return sig.R().add(key.pub().mul(h)).eq(SG)
            }
            ,
            EDDSA.prototype.hashInt = function() {
                for (var hash = this.hash(), i = 0; i < arguments.length; i++)
                    hash.update(arguments[i]);
                return utils.intFromLE(hash.digest()).umod(this.curve.n)
            }
            ,
            EDDSA.prototype.keyFromPublic = function(pub) {
                return KeyPair.fromPublic(this, pub)
            }
            ,
            EDDSA.prototype.keyFromSecret = function(secret) {
                return KeyPair.fromSecret(this, secret)
            }
            ,
            EDDSA.prototype.makeSignature = function(sig) {
                return sig instanceof Signature ? sig : new Signature(this,sig)
            }
            ,
            EDDSA.prototype.encodePoint = function(point) {
                var enc = point.getY().toArray("le", this.encodingLength);
                return enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0,
                enc
            }
            ,
            EDDSA.prototype.decodePoint = function(bytes) {
                var lastIx = (bytes = utils.parseBytes(bytes)).length - 1
                  , normed = bytes.slice(0, lastIx).concat(-129 & bytes[lastIx])
                  , xIsOdd = 0 != (128 & bytes[lastIx])
                  , y = utils.intFromLE(normed);
                return this.curve.pointFromY(y, xIsOdd)
            }
            ,
            EDDSA.prototype.encodeInt = function(num) {
                return num.toArray("le", this.encodingLength)
            }
            ,
            EDDSA.prototype.decodeInt = function(bytes) {
                return utils.intFromLE(bytes)
            }
            ,
            EDDSA.prototype.isPoint = function(val) {
                return val instanceof this.pointClass
            }
        }
        ,
        79087: (module,__unused_webpack_exports,__webpack_require__)=>{
            "use strict";
            var utils = __webpack_require__(80953)
              , assert = utils.assert
              , parseBytes = utils.parseBytes
              , cachedProperty = utils.cachedProperty;
            function KeyPair(eddsa, params) {
                this.eddsa = eddsa,
                this._secret = parseBytes(params.secret),
                eddsa.isPoint(params.pub) ? this._pub = params.pub : this._pubBytes = parseBytes(params.pub)
            }
            KeyPair.fromPublic = function(eddsa, pub) {
                return pub instanceof KeyPair ? pub : new KeyPair(eddsa,{
                    pub
                })
            }
            ,
            KeyPair.fromSecret = function(eddsa, secret) {
                return secret instanceof KeyPair ? secret : new KeyPair(eddsa,{
                    secret
                })
            }
            ,
            KeyPair.prototype.secret = function() {
                return this._secret
            }
            ,
            cachedProperty(KeyPair, "pubBytes", (function() {
                return this.eddsa.encodePoint(this.pub())
            }
            )),
            cachedProperty(KeyPair, "pub", (function() {
                return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv())
            }
            )),
            cachedProperty(KeyPair, "privBytes", (function() {
                var eddsa = this.eddsa
                  , hash = this.hash()
                  , lastIx = eddsa.encodingLength - 1
                  , a = hash.slice(0, eddsa.encodingLength);
                return a[0] &= 248,
                a[lastIx] &= 127,
                a[lastIx] |= 64,
                a
            }
            )),
            cachedProperty(KeyPair, "priv", (function() {
                return this.eddsa.decodeInt(this.privBytes())
            }
            )),
            cachedProperty(KeyPair, "hash", (function() {
                return this.eddsa.hash().update(this.secret()).digest()
            }
            )),
            cachedProperty(KeyPair, "messagePrefix", (function() {
                return this.hash().slice(this.eddsa.encodingLength)
            }
            )),
            KeyPair.prototype.sign = function(message) {
                return assert(this._secret, "KeyPair can only verify"),
                this.eddsa.sign(message, this)
            }
            ,
            KeyPair.prototype.verify = function(message, sig) {
                return this.eddsa.verify(message, sig, this)
            }
            ,
            KeyPair.prototype.getSecret = function(enc) {
                return assert(this._secret, "KeyPair is public only"),
                utils.encode(this.secret(), enc)
            }
            ,
            KeyPair.prototype.getPublic = function(enc) {
                return utils.encode(this.pubBytes(), enc)
            }
            ,
            module.exports = KeyPair
        }
        ,
        23622: (module,__unused_webpack_exports,__webpack_require__)=>{
            "use strict";
            var BN = __webpack_require__(13550)
              , utils = __webpack_require__(80953)
              , assert = utils.assert
              , cachedProperty = utils.cachedProperty
              , parseBytes = utils.parseBytes;
            function Signature(eddsa, sig) {
                this.eddsa = eddsa,
                "object" != typeof sig && (sig = parseBytes(sig)),
                Array.isArray(sig) && (sig = {
                    R: sig.slice(0, eddsa.encodingLength),
                    S: sig.slice(eddsa.encodingLength)
                }),
                assert(sig.R && sig.S, "Signature without R or S"),
                eddsa.isPoint(sig.R) && (this._R = sig.R),
                sig.S instanceof BN && (this._S = sig.S),
                this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded,
                this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded
            }
            cachedProperty(Signature, "S", (function() {
                return this.eddsa.decodeInt(this.Sencoded())
            }
            )),
            cachedProperty(Signature, "R", (function() {
                return this.eddsa.decodePoint(this.Rencoded())
            }
            )),
            cachedProperty(Signature, "Rencoded", (function() {
                return this.eddsa.encodePoint(this.R())
            }
            )),
            cachedProperty(Signature, "Sencoded", (function() {
                return this.eddsa.encodeInt(this.S())
            }
            )),
            Signature.prototype.toBytes = function() {
                return this.Rencoded().concat(this.Sencoded())
            }
            ,
            Signature.prototype.toHex = function() {
                return utils.encode(this.toBytes(), "hex").toUpperCase()
            }
            ,
            module.exports = Signature
        }
        ,
        91037: module=>{
            module.exports = {
                doubles: {
                    step: 4,
                    points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]]
                },
                naf: {
                    wnd: 7,
                    points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]]
                }
            }
        }
        ,
        80953: (__unused_webpack_module,exports,__webpack_require__)=>{
            "use strict";
            var utils = exports
              , BN = __webpack_require__(13550)
              , minAssert = __webpack_require__(79746)
              , minUtils = __webpack_require__(34504);
            utils.assert = minAssert,
            utils.toArray = minUtils.toArray,
            utils.zero2 = minUtils.zero2,
            utils.toHex = minUtils.toHex,
            utils.encode = minUtils.encode,
            utils.getNAF = function(num, w, bits) {
                var naf = new Array(Math.max(num.bitLength(), bits) + 1);
                naf.fill(0);
                for (var ws = 1 << w + 1, k = num.clone(), i = 0; i < naf.length; i++) {
                    var z, mod = k.andln(ws - 1);
                    k.isOdd() ? (z = mod > (ws >> 1) - 1 ? (ws >> 1) - mod : mod,
                    k.isubn(z)) : z = 0,
                    naf[i] = z,
                    k.iushrn(1)
                }
                return naf
            }
            ,
            utils.getJSF = function(k1, k2) {
                var jsf = [[], []];
                k1 = k1.clone(),
                k2 = k2.clone();
                for (var m8, d1 = 0, d2 = 0; k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0; ) {
                    var u1, u2, m14 = k1.andln(3) + d1 & 3, m24 = k2.andln(3) + d2 & 3;
                    3 === m14 && (m14 = -1),
                    3 === m24 && (m24 = -1),
                    u1 = 0 == (1 & m14) ? 0 : 3 !== (m8 = k1.andln(7) + d1 & 7) && 5 !== m8 || 2 !== m24 ? m14 : -m14,
                    jsf[0].push(u1),
                    u2 = 0 == (1 & m24) ? 0 : 3 !== (m8 = k2.andln(7) + d2 & 7) && 5 !== m8 || 2 !== m14 ? m24 : -m24,
                    jsf[1].push(u2),
                    2 * d1 === u1 + 1 && (d1 = 1 - d1),
                    2 * d2 === u2 + 1 && (d2 = 1 - d2),
                    k1.iushrn(1),
                    k2.iushrn(1)
                }
                return jsf
            }
            ,
            utils.cachedProperty = function(obj, name, computer) {
                var key = "_" + name;
                obj.prototype[name] = function() {
                    return void 0 !== this[key] ? this[key] : this[key] = computer.call(this)
                }
            }
            ,
            utils.parseBytes = function(bytes) {
                return "string" == typeof bytes ? utils.toArray(bytes, "hex") : bytes
            }
            ,
            utils.intFromLE = function(bytes) {
                return new BN(bytes,"hex","le")
            }
        }
        ,
        82192: (__unused_webpack_module,exports,__webpack_require__)=>{
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.keccak512 = exports.keccak384 = exports.keccak256 = exports.keccak224 = void 0;
            const sha3_1 = __webpack_require__(84589)
              , utils_1 = __webpack_require__(58040);
            exports.keccak224 = (0,
            utils_1.wrapHash)(sha3_1.keccak_224),
            exports.keccak256 = (()=>{
                const k = (0,
                utils_1.wrapHash)(sha3_1.keccak_256);
                return k.create = sha3_1.keccak_256.create,
                k
            }
            )(),
            exports.keccak384 = (0,
            utils_1.wrapHash)(sha3_1.keccak_384),
            exports.keccak512 = (0,
            utils_1.wrapHash)(sha3_1.keccak_512)
        }
        ,
        79131: (__unused_webpack_module,exports)=>{
            "use strict";
            function number(n) {
                if (!Number.isSafeInteger(n) || n < 0)
                    throw new Error(`Wrong positive integer: ${n}`)
            }
            function bool(b) {
                if ("boolean" != typeof b)
                    throw new Error(`Expected boolean, not ${b}`)
            }
            function bytes(b, ...lengths) {
                if (!(b instanceof Uint8Array))
                    throw new TypeError("Expected Uint8Array");
                if (lengths.length > 0 && !lengths.includes(b.length))
                    throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`)
            }
            function hash(hash) {
                if ("function" != typeof hash || "function" != typeof hash.create)
                    throw new Error("Hash should be wrapped by utils.wrapConstructor");
                number(hash.outputLen),
                number(hash.blockLen)
            }
            function exists(instance, checkFinished=!0) {
                if (instance.destroyed)
                    throw new Error("Hash instance has been destroyed");
                if (checkFinished && instance.finished)
                    throw new Error("Hash#digest() has already been called")
            }
            function output(out, instance) {
                bytes(out);
                const min = instance.outputLen;
                if (out.length < min)
                    throw new Error(`digestInto() expects output buffer of length at least ${min}`)
            }
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0,
            exports.number = number,
            exports.bool = bool,
            exports.bytes = bytes,
            exports.hash = hash,
            exports.exists = exists,
            exports.output = output;
            const assert = {
                number,
                bool,
                bytes,
                hash,
                exists,
                output
            };
            exports.default = assert
        }
        ,
        97946: (__unused_webpack_module,exports)=>{
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.add = exports.toBig = exports.split = exports.fromBig = void 0;
            const U32_MASK64 = BigInt(2 ** 32 - 1)
              , _32n = BigInt(32);
            function fromBig(n, le=!1) {
                return le ? {
                    h: Number(n & U32_MASK64),
                    l: Number(n >> _32n & U32_MASK64)
                } : {
                    h: 0 | Number(n >> _32n & U32_MASK64),
                    l: 0 | Number(n & U32_MASK64)
                }
            }
            function split(lst, le=!1) {
                let Ah = new Uint32Array(lst.length)
                  , Al = new Uint32Array(lst.length);
                for (let i = 0; i < lst.length; i++) {
                    const {h, l} = fromBig(lst[i], le);
                    [Ah[i],Al[i]] = [h, l]
                }
                return [Ah, Al]
            }
            exports.fromBig = fromBig,
            exports.split = split;
            exports.toBig = (h,l)=>BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
            function add(Ah, Al, Bh, Bl) {
                const l = (Al >>> 0) + (Bl >>> 0);
                return {
                    h: Ah + Bh + (l / 2 ** 32 | 0) | 0,
                    l: 0 | l
                }
            }
            exports.add = add;
            const u64 = {
                fromBig,
                split,
                toBig: exports.toBig,
                shrSH: (h,l,s)=>h >>> s,
                shrSL: (h,l,s)=>h << 32 - s | l >>> s,
                rotrSH: (h,l,s)=>h >>> s | l << 32 - s,
                rotrSL: (h,l,s)=>h << 32 - s | l >>> s,
                rotrBH: (h,l,s)=>h << 64 - s | l >>> s - 32,
                rotrBL: (h,l,s)=>h >>> s - 32 | l << 64 - s,
                rotr32H: (h,l)=>l,
                rotr32L: (h,l)=>h,
                rotlSH: (h,l,s)=>h << s | l >>> 32 - s,
                rotlSL: (h,l,s)=>l << s | h >>> 32 - s,
                rotlBH: (h,l,s)=>l << s - 32 | h >>> 64 - s,
                rotlBL: (h,l,s)=>h << s - 32 | l >>> 64 - s,
                add,
                add3L: (Al,Bl,Cl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0),
                add3H: (low,Ah,Bh,Ch)=>Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0,
                add4L: (Al,Bl,Cl,Dl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0),
                add4H: (low,Ah,Bh,Ch,Dh)=>Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0,
                add5H: (low,Ah,Bh,Ch,Dh,Eh)=>Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0,
                add5L: (Al,Bl,Cl,Dl,El)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0)
            };
            exports.default = u64
        }
        ,
        50534: (__unused_webpack_module,exports)=>{
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.crypto = void 0,
            exports.crypto = {
                node: void 0,
                web: "object" == typeof self && "crypto"in self ? self.crypto : void 0
            }
        }
        ,
        84589: (__unused_webpack_module,exports,__webpack_require__)=>{
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;
            const _assert_js_1 = __webpack_require__(79131)
              , _u64_js_1 = __webpack_require__(97946)
              , utils_js_1 = __webpack_require__(23037)
              , [SHA3_PI,SHA3_ROTL,_SHA3_IOTA] = [[], [], []]
              , _0n = BigInt(0)
              , _1n = BigInt(1)
              , _2n = BigInt(2)
              , _7n = BigInt(7)
              , _256n = BigInt(256)
              , _0x71n = BigInt(113);
            for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
                [x,y] = [y, (2 * x + 3 * y) % 5],
                SHA3_PI.push(2 * (5 * y + x)),
                SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
                let t = _0n;
                for (let j = 0; j < 7; j++)
                    R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n,
                    R & _2n && (t ^= _1n << (_1n << BigInt(j)) - _1n);
                _SHA3_IOTA.push(t)
            }
            const [SHA3_IOTA_H,SHA3_IOTA_L] = _u64_js_1.default.split(_SHA3_IOTA, !0)
              , rotlH = (h,l,s)=>s > 32 ? _u64_js_1.default.rotlBH(h, l, s) : _u64_js_1.default.rotlSH(h, l, s)
              , rotlL = (h,l,s)=>s > 32 ? _u64_js_1.default.rotlBL(h, l, s) : _u64_js_1.default.rotlSL(h, l, s);
            function keccakP(s, rounds=24) {
                const B = new Uint32Array(10);
                for (let round = 24 - rounds; round < 24; round++) {
                    for (let x = 0; x < 10; x++)
                        B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
                    for (let x = 0; x < 10; x += 2) {
                        const idx1 = (x + 8) % 10
                          , idx0 = (x + 2) % 10
                          , B0 = B[idx0]
                          , B1 = B[idx0 + 1]
                          , Th = rotlH(B0, B1, 1) ^ B[idx1]
                          , Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
                        for (let y = 0; y < 50; y += 10)
                            s[x + y] ^= Th,
                            s[x + y + 1] ^= Tl
                    }
                    let curH = s[2]
                      , curL = s[3];
                    for (let t = 0; t < 24; t++) {
                        const shift = SHA3_ROTL[t]
                          , Th = rotlH(curH, curL, shift)
                          , Tl = rotlL(curH, curL, shift)
                          , PI = SHA3_PI[t];
                        curH = s[PI],
                        curL = s[PI + 1],
                        s[PI] = Th,
                        s[PI + 1] = Tl
                    }
                    for (let y = 0; y < 50; y += 10) {
                        for (let x = 0; x < 10; x++)
                            B[x] = s[y + x];
                        for (let x = 0; x < 10; x++)
                            s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10]
                    }
                    s[0] ^= SHA3_IOTA_H[round],
                    s[1] ^= SHA3_IOTA_L[round]
                }
                B.fill(0)
            }
            exports.keccakP = keccakP;
            class Keccak extends utils_js_1.Hash {
                constructor(blockLen, suffix, outputLen, enableXOF=!1, rounds=24) {
                    if (super(),
                    this.blockLen = blockLen,
                    this.suffix = suffix,
                    this.outputLen = outputLen,
                    this.enableXOF = enableXOF,
                    this.rounds = rounds,
                    this.pos = 0,
                    this.posOut = 0,
                    this.finished = !1,
                    this.destroyed = !1,
                    _assert_js_1.default.number(outputLen),
                    0 >= this.blockLen || this.blockLen >= 200)
                        throw new Error("Sha3 supports only keccak-f1600 function");
                    this.state = new Uint8Array(200),
                    this.state32 = (0,
                    utils_js_1.u32)(this.state)
                }
                keccak() {
                    keccakP(this.state32, this.rounds),
                    this.posOut = 0,
                    this.pos = 0
                }
                update(data) {
                    _assert_js_1.default.exists(this);
                    const {blockLen, state} = this
                      , len = (data = (0,
                    utils_js_1.toBytes)(data)).length;
                    for (let pos = 0; pos < len; ) {
                        const take = Math.min(blockLen - this.pos, len - pos);
                        for (let i = 0; i < take; i++)
                            state[this.pos++] ^= data[pos++];
                        this.pos === blockLen && this.keccak()
                    }
                    return this
                }
                finish() {
                    if (this.finished)
                        return;
                    this.finished = !0;
                    const {state, suffix, pos, blockLen} = this;
                    state[pos] ^= suffix,
                    0 != (128 & suffix) && pos === blockLen - 1 && this.keccak(),
                    state[blockLen - 1] ^= 128,
                    this.keccak()
                }
                writeInto(out) {
                    _assert_js_1.default.exists(this, !1),
                    _assert_js_1.default.bytes(out),
                    this.finish();
                    const bufferOut = this.state
                      , {blockLen} = this;
                    for (let pos = 0, len = out.length; pos < len; ) {
                        this.posOut >= blockLen && this.keccak();
                        const take = Math.min(blockLen - this.posOut, len - pos);
                        out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos),
                        this.posOut += take,
                        pos += take
                    }
                    return out
                }
                xofInto(out) {
                    if (!this.enableXOF)
                        throw new Error("XOF is not possible for this instance");
                    return this.writeInto(out)
                }
                xof(bytes) {
                    return _assert_js_1.default.number(bytes),
                    this.xofInto(new Uint8Array(bytes))
                }
                digestInto(out) {
                    if (_assert_js_1.default.output(out, this),
                    this.finished)
                        throw new Error("digest() was already called");
                    return this.writeInto(out),
                    this.destroy(),
                    out
                }
                digest() {
                    return this.digestInto(new Uint8Array(this.outputLen))
                }
                destroy() {
                    this.destroyed = !0,
                    this.state.fill(0)
                }
                _cloneInto(to) {
                    const {blockLen, suffix, outputLen, rounds, enableXOF} = this;
                    return to || (to = new Keccak(blockLen,suffix,outputLen,enableXOF,rounds)),
                    to.state32.set(this.state32),
                    to.pos = this.pos,
                    to.posOut = this.posOut,
                    to.finished = this.finished,
                    to.rounds = rounds,
                    to.suffix = suffix,
                    to.outputLen = outputLen,
                    to.enableXOF = enableXOF,
                    to.destroyed = this.destroyed,
                    to
                }
            }
            exports.Keccak = Keccak;
            const gen = (suffix,blockLen,outputLen)=>(0,
            utils_js_1.wrapConstructor)((()=>new Keccak(blockLen,suffix,outputLen)));
            exports.sha3_224 = gen(6, 144, 28),
            exports.sha3_256 = gen(6, 136, 32),
            exports.sha3_384 = gen(6, 104, 48),
            exports.sha3_512 = gen(6, 72, 64),
            exports.keccak_224 = gen(1, 144, 28),
            exports.keccak_256 = gen(1, 136, 32),
            exports.keccak_384 = gen(1, 104, 48),
            exports.keccak_512 = gen(1, 72, 64);
            const genShake = (suffix,blockLen,outputLen)=>(0,
            utils_js_1.wrapConstructorWithOpts)(((opts={})=>new Keccak(blockLen,suffix,void 0 === opts.dkLen ? outputLen : opts.dkLen,!0)));
            exports.shake128 = genShake(31, 168, 16),
            exports.shake256 = genShake(31, 136, 32)
        }
        ,
        23037: (__unused_webpack_module,exports,__webpack_require__)=>{
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.randomBytes = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
            const crypto_1 = __webpack_require__(50534);
            exports.u8 = arr=>new Uint8Array(arr.buffer,arr.byteOffset,arr.byteLength);
            exports.u32 = arr=>new Uint32Array(arr.buffer,arr.byteOffset,Math.floor(arr.byteLength / 4));
            exports.createView = arr=>new DataView(arr.buffer,arr.byteOffset,arr.byteLength);
            if (exports.rotr = (word,shift)=>word << 32 - shift | word >>> shift,
            exports.isLE = 68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0],
            !exports.isLE)
                throw new Error("Non little-endian hardware is not supported");
            const hexes = Array.from({
                length: 256
            }, ((v,i)=>i.toString(16).padStart(2, "0")));
            exports.bytesToHex = function(uint8a) {
                if (!(uint8a instanceof Uint8Array))
                    throw new Error("Uint8Array expected");
                let hex = "";
                for (let i = 0; i < uint8a.length; i++)
                    hex += hexes[uint8a[i]];
                return hex
            }
            ,
            exports.hexToBytes = function(hex) {
                if ("string" != typeof hex)
                    throw new TypeError("hexToBytes: expected string, got " + typeof hex);
                if (hex.length % 2)
                    throw new Error("hexToBytes: received invalid unpadded hex");
                const array = new Uint8Array(hex.length / 2);
                for (let i = 0; i < array.length; i++) {
                    const j = 2 * i
                      , hexByte = hex.slice(j, j + 2)
                      , byte = Number.parseInt(hexByte, 16);
                    if (Number.isNaN(byte) || byte < 0)
                        throw new Error("Invalid byte sequence");
                    array[i] = byte
                }
                return array
            }
            ;
            function utf8ToBytes(str) {
                if ("string" != typeof str)
                    throw new TypeError("utf8ToBytes expected string, got " + typeof str);
                return (new TextEncoder).encode(str)
            }
            function toBytes(data) {
                if ("string" == typeof data && (data = utf8ToBytes(data)),
                !(data instanceof Uint8Array))
                    throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
                return data
            }
            exports.nextTick = async()=>{}
            ,
            exports.asyncLoop = async function(iters, tick, cb) {
                let ts = Date.now();
                for (let i = 0; i < iters; i++) {
                    cb(i);
                    const diff = Date.now() - ts;
                    diff >= 0 && diff < tick || (await (0,
                    exports.nextTick)(),
                    ts += diff)
                }
            }
            ,
            exports.utf8ToBytes = utf8ToBytes,
            exports.toBytes = toBytes,
            exports.concatBytes = function(...arrays) {
                if (!arrays.every((a=>a instanceof Uint8Array)))
                    throw new Error("Uint8Array list expected");
                if (1 === arrays.length)
                    return arrays[0];
                const length = arrays.reduce(((a,arr)=>a + arr.length), 0)
                  , result = new Uint8Array(length);
                for (let i = 0, pad = 0; i < arrays.length; i++) {
                    const arr = arrays[i];
                    result.set(arr, pad),
                    pad += arr.length
                }
                return result
            }
            ;
            exports.Hash = class {
                clone() {
                    return this._cloneInto()
                }
            }
            ;
            exports.checkOpts = function(defaults, opts) {
                if (void 0 !== opts && ("object" != typeof opts || (obj = opts,
                "[object Object]" !== Object.prototype.toString.call(obj) || obj.constructor !== Object)))
                    throw new TypeError("Options should be object or undefined");
                var obj;
                return Object.assign(defaults, opts)
            }
            ,
            exports.wrapConstructor = function(hashConstructor) {
                const hashC = message=>hashConstructor().update(toBytes(message)).digest()
                  , tmp = hashConstructor();
                return hashC.outputLen = tmp.outputLen,
                hashC.blockLen = tmp.blockLen,
                hashC.create = ()=>hashConstructor(),
                hashC
            }
            ,
            exports.wrapConstructorWithOpts = function(hashCons) {
                const hashC = (msg,opts)=>hashCons(opts).update(toBytes(msg)).digest()
                  , tmp = hashCons({});
                return hashC.outputLen = tmp.outputLen,
                hashC.blockLen = tmp.blockLen,
                hashC.create = opts=>hashCons(opts),
                hashC
            }
            ,
            exports.randomBytes = function(bytesLength=32) {
                if (crypto_1.crypto.web)
                    return crypto_1.crypto.web.getRandomValues(new Uint8Array(bytesLength));
                if (crypto_1.crypto.node)
                    return new Uint8Array(crypto_1.crypto.node.randomBytes(bytesLength).buffer);
                throw new Error("The environment doesn't have randomBytes function")
            }
        }
        ,
        58040: function(module, exports, __webpack_require__) {
            "use strict";
            module = __webpack_require__.nmd(module);
            var __importDefault = this && this.__importDefault || function(mod) {
                return mod && mod.__esModule ? mod : {
                    default: mod
                }
            }
            ;
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.crypto = exports.wrapHash = exports.equalsBytes = exports.hexToBytes = exports.bytesToUtf8 = exports.utf8ToBytes = exports.createView = exports.concatBytes = exports.toHex = exports.bytesToHex = exports.assertBytes = exports.assertBool = void 0;
            const _assert_1 = __importDefault(__webpack_require__(79131))
              , utils_1 = __webpack_require__(23037)
              , assertBool = _assert_1.default.bool;
            exports.assertBool = assertBool;
            const assertBytes = _assert_1.default.bytes;
            exports.assertBytes = assertBytes;
            var utils_2 = __webpack_require__(23037);
            Object.defineProperty(exports, "bytesToHex", {
                enumerable: !0,
                get: function() {
                    return utils_2.bytesToHex
                }
            }),
            Object.defineProperty(exports, "toHex", {
                enumerable: !0,
                get: function() {
                    return utils_2.bytesToHex
                }
            }),
            Object.defineProperty(exports, "concatBytes", {
                enumerable: !0,
                get: function() {
                    return utils_2.concatBytes
                }
            }),
            Object.defineProperty(exports, "createView", {
                enumerable: !0,
                get: function() {
                    return utils_2.createView
                }
            }),
            Object.defineProperty(exports, "utf8ToBytes", {
                enumerable: !0,
                get: function() {
                    return utils_2.utf8ToBytes
                }
            }),
            exports.bytesToUtf8 = function(data) {
                if (!(data instanceof Uint8Array))
                    throw new TypeError("bytesToUtf8 expected Uint8Array, got " + typeof data);
                return (new TextDecoder).decode(data)
            }
            ,
            exports.hexToBytes = function(data) {
                const sliced = data.startsWith("0x") ? data.substring(2) : data;
                return (0,
                utils_1.hexToBytes)(sliced)
            }
            ,
            exports.equalsBytes = function(a, b) {
                if (a.length !== b.length)
                    return !1;
                for (let i = 0; i < a.length; i++)
                    if (a[i] !== b[i])
                        return !1;
                return !0
            }
            ,
            exports.wrapHash = function(hash) {
                return msg=>(_assert_1.default.bytes(msg),
                hash(msg))
            }
            ,
            exports.crypto = (()=>{
                const webCrypto = "object" == typeof self && "crypto"in self ? self.crypto : void 0
                  , nodeRequire = "function" == typeof module.require && module.require.bind(module);
                return {
                    node: nodeRequire && !webCrypto ? nodeRequire("crypto") : void 0,
                    web: webCrypto
                }
            }
            )()
        },
        33715: (__unused_webpack_module,exports,__webpack_require__)=>{
            var hash = exports;
            hash.utils = __webpack_require__(26436),
            hash.common = __webpack_require__(95772),
            hash.sha = __webpack_require__(89041),
            hash.ripemd = __webpack_require__(12949),
            hash.hmac = __webpack_require__(52344),
            hash.sha1 = hash.sha.sha1,
            hash.sha256 = hash.sha.sha256,
            hash.sha224 = hash.sha.sha224,
            hash.sha384 = hash.sha.sha384,
            hash.sha512 = hash.sha.sha512,
            hash.ripemd160 = hash.ripemd.ripemd160
        }
        ,
        95772: (__unused_webpack_module,exports,__webpack_require__)=>{
            "use strict";
            var utils = __webpack_require__(26436)
              , assert = __webpack_require__(79746);
            function BlockHash() {
                this.pending = null,
                this.pendingTotal = 0,
                this.blockSize = this.constructor.blockSize,
                this.outSize = this.constructor.outSize,
                this.hmacStrength = this.constructor.hmacStrength,
                this.padLength = this.constructor.padLength / 8,
                this.endian = "big",
                this._delta8 = this.blockSize / 8,
                this._delta32 = this.blockSize / 32
            }
            exports.BlockHash = BlockHash,
            BlockHash.prototype.update = function(msg, enc) {
                if (msg = utils.toArray(msg, enc),
                this.pending ? this.pending = this.pending.concat(msg) : this.pending = msg,
                this.pendingTotal += msg.length,
                this.pending.length >= this._delta8) {
                    var r = (msg = this.pending).length % this._delta8;
                    this.pending = msg.slice(msg.length - r, msg.length),
                    0 === this.pending.length && (this.pending = null),
                    msg = utils.join32(msg, 0, msg.length - r, this.endian);
                    for (var i = 0; i < msg.length; i += this._delta32)
                        this._update(msg, i, i + this._delta32)
                }
                return this
            }
            ,
            BlockHash.prototype.digest = function(enc) {
                return this.update(this._pad()),
                assert(null === this.pending),
                this._digest(enc)
            }
            ,
            BlockHash.prototype._pad = function() {
                var len = this.pendingTotal
                  , bytes = this._delta8
                  , k = bytes - (len + this.padLength) % bytes
                  , res = new Array(k + this.padLength);
                res[0] = 128;
                for (var i = 1; i < k; i++)
                    res[i] = 0;
                if (len <<= 3,
                "big" === this.endian) {
                    for (var t = 8; t < this.padLength; t++)
                        res[i++] = 0;
                    res[i++] = 0,
                    res[i++] = 0,
                    res[i++] = 0,
                    res[i++] = 0,
                    res[i++] = len >>> 24 & 255,
                    res[i++] = len >>> 16 & 255,
                    res[i++] = len >>> 8 & 255,
                    res[i++] = 255 & len
                } else
                    for (res[i++] = 255 & len,
                    res[i++] = len >>> 8 & 255,
                    res[i++] = len >>> 16 & 255,
                    res[i++] = len >>> 24 & 255,
                    res[i++] = 0,
                    res[i++] = 0,
                    res[i++] = 0,
                    res[i++] = 0,
                    t = 8; t < this.padLength; t++)
                        res[i++] = 0;
                return res
            }
        }
        ,
        52344: (module,__unused_webpack_exports,__webpack_require__)=>{
            "use strict";
            var utils = __webpack_require__(26436)
              , assert = __webpack_require__(79746);
            function Hmac(hash, key, enc) {
                if (!(this instanceof Hmac))
                    return new Hmac(hash,key,enc);
                this.Hash = hash,
                this.blockSize = hash.blockSize / 8,
                this.outSize = hash.outSize / 8,
                this.inner = null,
                this.outer = null,
                this._init(utils.toArray(key, enc))
            }
            module.exports = Hmac,
            Hmac.prototype._init = function(key) {
                key.length > this.blockSize && (key = (new this.Hash).update(key).digest()),
                assert(key.length <= this.blockSize);
                for (var i = key.length; i < this.blockSize; i++)
                    key.push(0);
                for (i = 0; i < key.length; i++)
                    key[i] ^= 54;
                for (this.inner = (new this.Hash).update(key),
                i = 0; i < key.length; i++)
                    key[i] ^= 106;
                this.outer = (new this.Hash).update(key)
            }
            ,
            Hmac.prototype.update = function(msg, enc) {
                return this.inner.update(msg, enc),
                this
            }
            ,
            Hmac.prototype.digest = function(enc) {
                return this.outer.update(this.inner.digest()),
                this.outer.digest(enc)
            }
        }
        ,
        12949: (__unused_webpack_module,exports,__webpack_require__)=>{
            "use strict";
            var utils = __webpack_require__(26436)
              , common = __webpack_require__(95772)
              , rotl32 = utils.rotl32
              , sum32 = utils.sum32
              , sum32_3 = utils.sum32_3
              , sum32_4 = utils.sum32_4
              , BlockHash = common.BlockHash;
            function RIPEMD160() {
                if (!(this instanceof RIPEMD160))
                    return new RIPEMD160;
                BlockHash.call(this),
                this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520],
                this.endian = "little"
            }
            function f(j, x, y, z) {
                return j <= 15 ? x ^ y ^ z : j <= 31 ? x & y | ~x & z : j <= 47 ? (x | ~y) ^ z : j <= 63 ? x & z | y & ~z : x ^ (y | ~z)
            }
            function K(j) {
                return j <= 15 ? 0 : j <= 31 ? 1518500249 : j <= 47 ? 1859775393 : j <= 63 ? 2400959708 : 2840853838
            }
            function Kh(j) {
                return j <= 15 ? 1352829926 : j <= 31 ? 1548603684 : j <= 47 ? 1836072691 : j <= 63 ? 2053994217 : 0
            }
            utils.inherits(RIPEMD160, BlockHash),
            exports.ripemd160 = RIPEMD160,
            RIPEMD160.blockSize = 512,
            RIPEMD160.outSize = 160,
            RIPEMD160.hmacStrength = 192,
            RIPEMD160.padLength = 64,
            RIPEMD160.prototype._update = function(msg, start) {
                for (var A = this.h[0], B = this.h[1], C = this.h[2], D = this.h[3], E = this.h[4], Ah = A, Bh = B, Ch = C, Dh = D, Eh = E, j = 0; j < 80; j++) {
                    var T = sum32(rotl32(sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);
                    A = E,
                    E = D,
                    D = rotl32(C, 10),
                    C = B,
                    B = T,
                    T = sum32(rotl32(sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh),
                    Ah = Eh,
                    Eh = Dh,
                    Dh = rotl32(Ch, 10),
                    Ch = Bh,
                    Bh = T
                }
                T = sum32_3(this.h[1], C, Dh),
                this.h[1] = sum32_3(this.h[2], D, Eh),
                this.h[2] = sum32_3(this.h[3], E, Ah),
                this.h[3] = sum32_3(this.h[4], A, Bh),
                this.h[4] = sum32_3(this.h[0], B, Ch),
                this.h[0] = T
            }
            ,
            RIPEMD160.prototype._digest = function(enc) {
                return "hex" === enc ? utils.toHex32(this.h, "little") : utils.split32(this.h, "little")
            }
            ;
            var r = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]
              , rh = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]
              , s = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]
              , sh = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]
        }
        ,
        89041: (__unused_webpack_module,exports,__webpack_require__)=>{
            "use strict";
            exports.sha1 = __webpack_require__(84761),
            exports.sha224 = __webpack_require__(10799),
            exports.sha256 = __webpack_require__(89344),
            exports.sha384 = __webpack_require__(80772),
            exports.sha512 = __webpack_require__(45900)
        }
        ,
        84761: (module,__unused_webpack_exports,__webpack_require__)=>{
            "use strict";
            var utils = __webpack_require__(26436)
              , common = __webpack_require__(95772)
              , shaCommon = __webpack_require__(37038)
              , rotl32 = utils.rotl32
              , sum32 = utils.sum32
              , sum32_5 = utils.sum32_5
              , ft_1 = shaCommon.ft_1
              , BlockHash = common.BlockHash
              , sha1_K = [1518500249, 1859775393, 2400959708, 3395469782];
            function SHA1() {
                if (!(this instanceof SHA1))
                    return new SHA1;
                BlockHash.call(this),
                this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520],
                this.W = new Array(80)
            }
            utils.inherits(SHA1, BlockHash),
            module.exports = SHA1,
            SHA1.blockSize = 512,
            SHA1.outSize = 160,
            SHA1.hmacStrength = 80,
            SHA1.padLength = 64,
            SHA1.prototype._update = function(msg, start) {
                for (var W = this.W, i = 0; i < 16; i++)
                    W[i] = msg[start + i];
                for (; i < W.length; i++)
                    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
                var a = this.h[0]
                  , b = this.h[1]
                  , c = this.h[2]
                  , d = this.h[3]
                  , e = this.h[4];
                for (i = 0; i < W.length; i++) {
                    var s = ~~(i / 20)
                      , t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
                    e = d,
                    d = c,
                    c = rotl32(b, 30),
                    b = a,
                    a = t
                }
                this.h[0] = sum32(this.h[0], a),
                this.h[1] = sum32(this.h[1], b),
                this.h[2] = sum32(this.h[2], c),
                this.h[3] = sum32(this.h[3], d),
                this.h[4] = sum32(this.h[4], e)
            }
            ,
            SHA1.prototype._digest = function(enc) {
                return "hex" === enc ? utils.toHex32(this.h, "big") : utils.split32(this.h, "big")
            }
        }
        ,
        10799: (module,__unused_webpack_exports,__webpack_require__)=>{
            "use strict";
            var utils = __webpack_require__(26436)
              , SHA256 = __webpack_require__(89344);
            function SHA224() {
                if (!(this instanceof SHA224))
                    return new SHA224;
                SHA256.call(this),
                this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]
            }
            utils.inherits(SHA224, SHA256),
            module.exports = SHA224,
            SHA224.blockSize = 512,
            SHA224.outSize = 224,
            SHA224.hmacStrength = 192,
            SHA224.padLength = 64,
            SHA224.prototype._digest = function(enc) {
                return "hex" === enc ? utils.toHex32(this.h.slice(0, 7), "big") : utils.split32(this.h.slice(0, 7), "big")
            }
        }
        ,
        89344: (module,__unused_webpack_exports,__webpack_require__)=>{
            "use strict";
            var utils = __webpack_require__(26436)
              , common = __webpack_require__(95772)
              , shaCommon = __webpack_require__(37038)
              , assert = __webpack_require__(79746)
              , sum32 = utils.sum32
              , sum32_4 = utils.sum32_4
              , sum32_5 = utils.sum32_5
              , ch32 = shaCommon.ch32
              , maj32 = shaCommon.maj32
              , s0_256 = shaCommon.s0_256
              , s1_256 = shaCommon.s1_256
              , g0_256 = shaCommon.g0_256
              , g1_256 = shaCommon.g1_256
              , BlockHash = common.BlockHash
              , sha256_K = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
            function SHA256() {
                if (!(this instanceof SHA256))
                    return new SHA256;
                BlockHash.call(this),
                this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225],
                this.k = sha256_K,
                this.W = new Array(64)
            }
            utils.inherits(SHA256, BlockHash),
            module.exports = SHA256,
            SHA256.blockSize = 512,
            SHA256.outSize = 256,
            SHA256.hmacStrength = 192,
            SHA256.padLength = 64,
            SHA256.prototype._update = function(msg, start) {
                for (var W = this.W, i = 0; i < 16; i++)
                    W[i] = msg[start + i];
                for (; i < W.length; i++)
                    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
                var a = this.h[0]
                  , b = this.h[1]
                  , c = this.h[2]
                  , d = this.h[3]
                  , e = this.h[4]
                  , f = this.h[5]
                  , g = this.h[6]
                  , h = this.h[7];
                for (assert(this.k.length === W.length),
                i = 0; i < W.length; i++) {
                    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i])
                      , T2 = sum32(s0_256(a), maj32(a, b, c));
                    h = g,
                    g = f,
                    f = e,
                    e = sum32(d, T1),
                    d = c,
                    c = b,
                    b = a,
                    a = sum32(T1, T2)
                }
                this.h[0] = sum32(this.h[0], a),
                this.h[1] = sum32(this.h[1], b),
                this.h[2] = sum32(this.h[2], c),
                this.h[3] = sum32(this.h[3], d),
                this.h[4] = sum32(this.h[4], e),
                this.h[5] = sum32(this.h[5], f),
                this.h[6] = sum32(this.h[6], g),
                this.h[7] = sum32(this.h[7], h)
            }
            ,
            SHA256.prototype._digest = function(enc) {
                return "hex" === enc ? utils.toHex32(this.h, "big") : utils.split32(this.h, "big")
            }
        }
        ,
        80772: (module,__unused_webpack_exports,__webpack_require__)=>{
            "use strict";
            var utils = __webpack_require__(26436)
              , SHA512 = __webpack_require__(45900);
            function SHA384() {
                if (!(this instanceof SHA384))
                    return new SHA384;
                SHA512.call(this),
                this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]
            }
            utils.inherits(SHA384, SHA512),
            module.exports = SHA384,
            SHA384.blockSize = 1024,
            SHA384.outSize = 384,
            SHA384.hmacStrength = 192,
            SHA384.padLength = 128,
            SHA384.prototype._digest = function(enc) {
                return "hex" === enc ? utils.toHex32(this.h.slice(0, 12), "big") : utils.split32(this.h.slice(0, 12), "big")
            }
        }
        ,
        45900: (module,__unused_webpack_exports,__webpack_require__)=>{
            "use strict";
            var utils = __webpack_require__(26436)
              , common = __webpack_require__(95772)
              , assert = __webpack_require__(79746)
              , rotr64_hi = utils.rotr64_hi
              , rotr64_lo = utils.rotr64_lo
              , shr64_hi = utils.shr64_hi
              , shr64_lo = utils.shr64_lo
              , sum64 = utils.sum64
              , sum64_hi = utils.sum64_hi
              , sum64_lo = utils.sum64_lo
              , sum64_4_hi = utils.sum64_4_hi
              , sum64_4_lo = utils.sum64_4_lo
              , sum64_5_hi = utils.sum64_5_hi
              , sum64_5_lo = utils.sum64_5_lo
              , BlockHash = common.BlockHash
              , sha512_K = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
            function SHA512() {
                if (!(this instanceof SHA512))
                    return new SHA512;
                BlockHash.call(this),
                this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209],
                this.k = sha512_K,
                this.W = new Array(160)
            }
            function ch64_hi(xh, xl, yh, yl, zh) {
                var r = xh & yh ^ ~xh & zh;
                return r < 0 && (r += 4294967296),
                r
            }
            function ch64_lo(xh, xl, yh, yl, zh, zl) {
                var r = xl & yl ^ ~xl & zl;
                return r < 0 && (r += 4294967296),
                r
            }
            function maj64_hi(xh, xl, yh, yl, zh) {
                var r = xh & yh ^ xh & zh ^ yh & zh;
                return r < 0 && (r += 4294967296),
                r
            }
            function maj64_lo(xh, xl, yh, yl, zh, zl) {
                var r = xl & yl ^ xl & zl ^ yl & zl;
                return r < 0 && (r += 4294967296),
                r
            }
            function s0_512_hi(xh, xl) {
                var r = rotr64_hi(xh, xl, 28) ^ rotr64_hi(xl, xh, 2) ^ rotr64_hi(xl, xh, 7);
                return r < 0 && (r += 4294967296),
                r
            }
            function s0_512_lo(xh, xl) {
                var r = rotr64_lo(xh, xl, 28) ^ rotr64_lo(xl, xh, 2) ^ rotr64_lo(xl, xh, 7);
                return r < 0 && (r += 4294967296),
                r
            }
            function s1_512_hi(xh, xl) {
                var r = rotr64_hi(xh, xl, 14) ^ rotr64_hi(xh, xl, 18) ^ rotr64_hi(xl, xh, 9);
                return r < 0 && (r += 4294967296),
                r
            }
            function s1_512_lo(xh, xl) {
                var r = rotr64_lo(xh, xl, 14) ^ rotr64_lo(xh, xl, 18) ^ rotr64_lo(xl, xh, 9);
                return r < 0 && (r += 4294967296),
                r
            }
            function g0_512_hi(xh, xl) {
                var r = rotr64_hi(xh, xl, 1) ^ rotr64_hi(xh, xl, 8) ^ shr64_hi(xh, xl, 7);
                return r < 0 && (r += 4294967296),
                r
            }
            function g0_512_lo(xh, xl) {
                var r = rotr64_lo(xh, xl, 1) ^ rotr64_lo(xh, xl, 8) ^ shr64_lo(xh, xl, 7);
                return r < 0 && (r += 4294967296),
                r
            }
            function g1_512_hi(xh, xl) {
                var r = rotr64_hi(xh, xl, 19) ^ rotr64_hi(xl, xh, 29) ^ shr64_hi(xh, xl, 6);
                return r < 0 && (r += 4294967296),
                r
            }
            function g1_512_lo(xh, xl) {
                var r = rotr64_lo(xh, xl, 19) ^ rotr64_lo(xl, xh, 29) ^ shr64_lo(xh, xl, 6);
                return r < 0 && (r += 4294967296),
                r
            }
            utils.inherits(SHA512, BlockHash),
            module.exports = SHA512,
            SHA512.blockSize = 1024,
            SHA512.outSize = 512,
            SHA512.hmacStrength = 192,
            SHA512.padLength = 128,
            SHA512.prototype._prepareBlock = function(msg, start) {
                for (var W = this.W, i = 0; i < 32; i++)
                    W[i] = msg[start + i];
                for (; i < W.length; i += 2) {
                    var c0_hi = g1_512_hi(W[i - 4], W[i - 3])
                      , c0_lo = g1_512_lo(W[i - 4], W[i - 3])
                      , c1_hi = W[i - 14]
                      , c1_lo = W[i - 13]
                      , c2_hi = g0_512_hi(W[i - 30], W[i - 29])
                      , c2_lo = g0_512_lo(W[i - 30], W[i - 29])
                      , c3_hi = W[i - 32]
                      , c3_lo = W[i - 31];
                    W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo),
                    W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo)
                }
            }
            ,
            SHA512.prototype._update = function(msg, start) {
                this._prepareBlock(msg, start);
                var W = this.W
                  , ah = this.h[0]
                  , al = this.h[1]
                  , bh = this.h[2]
                  , bl = this.h[3]
                  , ch = this.h[4]
                  , cl = this.h[5]
                  , dh = this.h[6]
                  , dl = this.h[7]
                  , eh = this.h[8]
                  , el = this.h[9]
                  , fh = this.h[10]
                  , fl = this.h[11]
                  , gh = this.h[12]
                  , gl = this.h[13]
                  , hh = this.h[14]
                  , hl = this.h[15];
                assert(this.k.length === W.length);
                for (var i = 0; i < W.length; i += 2) {
                    var c0_hi = hh
                      , c0_lo = hl
                      , c1_hi = s1_512_hi(eh, el)
                      , c1_lo = s1_512_lo(eh, el)
                      , c2_hi = ch64_hi(eh, el, fh, fl, gh)
                      , c2_lo = ch64_lo(eh, el, fh, fl, gh, gl)
                      , c3_hi = this.k[i]
                      , c3_lo = this.k[i + 1]
                      , c4_hi = W[i]
                      , c4_lo = W[i + 1]
                      , T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo)
                      , T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
                    c0_hi = s0_512_hi(ah, al),
                    c0_lo = s0_512_lo(ah, al),
                    c1_hi = maj64_hi(ah, al, bh, bl, ch),
                    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
                    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo)
                      , T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
                    hh = gh,
                    hl = gl,
                    gh = fh,
                    gl = fl,
                    fh = eh,
                    fl = el,
                    eh = sum64_hi(dh, dl, T1_hi, T1_lo),
                    el = sum64_lo(dl, dl, T1_hi, T1_lo),
                    dh = ch,
                    dl = cl,
                    ch = bh,
                    cl = bl,
                    bh = ah,
                    bl = al,
                    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo),
                    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo)
                }
                sum64(this.h, 0, ah, al),
                sum64(this.h, 2, bh, bl),
                sum64(this.h, 4, ch, cl),
                sum64(this.h, 6, dh, dl),
                sum64(this.h, 8, eh, el),
                sum64(this.h, 10, fh, fl),
                sum64(this.h, 12, gh, gl),
                sum64(this.h, 14, hh, hl)
            }
            ,
            SHA512.prototype._digest = function(enc) {
                return "hex" === enc ? utils.toHex32(this.h, "big") : utils.split32(this.h, "big")
            }
        }
        ,
        37038: (__unused_webpack_module,exports,__webpack_require__)=>{
            "use strict";
            var rotr32 = __webpack_require__(26436).rotr32;
            function ch32(x, y, z) {
                return x & y ^ ~x & z
            }
            function maj32(x, y, z) {
                return x & y ^ x & z ^ y & z
            }
            function p32(x, y, z) {
                return x ^ y ^ z
            }
            exports.ft_1 = function(s, x, y, z) {
                return 0 === s ? ch32(x, y, z) : 1 === s || 3 === s ? p32(x, y, z) : 2 === s ? maj32(x, y, z) : void 0
            }
            ,
            exports.ch32 = ch32,
            exports.maj32 = maj32,
            exports.p32 = p32,
            exports.s0_256 = function(x) {
                return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22)
            }
            ,
            exports.s1_256 = function(x) {
                return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25)
            }
            ,
            exports.g0_256 = function(x) {
                return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3
            }
            ,
            exports.g1_256 = function(x) {
                return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10
            }
        }
        ,
        26436: (__unused_webpack_module,exports,__webpack_require__)=>{
            "use strict";
            var assert = __webpack_require__(79746)
              , inherits = __webpack_require__(35717);
            function isSurrogatePair(msg, i) {
                return 55296 == (64512 & msg.charCodeAt(i)) && (!(i < 0 || i + 1 >= msg.length) && 56320 == (64512 & msg.charCodeAt(i + 1)))
            }
            function htonl(w) {
                return (w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (255 & w) << 24) >>> 0
            }
            function zero2(word) {
                return 1 === word.length ? "0" + word : word
            }
            function zero8(word) {
                return 7 === word.length ? "0" + word : 6 === word.length ? "00" + word : 5 === word.length ? "000" + word : 4 === word.length ? "0000" + word : 3 === word.length ? "00000" + word : 2 === word.length ? "000000" + word : 1 === word.length ? "0000000" + word : word
            }
            exports.inherits = inherits,
            exports.toArray = function(msg, enc) {
                if (Array.isArray(msg))
                    return msg.slice();
                if (!msg)
                    return [];
                var res = [];
                if ("string" == typeof msg)
                    if (enc) {
                        if ("hex" === enc)
                            for ((msg = msg.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (msg = "0" + msg),
                            i = 0; i < msg.length; i += 2)
                                res.push(parseInt(msg[i] + msg[i + 1], 16))
                    } else
                        for (var p = 0, i = 0; i < msg.length; i++) {
                            var c = msg.charCodeAt(i);
                            c < 128 ? res[p++] = c : c < 2048 ? (res[p++] = c >> 6 | 192,
                            res[p++] = 63 & c | 128) : isSurrogatePair(msg, i) ? (c = 65536 + ((1023 & c) << 10) + (1023 & msg.charCodeAt(++i)),
                            res[p++] = c >> 18 | 240,
                            res[p++] = c >> 12 & 63 | 128,
                            res[p++] = c >> 6 & 63 | 128,
                            res[p++] = 63 & c | 128) : (res[p++] = c >> 12 | 224,
                            res[p++] = c >> 6 & 63 | 128,
                            res[p++] = 63 & c | 128)
                        }
                else
                    for (i = 0; i < msg.length; i++)
                        res[i] = 0 | msg[i];
                return res
            }
            ,
            exports.toHex = function(msg) {
                for (var res = "", i = 0; i < msg.length; i++)
                    res += zero2(msg[i].toString(16));
                return res
            }
            ,
            exports.htonl = htonl,
            exports.toHex32 = function(msg, endian) {
                for (var res = "", i = 0; i < msg.length; i++) {
                    var w = msg[i];
                    "little" === endian && (w = htonl(w)),
                    res += zero8(w.toString(16))
                }
                return res
            }
            ,
            exports.zero2 = zero2,
            exports.zero8 = zero8,
            exports.join32 = function(msg, start, end, endian) {
                var len = end - start;
                assert(len % 4 == 0);
                for (var res = new Array(len / 4), i = 0, k = start; i < res.length; i++,
                k += 4) {
                    var w;
                    w = "big" === endian ? msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3] : msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k],
                    res[i] = w >>> 0
                }
                return res
            }
            ,
            exports.split32 = function(msg, endian) {
                for (var res = new Array(4 * msg.length), i = 0, k = 0; i < msg.length; i++,
                k += 4) {
                    var m = msg[i];
                    "big" === endian ? (res[k] = m >>> 24,
                    res[k + 1] = m >>> 16 & 255,
                    res[k + 2] = m >>> 8 & 255,
                    res[k + 3] = 255 & m) : (res[k + 3] = m >>> 24,
                    res[k + 2] = m >>> 16 & 255,
                    res[k + 1] = m >>> 8 & 255,
                    res[k] = 255 & m)
                }
                return res
            }
            ,
            exports.rotr32 = function(w, b) {
                return w >>> b | w << 32 - b
            }
            ,
            exports.rotl32 = function(w, b) {
                return w << b | w >>> 32 - b
            }
            ,
            exports.sum32 = function(a, b) {
                return a + b >>> 0
            }
            ,
            exports.sum32_3 = function(a, b, c) {
                return a + b + c >>> 0
            }
            ,
            exports.sum32_4 = function(a, b, c, d) {
                return a + b + c + d >>> 0
            }
            ,
            exports.sum32_5 = function(a, b, c, d, e) {
                return a + b + c + d + e >>> 0
            }
            ,
            exports.sum64 = function(buf, pos, ah, al) {
                var bh = buf[pos]
                  , lo = al + buf[pos + 1] >>> 0
                  , hi = (lo < al ? 1 : 0) + ah + bh;
                buf[pos] = hi >>> 0,
                buf[pos + 1] = lo
            }
            ,
            exports.sum64_hi = function(ah, al, bh, bl) {
                return (al + bl >>> 0 < al ? 1 : 0) + ah + bh >>> 0
            }
            ,
            exports.sum64_lo = function(ah, al, bh, bl) {
                return al + bl >>> 0
            }
            ,
            exports.sum64_4_hi = function(ah, al, bh, bl, ch, cl, dh, dl) {
                var carry = 0
                  , lo = al;
                return carry += (lo = lo + bl >>> 0) < al ? 1 : 0,
                carry += (lo = lo + cl >>> 0) < cl ? 1 : 0,
                ah + bh + ch + dh + (carry += (lo = lo + dl >>> 0) < dl ? 1 : 0) >>> 0
            }
            ,
            exports.sum64_4_lo = function(ah, al, bh, bl, ch, cl, dh, dl) {
                return al + bl + cl + dl >>> 0
            }
            ,
            exports.sum64_5_hi = function(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
                var carry = 0
                  , lo = al;
                return carry += (lo = lo + bl >>> 0) < al ? 1 : 0,
                carry += (lo = lo + cl >>> 0) < cl ? 1 : 0,
                carry += (lo = lo + dl >>> 0) < dl ? 1 : 0,
                ah + bh + ch + dh + eh + (carry += (lo = lo + el >>> 0) < el ? 1 : 0) >>> 0
            }
            ,
            exports.sum64_5_lo = function(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
                return al + bl + cl + dl + el >>> 0
            }
            ,
            exports.rotr64_hi = function(ah, al, num) {
                return (al << 32 - num | ah >>> num) >>> 0
            }
            ,
            exports.rotr64_lo = function(ah, al, num) {
                return (ah << 32 - num | al >>> num) >>> 0
            }
            ,
            exports.shr64_hi = function(ah, al, num) {
                return ah >>> num
            }
            ,
            exports.shr64_lo = function(ah, al, num) {
                return (ah << 32 - num | al >>> num) >>> 0
            }
        }
        ,
        2156: (module,__unused_webpack_exports,__webpack_require__)=>{
            "use strict";
            var hash = __webpack_require__(33715)
              , utils = __webpack_require__(34504)
              , assert = __webpack_require__(79746);
            function HmacDRBG(options) {
                if (!(this instanceof HmacDRBG))
                    return new HmacDRBG(options);
                this.hash = options.hash,
                this.predResist = !!options.predResist,
                this.outLen = this.hash.outSize,
                this.minEntropy = options.minEntropy || this.hash.hmacStrength,
                this._reseed = null,
                this.reseedInterval = null,
                this.K = null,
                this.V = null;
                var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex")
                  , nonce = utils.toArray(options.nonce, options.nonceEnc || "hex")
                  , pers = utils.toArray(options.pers, options.persEnc || "hex");
                assert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"),
                this._init(entropy, nonce, pers)
            }
            module.exports = HmacDRBG,
            HmacDRBG.prototype._init = function(entropy, nonce, pers) {
                var seed = entropy.concat(nonce).concat(pers);
                this.K = new Array(this.outLen / 8),
                this.V = new Array(this.outLen / 8);
                for (var i = 0; i < this.V.length; i++)
                    this.K[i] = 0,
                    this.V[i] = 1;
                this._update(seed),
                this._reseed = 1,
                this.reseedInterval = 281474976710656
            }
            ,
            HmacDRBG.prototype._hmac = function() {
                return new hash.hmac(this.hash,this.K)
            }
            ,
            HmacDRBG.prototype._update = function(seed) {
                var kmac = this._hmac().update(this.V).update([0]);
                seed && (kmac = kmac.update(seed)),
                this.K = kmac.digest(),
                this.V = this._hmac().update(this.V).digest(),
                seed && (this.K = this._hmac().update(this.V).update([1]).update(seed).digest(),
                this.V = this._hmac().update(this.V).digest())
            }
            ,
            HmacDRBG.prototype.reseed = function(entropy, entropyEnc, add, addEnc) {
                "string" != typeof entropyEnc && (addEnc = add,
                add = entropyEnc,
                entropyEnc = null),
                entropy = utils.toArray(entropy, entropyEnc),
                add = utils.toArray(add, addEnc),
                assert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"),
                this._update(entropy.concat(add || [])),
                this._reseed = 1
            }
            ,
            HmacDRBG.prototype.generate = function(len, enc, add, addEnc) {
                if (this._reseed > this.reseedInterval)
                    throw new Error("Reseed is required");
                "string" != typeof enc && (addEnc = add,
                add = enc,
                enc = null),
                add && (add = utils.toArray(add, addEnc || "hex"),
                this._update(add));
                for (var temp = []; temp.length < len; )
                    this.V = this._hmac().update(this.V).digest(),
                    temp = temp.concat(this.V);
                var res = temp.slice(0, len);
                return this._update(add),
                this._reseed++,
                utils.encode(res, enc)
            }
        }
        ,
        80645: (__unused_webpack_module,exports)=>{
            exports.read = function(buffer, offset, isLE, mLen, nBytes) {
                var e, m, eLen = 8 * nBytes - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, nBits = -7, i = isLE ? nBytes - 1 : 0, d = isLE ? -1 : 1, s = buffer[offset + i];
                for (i += d,
                e = s & (1 << -nBits) - 1,
                s >>= -nBits,
                nBits += eLen; nBits > 0; e = 256 * e + buffer[offset + i],
                i += d,
                nBits -= 8)
                    ;
                for (m = e & (1 << -nBits) - 1,
                e >>= -nBits,
                nBits += mLen; nBits > 0; m = 256 * m + buffer[offset + i],
                i += d,
                nBits -= 8)
                    ;
                if (0 === e)
                    e = 1 - eBias;
                else {
                    if (e === eMax)
                        return m ? NaN : 1 / 0 * (s ? -1 : 1);
                    m += Math.pow(2, mLen),
                    e -= eBias
                }
                return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
            }
            ,
            exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
                var e, m, c, eLen = 8 * nBytes - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, rt = 23 === mLen ? Math.pow(2, -24) - Math.pow(2, -77) : 0, i = isLE ? 0 : nBytes - 1, d = isLE ? 1 : -1, s = value < 0 || 0 === value && 1 / value < 0 ? 1 : 0;
                for (value = Math.abs(value),
                isNaN(value) || value === 1 / 0 ? (m = isNaN(value) ? 1 : 0,
                e = eMax) : (e = Math.floor(Math.log(value) / Math.LN2),
                value * (c = Math.pow(2, -e)) < 1 && (e--,
                c *= 2),
                (value += e + eBias >= 1 ? rt / c : rt * Math.pow(2, 1 - eBias)) * c >= 2 && (e++,
                c /= 2),
                e + eBias >= eMax ? (m = 0,
                e = eMax) : e + eBias >= 1 ? (m = (value * c - 1) * Math.pow(2, mLen),
                e += eBias) : (m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen),
                e = 0)); mLen >= 8; buffer[offset + i] = 255 & m,
                i += d,
                m /= 256,
                mLen -= 8)
                    ;
                for (e = e << mLen | m,
                eLen += mLen; eLen > 0; buffer[offset + i] = 255 & e,
                i += d,
                e /= 256,
                eLen -= 8)
                    ;
                buffer[offset + i - d] |= 128 * s
            }
        }
        ,
        35717: module=>{
            "function" == typeof Object.create ? module.exports = function(ctor, superCtor) {
                superCtor && (ctor.super_ = superCtor,
                ctor.prototype = Object.create(superCtor.prototype, {
                    constructor: {
                        value: ctor,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }))
            }
            : module.exports = function(ctor, superCtor) {
                if (superCtor) {
                    ctor.super_ = superCtor;
                    var TempCtor = function() {};
                    TempCtor.prototype = superCtor.prototype,
                    ctor.prototype = new TempCtor,
                    ctor.prototype.constructor = ctor
                }
            }
        }
        ,
        94301: (module,__unused_webpack_exports,__webpack_require__)=>{
            __webpack_require__(57147),
            module.exports = self.fetch.bind(self)
        }
        ,
        4400: (module,__unused_webpack_exports,__webpack_require__)=>{
            var json_stringify = __webpack_require__(54123).stringify
              , json_parse = __webpack_require__(26813);
            module.exports = function(options) {
                return {
                    parse: json_parse(options),
                    stringify: json_stringify
                }
            }
            ,
            module.exports.parse = json_parse(),
            module.exports.stringify = json_stringify
        }
        ,
        26813: (module,__unused_webpack_exports,__webpack_require__)=>{
            var BigNumber = null;
            const suspectProtoRx = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/
              , suspectConstructorRx = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/;
            module.exports = function(options) {
                "use strict";
                var _options = {
                    strict: !1,
                    storeAsString: !1,
                    alwaysParseAsBig: !1,
                    useNativeBigInt: !1,
                    protoAction: "error",
                    constructorAction: "error"
                };
                if (null != options) {
                    if (!0 === options.strict && (_options.strict = !0),
                    !0 === options.storeAsString && (_options.storeAsString = !0),
                    _options.alwaysParseAsBig = !0 === options.alwaysParseAsBig && options.alwaysParseAsBig,
                    _options.useNativeBigInt = !0 === options.useNativeBigInt && options.useNativeBigInt,
                    void 0 !== options.constructorAction) {
                        if ("error" !== options.constructorAction && "ignore" !== options.constructorAction && "preserve" !== options.constructorAction)
                            throw new Error(`Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${options.constructorAction}`);
                        _options.constructorAction = options.constructorAction
                    }
                    if (void 0 !== options.protoAction) {
                        if ("error" !== options.protoAction && "ignore" !== options.protoAction && "preserve" !== options.protoAction)
                            throw new Error(`Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${options.protoAction}`);
                        _options.protoAction = options.protoAction
                    }
                }
                var at, ch, text, value, escapee = {
                    '"': '"',
                    "\\": "\\",
                    "/": "/",
                    b: "\b",
                    f: "\f",
                    n: "\n",
                    r: "\r",
                    t: "\t"
                }, error = function(m) {
                    throw {
                        name: "SyntaxError",
                        message: m,
                        at,
                        text
                    }
                }, next = function(c) {
                    return c && c !== ch && error("Expected '" + c + "' instead of '" + ch + "'"),
                    ch = text.charAt(at),
                    at += 1,
                    ch
                }, number = function() {
                    var number, string = "";
                    for ("-" === ch && (string = "-",
                    next("-")); ch >= "0" && ch <= "9"; )
                        string += ch,
                        next();
                    if ("." === ch)
                        for (string += "."; next() && ch >= "0" && ch <= "9"; )
                            string += ch;
                    if ("e" === ch || "E" === ch)
                        for (string += ch,
                        next(),
                        "-" !== ch && "+" !== ch || (string += ch,
                        next()); ch >= "0" && ch <= "9"; )
                            string += ch,
                            next();
                    if (number = +string,
                    isFinite(number))
                        return null == BigNumber && (BigNumber = __webpack_require__(59487)),
                        string.length > 15 ? _options.storeAsString ? string : _options.useNativeBigInt ? BigInt(string) : new BigNumber(string) : _options.alwaysParseAsBig ? _options.useNativeBigInt ? BigInt(number) : new BigNumber(number) : number;
                    error("Bad number")
                }, string = function() {
                    var hex, i, uffff, string = "";
                    if ('"' === ch)
                        for (var startAt = at; next(); ) {
                            if ('"' === ch)
                                return at - 1 > startAt && (string += text.substring(startAt, at - 1)),
                                next(),
                                string;
                            if ("\\" === ch) {
                                if (at - 1 > startAt && (string += text.substring(startAt, at - 1)),
                                next(),
                                "u" === ch) {
                                    for (uffff = 0,
                                    i = 0; i < 4 && (hex = parseInt(next(), 16),
                                    isFinite(hex)); i += 1)
                                        uffff = 16 * uffff + hex;
                                    string += String.fromCharCode(uffff)
                                } else {
                                    if ("string" != typeof escapee[ch])
                                        break;
                                    string += escapee[ch]
                                }
                                startAt = at
                            }
                        }
                    error("Bad string")
                }, white = function() {
                    for (; ch && ch <= " "; )
                        next()
                };
                return value = function() {
                    switch (white(),
                    ch) {
                    case "{":
                        return function() {
                            var key, object = Object.create(null);
                            if ("{" === ch) {
                                if (next("{"),
                                white(),
                                "}" === ch)
                                    return next("}"),
                                    object;
                                for (; ch; ) {
                                    if (key = string(),
                                    white(),
                                    next(":"),
                                    !0 === _options.strict && Object.hasOwnProperty.call(object, key) && error('Duplicate key "' + key + '"'),
                                    !0 === suspectProtoRx.test(key) ? "error" === _options.protoAction ? error("Object contains forbidden prototype property") : "ignore" === _options.protoAction ? value() : object[key] = value() : !0 === suspectConstructorRx.test(key) ? "error" === _options.constructorAction ? error("Object contains forbidden constructor property") : "ignore" === _options.constructorAction ? value() : object[key] = value() : object[key] = value(),
                                    white(),
                                    "}" === ch)
                                        return next("}"),
                                        object;
                                    next(","),
                                    white()
                                }
                            }
                            error("Bad object")
                        }();
                    case "[":
                        return function() {
                            var array = [];
                            if ("[" === ch) {
                                if (next("["),
                                white(),
                                "]" === ch)
                                    return next("]"),
                                    array;
                                for (; ch; ) {
                                    if (array.push(value()),
                                    white(),
                                    "]" === ch)
                                        return next("]"),
                                        array;
                                    next(","),
                                    white()
                                }
                            }
                            error("Bad array")
                        }();
                    case '"':
                        return string();
                    case "-":
                        return number();
                    default:
                        return ch >= "0" && ch <= "9" ? number() : function() {
                            switch (ch) {
                            case "t":
                                return next("t"),
                                next("r"),
                                next("u"),
                                next("e"),
                                !0;
                            case "f":
                                return next("f"),
                                next("a"),
                                next("l"),
                                next("s"),
                                next("e"),
                                !1;
                            case "n":
                                return next("n"),
                                next("u"),
                                next("l"),
                                next("l"),
                                null
                            }
                            error("Unexpected '" + ch + "'")
                        }()
                    }
                }
                ,
                function(source, reviver) {
                    var result;
                    return text = source + "",
                    at = 0,
                    ch = " ",
                    result = value(),
                    white(),
                    ch && error("Syntax error"),
                    "function" == typeof reviver ? function walk(holder, key) {
                        var v, value = holder[key];
                        return value && "object" == typeof value && Object.keys(value).forEach((function(k) {
                            void 0 !== (v = walk(value, k)) ? value[k] = v : delete value[k]
                        }
                        )),
                        reviver.call(holder, key, value)
                    }({
                        "": result
                    }, "") : result
                }
            }
        }
        ,
        54123: (module,__unused_webpack_exports,__webpack_require__)=>{
            var BigNumber = __webpack_require__(59487)
              , JSON = module.exports;
            !function() {
                "use strict";
                var gap, indent, rep, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, meta = {
                    "\b": "\\b",
                    "\t": "\\t",
                    "\n": "\\n",
                    "\f": "\\f",
                    "\r": "\\r",
                    '"': '\\"',
                    "\\": "\\\\"
                };
                function quote(string) {
                    return escapable.lastIndex = 0,
                    escapable.test(string) ? '"' + string.replace(escapable, (function(a) {
                        var c = meta[a];
                        return "string" == typeof c ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4)
                    }
                    )) + '"' : '"' + string + '"'
                }
                function str(key, holder) {
                    var i, k, v, length, partial, mind = gap, value = holder[key], isBigNumber = null != value && (value instanceof BigNumber || BigNumber.isBigNumber(value));
                    switch (value && "object" == typeof value && "function" == typeof value.toJSON && (value = value.toJSON(key)),
                    "function" == typeof rep && (value = rep.call(holder, key, value)),
                    typeof value) {
                    case "string":
                        return isBigNumber ? value : quote(value);
                    case "number":
                        return isFinite(value) ? String(value) : "null";
                    case "boolean":
                    case "null":
                    case "bigint":
                        return String(value);
                    case "object":
                        if (!value)
                            return "null";
                        if (gap += indent,
                        partial = [],
                        "[object Array]" === Object.prototype.toString.apply(value)) {
                            for (length = value.length,
                            i = 0; i < length; i += 1)
                                partial[i] = str(i, value) || "null";
                            return v = 0 === partial.length ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]",
                            gap = mind,
                            v
                        }
                        if (rep && "object" == typeof rep)
                            for (length = rep.length,
                            i = 0; i < length; i += 1)
                                "string" == typeof rep[i] && (v = str(k = rep[i], value)) && partial.push(quote(k) + (gap ? ": " : ":") + v);
                        else
                            Object.keys(value).forEach((function(k) {
                                var v = str(k, value);
                                v && partial.push(quote(k) + (gap ? ": " : ":") + v)
                            }
                            ));
                        return v = 0 === partial.length ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}",
                        gap = mind,
                        v
                    }
                }
                "function" != typeof JSON.stringify && (JSON.stringify = function(value, replacer, space) {
                    var i;
                    if (gap = "",
                    indent = "",
                    "number" == typeof space)
                        for (i = 0; i < space; i += 1)
                            indent += " ";
                    else
                        "string" == typeof space && (indent = space);
                    if (rep = replacer,
                    replacer && "function" != typeof replacer && ("object" != typeof replacer || "number" != typeof replacer.length))
                        throw new Error("JSON.stringify");
                    return str("", {
                        "": value
                    })
                }
                )
            }()
        }
        ,
        59487: function(module, exports, __webpack_require__) {
            var __WEBPACK_AMD_DEFINE_RESULT__;
            !function(globalObject) {
                "use strict";
                var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], MAX = 1e9;
                function bitFloor(n) {
                    var i = 0 | n;
                    return n > 0 || n === i ? i : i - 1
                }
                function coeffToString(a) {
                    for (var s, z, i = 1, j = a.length, r = a[0] + ""; i < j; ) {
                        for (s = a[i++] + "",
                        z = LOG_BASE - s.length; z--; s = "0" + s)
                            ;
                        r += s
                    }
                    for (j = r.length; 48 === r.charCodeAt(--j); )
                        ;
                    return r.slice(0, j + 1 || 1)
                }
                function compare(x, y) {
                    var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
                    if (!i || !j)
                        return null;
                    if (a = xc && !xc[0],
                    b = yc && !yc[0],
                    a || b)
                        return a ? b ? 0 : -j : i;
                    if (i != j)
                        return i;
                    if (a = i < 0,
                    b = k == l,
                    !xc || !yc)
                        return b ? 0 : !xc ^ a ? 1 : -1;
                    if (!b)
                        return k > l ^ a ? 1 : -1;
                    for (j = (k = xc.length) < (l = yc.length) ? k : l,
                    i = 0; i < j; i++)
                        if (xc[i] != yc[i])
                            return xc[i] > yc[i] ^ a ? 1 : -1;
                    return k == l ? 0 : k > l ^ a ? 1 : -1
                }
                function intCheck(n, min, max, name) {
                    if (n < min || n > max || n !== mathfloor(n))
                        throw Error(bignumberError + (name || "Argument") + ("number" == typeof n ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n))
                }
                function isOdd(n) {
                    var k = n.c.length - 1;
                    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0
                }
                function toExponential(str, e) {
                    return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e
                }
                function toFixedPoint(str, e, z) {
                    var len, zs;
                    if (e < 0) {
                        for (zs = z + "."; ++e; zs += z)
                            ;
                        str = zs + str
                    } else if (++e > (len = str.length)) {
                        for (zs = z,
                        e -= len; --e; zs += z)
                            ;
                        str += zs
                    } else
                        e < len && (str = str.slice(0, e) + "." + str.slice(e));
                    return str
                }
                BigNumber = function clone(configObject) {
                    var div, convertBase, parseNumeric, random53bitInt, basePrefix, dotAfter, dotBefore, isInfinityOrNaN, whitespaceOrPlus, P = BigNumber.prototype = {
                        constructor: BigNumber,
                        toString: null,
                        valueOf: null
                    }, ONE = new BigNumber(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = !1, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
                        prefix: "",
                        groupSize: 3,
                        secondaryGroupSize: 0,
                        groupSeparator: ",",
                        decimalSeparator: ".",
                        fractionGroupSize: 0,
                        fractionGroupSeparator: " ",
                        suffix: ""
                    }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = !0;
                    function BigNumber(v, b) {
                        var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
                        if (!(x instanceof BigNumber))
                            return new BigNumber(v,b);
                        if (null == b) {
                            if (v && !0 === v._isBigNumber)
                                return x.s = v.s,
                                void (!v.c || v.e > MAX_EXP ? x.c = x.e = null : v.e < MIN_EXP ? x.c = [x.e = 0] : (x.e = v.e,
                                x.c = v.c.slice()));
                            if ((isNum = "number" == typeof v) && 0 * v == 0) {
                                if (x.s = 1 / v < 0 ? (v = -v,
                                -1) : 1,
                                v === ~~v) {
                                    for (e = 0,
                                    i = v; i >= 10; i /= 10,
                                    e++)
                                        ;
                                    return void (e > MAX_EXP ? x.c = x.e = null : (x.e = e,
                                    x.c = [v]))
                                }
                                str = String(v)
                            } else {
                                if (!isNumeric.test(str = String(v)))
                                    return parseNumeric(x, str, isNum);
                                x.s = 45 == str.charCodeAt(0) ? (str = str.slice(1),
                                -1) : 1
                            }
                            (e = str.indexOf(".")) > -1 && (str = str.replace(".", "")),
                            (i = str.search(/e/i)) > 0 ? (e < 0 && (e = i),
                            e += +str.slice(i + 1),
                            str = str.substring(0, i)) : e < 0 && (e = str.length)
                        } else {
                            if (intCheck(b, 2, ALPHABET.length, "Base"),
                            10 == b && alphabetHasNormalDecimalDigits)
                                return round(x = new BigNumber(v), DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
                            if (str = String(v),
                            isNum = "number" == typeof v) {
                                if (0 * v != 0)
                                    return parseNumeric(x, str, isNum, b);
                                if (x.s = 1 / v < 0 ? (str = str.slice(1),
                                -1) : 1,
                                BigNumber.DEBUG && str.replace(/^0\.0*|\./, "").length > 15)
                                    throw Error(tooManyDigits + v)
                            } else
                                x.s = 45 === str.charCodeAt(0) ? (str = str.slice(1),
                                -1) : 1;
                            for (alphabet = ALPHABET.slice(0, b),
                            e = i = 0,
                            len = str.length; i < len; i++)
                                if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                                    if ("." == c) {
                                        if (i > e) {
                                            e = len;
                                            continue
                                        }
                                    } else if (!caseChanged && (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase()))) {
                                        caseChanged = !0,
                                        i = -1,
                                        e = 0;
                                        continue
                                    }
                                    return parseNumeric(x, String(v), isNum, b)
                                }
                            isNum = !1,
                            (e = (str = convertBase(str, b, 10, x.s)).indexOf(".")) > -1 ? str = str.replace(".", "") : e = str.length
                        }
                        for (i = 0; 48 === str.charCodeAt(i); i++)
                            ;
                        for (len = str.length; 48 === str.charCodeAt(--len); )
                            ;
                        if (str = str.slice(i, ++len)) {
                            if (len -= i,
                            isNum && BigNumber.DEBUG && len > 15 && (v > 9007199254740991 || v !== mathfloor(v)))
                                throw Error(tooManyDigits + x.s * v);
                            if ((e = e - i - 1) > MAX_EXP)
                                x.c = x.e = null;
                            else if (e < MIN_EXP)
                                x.c = [x.e = 0];
                            else {
                                if (x.e = e,
                                x.c = [],
                                i = (e + 1) % LOG_BASE,
                                e < 0 && (i += LOG_BASE),
                                i < len) {
                                    for (i && x.c.push(+str.slice(0, i)),
                                    len -= LOG_BASE; i < len; )
                                        x.c.push(+str.slice(i, i += LOG_BASE));
                                    i = LOG_BASE - (str = str.slice(i)).length
                                } else
                                    i -= len;
                                for (; i--; str += "0")
                                    ;
                                x.c.push(+str)
                            }
                        } else
                            x.c = [x.e = 0]
                    }
                    function format(n, i, rm, id) {
                        var c0, e, ne, len, str;
                        if (null == rm ? rm = ROUNDING_MODE : intCheck(rm, 0, 8),
                        !n.c)
                            return n.toString();
                        if (c0 = n.c[0],
                        ne = n.e,
                        null == i)
                            str = coeffToString(n.c),
                            str = 1 == id || 2 == id && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
                        else if (e = (n = round(new BigNumber(n), i, rm)).e,
                        len = (str = coeffToString(n.c)).length,
                        1 == id || 2 == id && (i <= e || e <= TO_EXP_NEG)) {
                            for (; len < i; str += "0",
                            len++)
                                ;
                            str = toExponential(str, e)
                        } else if (i -= ne,
                        str = toFixedPoint(str, e, "0"),
                        e + 1 > len) {
                            if (--i > 0)
                                for (str += "."; i--; str += "0")
                                    ;
                        } else if ((i += e - len) > 0)
                            for (e + 1 == len && (str += "."); i--; str += "0")
                                ;
                        return n.s < 0 && c0 ? "-" + str : str
                    }
                    function maxOrMin(args, n) {
                        for (var k, y, i = 1, x = new BigNumber(args[0]); i < args.length; i++)
                            (!(y = new BigNumber(args[i])).s || (k = compare(x, y)) === n || 0 === k && x.s === n) && (x = y);
                        return x
                    }
                    function normalise(n, c, e) {
                        for (var i = 1, j = c.length; !c[--j]; c.pop())
                            ;
                        for (j = c[0]; j >= 10; j /= 10,
                        i++)
                            ;
                        return (e = i + e * LOG_BASE - 1) > MAX_EXP ? n.c = n.e = null : e < MIN_EXP ? n.c = [n.e = 0] : (n.e = e,
                        n.c = c),
                        n
                    }
                    function round(x, sd, rm, r) {
                        var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
                        if (xc) {
                            out: {
                                for (d = 1,
                                k = xc[0]; k >= 10; k /= 10,
                                d++)
                                    ;
                                if ((i = sd - d) < 0)
                                    i += LOG_BASE,
                                    j = sd,
                                    n = xc[ni = 0],
                                    rd = mathfloor(n / pows10[d - j - 1] % 10);
                                else if ((ni = mathceil((i + 1) / LOG_BASE)) >= xc.length) {
                                    if (!r)
                                        break out;
                                    for (; xc.length <= ni; xc.push(0))
                                        ;
                                    n = rd = 0,
                                    d = 1,
                                    j = (i %= LOG_BASE) - LOG_BASE + 1
                                } else {
                                    for (n = k = xc[ni],
                                    d = 1; k >= 10; k /= 10,
                                    d++)
                                        ;
                                    rd = (j = (i %= LOG_BASE) - LOG_BASE + d) < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10)
                                }
                                if (r = r || sd < 0 || null != xc[ni + 1] || (j < 0 ? n : n % pows10[d - j - 1]),
                                r = rm < 4 ? (rd || r) && (0 == rm || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || 5 == rd && (4 == rm || r || 6 == rm && (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7)),
                                sd < 1 || !xc[0])
                                    return xc.length = 0,
                                    r ? (sd -= x.e + 1,
                                    xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE],
                                    x.e = -sd || 0) : xc[0] = x.e = 0,
                                    x;
                                if (0 == i ? (xc.length = ni,
                                k = 1,
                                ni--) : (xc.length = ni + 1,
                                k = pows10[LOG_BASE - i],
                                xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0),
                                r)
                                    for (; ; ) {
                                        if (0 == ni) {
                                            for (i = 1,
                                            j = xc[0]; j >= 10; j /= 10,
                                            i++)
                                                ;
                                            for (j = xc[0] += k,
                                            k = 1; j >= 10; j /= 10,
                                            k++)
                                                ;
                                            i != k && (x.e++,
                                            xc[0] == BASE && (xc[0] = 1));
                                            break
                                        }
                                        if (xc[ni] += k,
                                        xc[ni] != BASE)
                                            break;
                                        xc[ni--] = 0,
                                        k = 1
                                    }
                                for (i = xc.length; 0 === xc[--i]; xc.pop())
                                    ;
                            }
                            x.e > MAX_EXP ? x.c = x.e = null : x.e < MIN_EXP && (x.c = [x.e = 0])
                        }
                        return x
                    }
                    function valueOf(n) {
                        var str, e = n.e;
                        return null === e ? n.toString() : (str = coeffToString(n.c),
                        str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0"),
                        n.s < 0 ? "-" + str : str)
                    }
                    return BigNumber.clone = clone,
                    BigNumber.ROUND_UP = 0,
                    BigNumber.ROUND_DOWN = 1,
                    BigNumber.ROUND_CEIL = 2,
                    BigNumber.ROUND_FLOOR = 3,
                    BigNumber.ROUND_HALF_UP = 4,
                    BigNumber.ROUND_HALF_DOWN = 5,
                    BigNumber.ROUND_HALF_EVEN = 6,
                    BigNumber.ROUND_HALF_CEIL = 7,
                    BigNumber.ROUND_HALF_FLOOR = 8,
                    BigNumber.EUCLID = 9,
                    BigNumber.config = BigNumber.set = function(obj) {
                        var p, v;
                        if (null != obj) {
                            if ("object" != typeof obj)
                                throw Error(bignumberError + "Object expected: " + obj);
                            if (obj.hasOwnProperty(p = "DECIMAL_PLACES") && (intCheck(v = obj[p], 0, MAX, p),
                            DECIMAL_PLACES = v),
                            obj.hasOwnProperty(p = "ROUNDING_MODE") && (intCheck(v = obj[p], 0, 8, p),
                            ROUNDING_MODE = v),
                            obj.hasOwnProperty(p = "EXPONENTIAL_AT") && ((v = obj[p]) && v.pop ? (intCheck(v[0], -MAX, 0, p),
                            intCheck(v[1], 0, MAX, p),
                            TO_EXP_NEG = v[0],
                            TO_EXP_POS = v[1]) : (intCheck(v, -MAX, MAX, p),
                            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v))),
                            obj.hasOwnProperty(p = "RANGE"))
                                if ((v = obj[p]) && v.pop)
                                    intCheck(v[0], -MAX, -1, p),
                                    intCheck(v[1], 1, MAX, p),
                                    MIN_EXP = v[0],
                                    MAX_EXP = v[1];
                                else {
                                    if (intCheck(v, -MAX, MAX, p),
                                    !v)
                                        throw Error(bignumberError + p + " cannot be zero: " + v);
                                    MIN_EXP = -(MAX_EXP = v < 0 ? -v : v)
                                }
                            if (obj.hasOwnProperty(p = "CRYPTO")) {
                                if ((v = obj[p]) !== !!v)
                                    throw Error(bignumberError + p + " not true or false: " + v);
                                if (v) {
                                    if ("undefined" == typeof crypto || !crypto || !crypto.getRandomValues && !crypto.randomBytes)
                                        throw CRYPTO = !v,
                                        Error(bignumberError + "crypto unavailable");
                                    CRYPTO = v
                                } else
                                    CRYPTO = v
                            }
                            if (obj.hasOwnProperty(p = "MODULO_MODE") && (intCheck(v = obj[p], 0, 9, p),
                            MODULO_MODE = v),
                            obj.hasOwnProperty(p = "POW_PRECISION") && (intCheck(v = obj[p], 0, MAX, p),
                            POW_PRECISION = v),
                            obj.hasOwnProperty(p = "FORMAT")) {
                                if ("object" != typeof (v = obj[p]))
                                    throw Error(bignumberError + p + " not an object: " + v);
                                FORMAT = v
                            }
                            if (obj.hasOwnProperty(p = "ALPHABET")) {
                                if ("string" != typeof (v = obj[p]) || /^.?$|[+\-.\s]|(.).*\1/.test(v))
                                    throw Error(bignumberError + p + " invalid: " + v);
                                alphabetHasNormalDecimalDigits = "0123456789" == v.slice(0, 10),
                                ALPHABET = v
                            }
                        }
                        return {
                            DECIMAL_PLACES,
                            ROUNDING_MODE,
                            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
                            RANGE: [MIN_EXP, MAX_EXP],
                            CRYPTO,
                            MODULO_MODE,
                            POW_PRECISION,
                            FORMAT,
                            ALPHABET
                        }
                    }
                    ,
                    BigNumber.isBigNumber = function(v) {
                        if (!v || !0 !== v._isBigNumber)
                            return !1;
                        if (!BigNumber.DEBUG)
                            return !0;
                        var i, n, c = v.c, e = v.e, s = v.s;
                        out: if ("[object Array]" == {}.toString.call(c)) {
                            if ((1 === s || -1 === s) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
                                if (0 === c[0]) {
                                    if (0 === e && 1 === c.length)
                                        return !0;
                                    break out
                                }
                                if ((i = (e + 1) % LOG_BASE) < 1 && (i += LOG_BASE),
                                String(c[0]).length == i) {
                                    for (i = 0; i < c.length; i++)
                                        if ((n = c[i]) < 0 || n >= BASE || n !== mathfloor(n))
                                            break out;
                                    if (0 !== n)
                                        return !0
                                }
                            }
                        } else if (null === c && null === e && (null === s || 1 === s || -1 === s))
                            return !0;
                        throw Error(bignumberError + "Invalid BigNumber: " + v)
                    }
                    ,
                    BigNumber.maximum = BigNumber.max = function() {
                        return maxOrMin(arguments, -1)
                    }
                    ,
                    BigNumber.minimum = BigNumber.min = function() {
                        return maxOrMin(arguments, 1)
                    }
                    ,
                    BigNumber.random = (random53bitInt = 9007199254740992 * Math.random() & 2097151 ? function() {
                        return mathfloor(9007199254740992 * Math.random())
                    }
                    : function() {
                        return 8388608 * (1073741824 * Math.random() | 0) + (8388608 * Math.random() | 0)
                    }
                    ,
                    function(dp) {
                        var a, b, e, k, v, i = 0, c = [], rand = new BigNumber(ONE);
                        if (null == dp ? dp = DECIMAL_PLACES : intCheck(dp, 0, MAX),
                        k = mathceil(dp / LOG_BASE),
                        CRYPTO)
                            if (crypto.getRandomValues) {
                                for (a = crypto.getRandomValues(new Uint32Array(k *= 2)); i < k; )
                                    (v = 131072 * a[i] + (a[i + 1] >>> 11)) >= 9e15 ? (b = crypto.getRandomValues(new Uint32Array(2)),
                                    a[i] = b[0],
                                    a[i + 1] = b[1]) : (c.push(v % 1e14),
                                    i += 2);
                                i = k / 2
                            } else {
                                if (!crypto.randomBytes)
                                    throw CRYPTO = !1,
                                    Error(bignumberError + "crypto unavailable");
                                for (a = crypto.randomBytes(k *= 7); i < k; )
                                    (v = 281474976710656 * (31 & a[i]) + 1099511627776 * a[i + 1] + 4294967296 * a[i + 2] + 16777216 * a[i + 3] + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6]) >= 9e15 ? crypto.randomBytes(7).copy(a, i) : (c.push(v % 1e14),
                                    i += 7);
                                i = k / 7
                            }
                        if (!CRYPTO)
                            for (; i < k; )
                                (v = random53bitInt()) < 9e15 && (c[i++] = v % 1e14);
                        for (k = c[--i],
                        dp %= LOG_BASE,
                        k && dp && (v = POWS_TEN[LOG_BASE - dp],
                        c[i] = mathfloor(k / v) * v); 0 === c[i]; c.pop(),
                        i--)
                            ;
                        if (i < 0)
                            c = [e = 0];
                        else {
                            for (e = -1; 0 === c[0]; c.splice(0, 1),
                            e -= LOG_BASE)
                                ;
                            for (i = 1,
                            v = c[0]; v >= 10; v /= 10,
                            i++)
                                ;
                            i < LOG_BASE && (e -= LOG_BASE - i)
                        }
                        return rand.e = e,
                        rand.c = c,
                        rand
                    }
                    ),
                    BigNumber.sum = function() {
                        for (var i = 1, args = arguments, sum = new BigNumber(args[0]); i < args.length; )
                            sum = sum.plus(args[i++]);
                        return sum
                    }
                    ,
                    convertBase = function() {
                        function toBaseOut(str, baseIn, baseOut, alphabet) {
                            for (var j, arrL, arr = [0], i = 0, len = str.length; i < len; ) {
                                for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
                                    ;
                                for (arr[0] += alphabet.indexOf(str.charAt(i++)),
                                j = 0; j < arr.length; j++)
                                    arr[j] > baseOut - 1 && (null == arr[j + 1] && (arr[j + 1] = 0),
                                    arr[j + 1] += arr[j] / baseOut | 0,
                                    arr[j] %= baseOut)
                            }
                            return arr.reverse()
                        }
                        return function(str, baseIn, baseOut, sign, callerIsToString) {
                            var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
                            for (i >= 0 && (k = POW_PRECISION,
                            POW_PRECISION = 0,
                            str = str.replace(".", ""),
                            x = (y = new BigNumber(baseIn)).pow(str.length - i),
                            POW_PRECISION = k,
                            y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, "0"), 10, baseOut, "0123456789"),
                            y.e = y.c.length),
                            e = k = (xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET,
                            "0123456789") : (alphabet = "0123456789",
                            ALPHABET))).length; 0 == xc[--k]; xc.pop())
                                ;
                            if (!xc[0])
                                return alphabet.charAt(0);
                            if (i < 0 ? --e : (x.c = xc,
                            x.e = e,
                            x.s = sign,
                            xc = (x = div(x, y, dp, rm, baseOut)).c,
                            r = x.r,
                            e = x.e),
                            i = xc[d = e + dp + 1],
                            k = baseOut / 2,
                            r = r || d < 0 || null != xc[d + 1],
                            r = rm < 4 ? (null != i || r) && (0 == rm || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (4 == rm || r || 6 == rm && 1 & xc[d - 1] || rm == (x.s < 0 ? 8 : 7)),
                            d < 1 || !xc[0])
                                str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
                            else {
                                if (xc.length = d,
                                r)
                                    for (--baseOut; ++xc[--d] > baseOut; )
                                        xc[d] = 0,
                                        d || (++e,
                                        xc = [1].concat(xc));
                                for (k = xc.length; !xc[--k]; )
                                    ;
                                for (i = 0,
                                str = ""; i <= k; str += alphabet.charAt(xc[i++]))
                                    ;
                                str = toFixedPoint(str, e, alphabet.charAt(0))
                            }
                            return str
                        }
                    }(),
                    div = function() {
                        function multiply(x, k, base) {
                            var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % 1e7, khi = k / 1e7 | 0;
                            for (x = x.slice(); i--; )
                                carry = ((temp = klo * (xlo = x[i] % 1e7) + (m = khi * xlo + (xhi = x[i] / 1e7 | 0) * klo) % 1e7 * 1e7 + carry) / base | 0) + (m / 1e7 | 0) + khi * xhi,
                                x[i] = temp % base;
                            return carry && (x = [carry].concat(x)),
                            x
                        }
                        function compare(a, b, aL, bL) {
                            var i, cmp;
                            if (aL != bL)
                                cmp = aL > bL ? 1 : -1;
                            else
                                for (i = cmp = 0; i < aL; i++)
                                    if (a[i] != b[i]) {
                                        cmp = a[i] > b[i] ? 1 : -1;
                                        break
                                    }
                            return cmp
                        }
                        function subtract(a, b, aL, base) {
                            for (var i = 0; aL--; )
                                a[aL] -= i,
                                i = a[aL] < b[aL] ? 1 : 0,
                                a[aL] = i * base + a[aL] - b[aL];
                            for (; !a[0] && a.length > 1; a.splice(0, 1))
                                ;
                        }
                        return function(x, y, dp, rm, base) {
                            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
                            if (!(xc && xc[0] && yc && yc[0]))
                                return new BigNumber(x.s && y.s && (xc ? !yc || xc[0] != yc[0] : yc) ? xc && 0 == xc[0] || !yc ? 0 * s : s / 0 : NaN);
                            for (qc = (q = new BigNumber(s)).c = [],
                            s = dp + (e = x.e - y.e) + 1,
                            base || (base = BASE,
                            e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE),
                            s = s / LOG_BASE | 0),
                            i = 0; yc[i] == (xc[i] || 0); i++)
                                ;
                            if (yc[i] > (xc[i] || 0) && e--,
                            s < 0)
                                qc.push(1),
                                more = !0;
                            else {
                                for (xL = xc.length,
                                yL = yc.length,
                                i = 0,
                                s += 2,
                                (n = mathfloor(base / (yc[0] + 1))) > 1 && (yc = multiply(yc, n, base),
                                xc = multiply(xc, n, base),
                                yL = yc.length,
                                xL = xc.length),
                                xi = yL,
                                remL = (rem = xc.slice(0, yL)).length; remL < yL; rem[remL++] = 0)
                                    ;
                                yz = yc.slice(),
                                yz = [0].concat(yz),
                                yc0 = yc[0],
                                yc[1] >= base / 2 && yc0++;
                                do {
                                    if (n = 0,
                                    (cmp = compare(yc, rem, yL, remL)) < 0) {
                                        if (rem0 = rem[0],
                                        yL != remL && (rem0 = rem0 * base + (rem[1] || 0)),
                                        (n = mathfloor(rem0 / yc0)) > 1)
                                            for (n >= base && (n = base - 1),
                                            prodL = (prod = multiply(yc, n, base)).length,
                                            remL = rem.length; 1 == compare(prod, rem, prodL, remL); )
                                                n--,
                                                subtract(prod, yL < prodL ? yz : yc, prodL, base),
                                                prodL = prod.length,
                                                cmp = 1;
                                        else
                                            0 == n && (cmp = n = 1),
                                            prodL = (prod = yc.slice()).length;
                                        if (prodL < remL && (prod = [0].concat(prod)),
                                        subtract(rem, prod, remL, base),
                                        remL = rem.length,
                                        -1 == cmp)
                                            for (; compare(yc, rem, yL, remL) < 1; )
                                                n++,
                                                subtract(rem, yL < remL ? yz : yc, remL, base),
                                                remL = rem.length
                                    } else
                                        0 === cmp && (n++,
                                        rem = [0]);
                                    qc[i++] = n,
                                    rem[0] ? rem[remL++] = xc[xi] || 0 : (rem = [xc[xi]],
                                    remL = 1)
                                } while ((xi++ < xL || null != rem[0]) && s--);
                                more = null != rem[0],
                                qc[0] || qc.splice(0, 1)
                            }
                            if (base == BASE) {
                                for (i = 1,
                                s = qc[0]; s >= 10; s /= 10,
                                i++)
                                    ;
                                round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more)
                            } else
                                q.e = e,
                                q.r = +more;
                            return q
                        }
                    }(),
                    basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
                    dotAfter = /^([^.]+)\.$/,
                    dotBefore = /^\.([^.]+)$/,
                    isInfinityOrNaN = /^-?(Infinity|NaN)$/,
                    whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g,
                    parseNumeric = function(x, str, isNum, b) {
                        var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
                        if (isInfinityOrNaN.test(s))
                            x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
                        else {
                            if (!isNum && (s = s.replace(basePrefix, (function(m, p1, p2) {
                                return base = "x" == (p2 = p2.toLowerCase()) ? 16 : "b" == p2 ? 2 : 8,
                                b && b != base ? m : p1
                            }
                            )),
                            b && (base = b,
                            s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1")),
                            str != s))
                                return new BigNumber(s,base);
                            if (BigNumber.DEBUG)
                                throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
                            x.s = null
                        }
                        x.c = x.e = null
                    }
                    ,
                    P.absoluteValue = P.abs = function() {
                        var x = new BigNumber(this);
                        return x.s < 0 && (x.s = 1),
                        x
                    }
                    ,
                    P.comparedTo = function(y, b) {
                        return compare(this, new BigNumber(y,b))
                    }
                    ,
                    P.decimalPlaces = P.dp = function(dp, rm) {
                        var c, n, v, x = this;
                        if (null != dp)
                            return intCheck(dp, 0, MAX),
                            null == rm ? rm = ROUNDING_MODE : intCheck(rm, 0, 8),
                            round(new BigNumber(x), dp + x.e + 1, rm);
                        if (!(c = x.c))
                            return null;
                        if (n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE,
                        v = c[v])
                            for (; v % 10 == 0; v /= 10,
                            n--)
                                ;
                        return n < 0 && (n = 0),
                        n
                    }
                    ,
                    P.dividedBy = P.div = function(y, b) {
                        return div(this, new BigNumber(y,b), DECIMAL_PLACES, ROUNDING_MODE)
                    }
                    ,
                    P.dividedToIntegerBy = P.idiv = function(y, b) {
                        return div(this, new BigNumber(y,b), 0, 1)
                    }
                    ,
                    P.exponentiatedBy = P.pow = function(n, m) {
                        var half, isModExp, i, k, nIsBig, nIsNeg, nIsOdd, y, x = this;
                        if ((n = new BigNumber(n)).c && !n.isInteger())
                            throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
                        if (null != m && (m = new BigNumber(m)),
                        nIsBig = n.e > 14,
                        !x.c || !x.c[0] || 1 == x.c[0] && !x.e && 1 == x.c.length || !n.c || !n.c[0])
                            return y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n))),
                            m ? y.mod(m) : y;
                        if (nIsNeg = n.s < 0,
                        m) {
                            if (m.c ? !m.c[0] : !m.s)
                                return new BigNumber(NaN);
                            (isModExp = !nIsNeg && x.isInteger() && m.isInteger()) && (x = x.mod(m))
                        } else {
                            if (n.e > 9 && (x.e > 0 || x.e < -1 || (0 == x.e ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7)))
                                return k = x.s < 0 && isOdd(n) ? -0 : 0,
                                x.e > -1 && (k = 1 / k),
                                new BigNumber(nIsNeg ? 1 / k : k);
                            POW_PRECISION && (k = mathceil(POW_PRECISION / LOG_BASE + 2))
                        }
                        for (nIsBig ? (half = new BigNumber(.5),
                        nIsNeg && (n.s = 1),
                        nIsOdd = isOdd(n)) : nIsOdd = (i = Math.abs(+valueOf(n))) % 2,
                        y = new BigNumber(ONE); ; ) {
                            if (nIsOdd) {
                                if (!(y = y.times(x)).c)
                                    break;
                                k ? y.c.length > k && (y.c.length = k) : isModExp && (y = y.mod(m))
                            }
                            if (i) {
                                if (0 === (i = mathfloor(i / 2)))
                                    break;
                                nIsOdd = i % 2
                            } else if (round(n = n.times(half), n.e + 1, 1),
                            n.e > 14)
                                nIsOdd = isOdd(n);
                            else {
                                if (0 === (i = +valueOf(n)))
                                    break;
                                nIsOdd = i % 2
                            }
                            x = x.times(x),
                            k ? x.c && x.c.length > k && (x.c.length = k) : isModExp && (x = x.mod(m))
                        }
                        return isModExp ? y : (nIsNeg && (y = ONE.div(y)),
                        m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, undefined) : y)
                    }
                    ,
                    P.integerValue = function(rm) {
                        var n = new BigNumber(this);
                        return null == rm ? rm = ROUNDING_MODE : intCheck(rm, 0, 8),
                        round(n, n.e + 1, rm)
                    }
                    ,
                    P.isEqualTo = P.eq = function(y, b) {
                        return 0 === compare(this, new BigNumber(y,b))
                    }
                    ,
                    P.isFinite = function() {
                        return !!this.c
                    }
                    ,
                    P.isGreaterThan = P.gt = function(y, b) {
                        return compare(this, new BigNumber(y,b)) > 0
                    }
                    ,
                    P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
                        return 1 === (b = compare(this, new BigNumber(y,b))) || 0 === b
                    }
                    ,
                    P.isInteger = function() {
                        return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2
                    }
                    ,
                    P.isLessThan = P.lt = function(y, b) {
                        return compare(this, new BigNumber(y,b)) < 0
                    }
                    ,
                    P.isLessThanOrEqualTo = P.lte = function(y, b) {
                        return -1 === (b = compare(this, new BigNumber(y,b))) || 0 === b
                    }
                    ,
                    P.isNaN = function() {
                        return !this.s
                    }
                    ,
                    P.isNegative = function() {
                        return this.s < 0
                    }
                    ,
                    P.isPositive = function() {
                        return this.s > 0
                    }
                    ,
                    P.isZero = function() {
                        return !!this.c && 0 == this.c[0]
                    }
                    ,
                    P.minus = function(y, b) {
                        var i, j, t, xLTy, x = this, a = x.s;
                        if (b = (y = new BigNumber(y,b)).s,
                        !a || !b)
                            return new BigNumber(NaN);
                        if (a != b)
                            return y.s = -b,
                            x.plus(y);
                        var xe = x.e / LOG_BASE
                          , ye = y.e / LOG_BASE
                          , xc = x.c
                          , yc = y.c;
                        if (!xe || !ye) {
                            if (!xc || !yc)
                                return xc ? (y.s = -b,
                                y) : new BigNumber(yc ? x : NaN);
                            if (!xc[0] || !yc[0])
                                return yc[0] ? (y.s = -b,
                                y) : new BigNumber(xc[0] ? x : 3 == ROUNDING_MODE ? -0 : 0)
                        }
                        if (xe = bitFloor(xe),
                        ye = bitFloor(ye),
                        xc = xc.slice(),
                        a = xe - ye) {
                            for ((xLTy = a < 0) ? (a = -a,
                            t = xc) : (ye = xe,
                            t = yc),
                            t.reverse(),
                            b = a; b--; t.push(0))
                                ;
                            t.reverse()
                        } else
                            for (j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b,
                            a = b = 0; b < j; b++)
                                if (xc[b] != yc[b]) {
                                    xLTy = xc[b] < yc[b];
                                    break
                                }
                        if (xLTy && (t = xc,
                        xc = yc,
                        yc = t,
                        y.s = -y.s),
                        (b = (j = yc.length) - (i = xc.length)) > 0)
                            for (; b--; xc[i++] = 0)
                                ;
                        for (b = BASE - 1; j > a; ) {
                            if (xc[--j] < yc[j]) {
                                for (i = j; i && !xc[--i]; xc[i] = b)
                                    ;
                                --xc[i],
                                xc[j] += BASE
                            }
                            xc[j] -= yc[j]
                        }
                        for (; 0 == xc[0]; xc.splice(0, 1),
                        --ye)
                            ;
                        return xc[0] ? normalise(y, xc, ye) : (y.s = 3 == ROUNDING_MODE ? -1 : 1,
                        y.c = [y.e = 0],
                        y)
                    }
                    ,
                    P.modulo = P.mod = function(y, b) {
                        var q, s, x = this;
                        return y = new BigNumber(y,b),
                        !x.c || !y.s || y.c && !y.c[0] ? new BigNumber(NaN) : !y.c || x.c && !x.c[0] ? new BigNumber(x) : (9 == MODULO_MODE ? (s = y.s,
                        y.s = 1,
                        q = div(x, y, 0, 3),
                        y.s = s,
                        q.s *= s) : q = div(x, y, 0, MODULO_MODE),
                        (y = x.minus(q.times(y))).c[0] || 1 != MODULO_MODE || (y.s = x.s),
                        y)
                    }
                    ,
                    P.multipliedBy = P.times = function(y, b) {
                        var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, x = this, xc = x.c, yc = (y = new BigNumber(y,b)).c;
                        if (!(xc && yc && xc[0] && yc[0]))
                            return !x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc ? y.c = y.e = y.s = null : (y.s *= x.s,
                            xc && yc ? (y.c = [0],
                            y.e = 0) : y.c = y.e = null),
                            y;
                        for (e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE),
                        y.s *= x.s,
                        (xcL = xc.length) < (ycL = yc.length) && (zc = xc,
                        xc = yc,
                        yc = zc,
                        i = xcL,
                        xcL = ycL,
                        ycL = i),
                        i = xcL + ycL,
                        zc = []; i--; zc.push(0))
                            ;
                        for (base = BASE,
                        1e7,
                        i = ycL; --i >= 0; ) {
                            for (c = 0,
                            ylo = yc[i] % 1e7,
                            yhi = yc[i] / 1e7 | 0,
                            j = i + (k = xcL); j > i; )
                                c = ((xlo = ylo * (xlo = xc[--k] % 1e7) + (m = yhi * xlo + (xhi = xc[k] / 1e7 | 0) * ylo) % 1e7 * 1e7 + zc[j] + c) / base | 0) + (m / 1e7 | 0) + yhi * xhi,
                                zc[j--] = xlo % base;
                            zc[j] = c
                        }
                        return c ? ++e : zc.splice(0, 1),
                        normalise(y, zc, e)
                    }
                    ,
                    P.negated = function() {
                        var x = new BigNumber(this);
                        return x.s = -x.s || null,
                        x
                    }
                    ,
                    P.plus = function(y, b) {
                        var t, x = this, a = x.s;
                        if (b = (y = new BigNumber(y,b)).s,
                        !a || !b)
                            return new BigNumber(NaN);
                        if (a != b)
                            return y.s = -b,
                            x.minus(y);
                        var xe = x.e / LOG_BASE
                          , ye = y.e / LOG_BASE
                          , xc = x.c
                          , yc = y.c;
                        if (!xe || !ye) {
                            if (!xc || !yc)
                                return new BigNumber(a / 0);
                            if (!xc[0] || !yc[0])
                                return yc[0] ? y : new BigNumber(xc[0] ? x : 0 * a)
                        }
                        if (xe = bitFloor(xe),
                        ye = bitFloor(ye),
                        xc = xc.slice(),
                        a = xe - ye) {
                            for (a > 0 ? (ye = xe,
                            t = yc) : (a = -a,
                            t = xc),
                            t.reverse(); a--; t.push(0))
                                ;
                            t.reverse()
                        }
                        for ((a = xc.length) - (b = yc.length) < 0 && (t = yc,
                        yc = xc,
                        xc = t,
                        b = a),
                        a = 0; b; )
                            a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0,
                            xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
                        return a && (xc = [a].concat(xc),
                        ++ye),
                        normalise(y, xc, ye)
                    }
                    ,
                    P.precision = P.sd = function(sd, rm) {
                        var c, n, v, x = this;
                        if (null != sd && sd !== !!sd)
                            return intCheck(sd, 1, MAX),
                            null == rm ? rm = ROUNDING_MODE : intCheck(rm, 0, 8),
                            round(new BigNumber(x), sd, rm);
                        if (!(c = x.c))
                            return null;
                        if (n = (v = c.length - 1) * LOG_BASE + 1,
                        v = c[v]) {
                            for (; v % 10 == 0; v /= 10,
                            n--)
                                ;
                            for (v = c[0]; v >= 10; v /= 10,
                            n++)
                                ;
                        }
                        return sd && x.e + 1 > n && (n = x.e + 1),
                        n
                    }
                    ,
                    P.shiftedBy = function(k) {
                        return intCheck(k, -9007199254740991, 9007199254740991),
                        this.times("1e" + k)
                    }
                    ,
                    P.squareRoot = P.sqrt = function() {
                        var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber("0.5");
                        if (1 !== s || !c || !c[0])
                            return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
                        if (0 == (s = Math.sqrt(+valueOf(x))) || s == 1 / 0 ? (((n = coeffToString(c)).length + e) % 2 == 0 && (n += "0"),
                        s = Math.sqrt(+n),
                        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2),
                        r = new BigNumber(n = s == 1 / 0 ? "5e" + e : (n = s.toExponential()).slice(0, n.indexOf("e") + 1) + e)) : r = new BigNumber(s + ""),
                        r.c[0])
                            for ((s = (e = r.e) + dp) < 3 && (s = 0); ; )
                                if (t = r,
                                r = half.times(t.plus(div(x, t, dp, 1))),
                                coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                                    if (r.e < e && --s,
                                    "9999" != (n = n.slice(s - 3, s + 1)) && (rep || "4999" != n)) {
                                        +n && (+n.slice(1) || "5" != n.charAt(0)) || (round(r, r.e + DECIMAL_PLACES + 2, 1),
                                        m = !r.times(r).eq(x));
                                        break
                                    }
                                    if (!rep && (round(t, t.e + DECIMAL_PLACES + 2, 0),
                                    t.times(t).eq(x))) {
                                        r = t;
                                        break
                                    }
                                    dp += 4,
                                    s += 4,
                                    rep = 1
                                }
                        return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m)
                    }
                    ,
                    P.toExponential = function(dp, rm) {
                        return null != dp && (intCheck(dp, 0, MAX),
                        dp++),
                        format(this, dp, rm, 1)
                    }
                    ,
                    P.toFixed = function(dp, rm) {
                        return null != dp && (intCheck(dp, 0, MAX),
                        dp = dp + this.e + 1),
                        format(this, dp, rm)
                    }
                    ,
                    P.toFormat = function(dp, rm, format) {
                        var str, x = this;
                        if (null == format)
                            null != dp && rm && "object" == typeof rm ? (format = rm,
                            rm = null) : dp && "object" == typeof dp ? (format = dp,
                            dp = rm = null) : format = FORMAT;
                        else if ("object" != typeof format)
                            throw Error(bignumberError + "Argument not an object: " + format);
                        if (str = x.toFixed(dp, rm),
                        x.c) {
                            var i, arr = str.split("."), g1 = +format.groupSize, g2 = +format.secondaryGroupSize, groupSeparator = format.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
                            if (g2 && (i = g1,
                            g1 = g2,
                            g2 = i,
                            len -= i),
                            g1 > 0 && len > 0) {
                                for (i = len % g1 || g1,
                                intPart = intDigits.substr(0, i); i < len; i += g1)
                                    intPart += groupSeparator + intDigits.substr(i, g1);
                                g2 > 0 && (intPart += groupSeparator + intDigits.slice(i)),
                                isNeg && (intPart = "-" + intPart)
                            }
                            str = fractionPart ? intPart + (format.decimalSeparator || "") + ((g2 = +format.fractionGroupSize) ? fractionPart.replace(new RegExp("\\d{" + g2 + "}\\B","g"), "$&" + (format.fractionGroupSeparator || "")) : fractionPart) : intPart
                        }
                        return (format.prefix || "") + str + (format.suffix || "")
                    }
                    ,
                    P.toFraction = function(md) {
                        var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
                        if (null != md && (!(n = new BigNumber(md)).isInteger() && (n.c || 1 !== n.s) || n.lt(ONE)))
                            throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
                        if (!xc)
                            return new BigNumber(x);
                        for (d = new BigNumber(ONE),
                        n1 = d0 = new BigNumber(ONE),
                        d1 = n0 = new BigNumber(ONE),
                        s = coeffToString(xc),
                        e = d.e = s.length - x.e - 1,
                        d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp],
                        md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n,
                        exp = MAX_EXP,
                        MAX_EXP = 1 / 0,
                        n = new BigNumber(s),
                        n0.c[0] = 0; q = div(n, d, 0, 1),
                        1 != (d2 = d0.plus(q.times(d1))).comparedTo(md); )
                            d0 = d1,
                            d1 = d2,
                            n1 = n0.plus(q.times(d2 = n1)),
                            n0 = d2,
                            d = n.minus(q.times(d2 = d)),
                            n = d2;
                        return d2 = div(md.minus(d0), d1, 0, 1),
                        n0 = n0.plus(d2.times(n1)),
                        d0 = d0.plus(d2.times(d1)),
                        n0.s = n1.s = x.s,
                        r = div(n1, d1, e *= 2, ROUNDING_MODE).minus(x).abs().comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0],
                        MAX_EXP = exp,
                        r
                    }
                    ,
                    P.toNumber = function() {
                        return +valueOf(this)
                    }
                    ,
                    P.toPrecision = function(sd, rm) {
                        return null != sd && intCheck(sd, 1, MAX),
                        format(this, sd, rm, 2)
                    }
                    ,
                    P.toString = function(b) {
                        var str, n = this, s = n.s, e = n.e;
                        return null === e ? s ? (str = "Infinity",
                        s < 0 && (str = "-" + str)) : str = "NaN" : (null == b ? str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0") : 10 === b && alphabetHasNormalDecimalDigits ? str = toFixedPoint(coeffToString((n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE)).c), n.e, "0") : (intCheck(b, 2, ALPHABET.length, "Base"),
                        str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, !0)),
                        s < 0 && n.c[0] && (str = "-" + str)),
                        str
                    }
                    ,
                    P.valueOf = P.toJSON = function() {
                        return valueOf(this)
                    }
                    ,
                    P._isBigNumber = !0,
                    null != configObject && BigNumber.set(configObject),
                    BigNumber
                }(),
                BigNumber.default = BigNumber.BigNumber = BigNumber,
                void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                    return BigNumber
                }
                .call(exports, __webpack_require__, exports, module)) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)
            }()
        },
        79746: module=>{
            function assert(val, msg) {
                if (!val)
                    throw new Error(msg || "Assertion failed")
            }
            module.exports = assert,
            assert.equal = function(l, r, msg) {
                if (l != r)
                    throw new Error(msg || "Assertion failed: " + l + " != " + r)
            }
        }
        ,
        34504: (__unused_webpack_module,exports)=>{
            "use strict";
            var utils = exports;
            function zero2(word) {
                return 1 === word.length ? "0" + word : word
            }
            function toHex(msg) {
                for (var res = "", i = 0; i < msg.length; i++)
                    res += zero2(msg[i].toString(16));
                return res
            }
            utils.toArray = function(msg, enc) {
                if (Array.isArray(msg))
                    return msg.slice();
                if (!msg)
                    return [];
                var res = [];
                if ("string" != typeof msg) {
                    for (var i = 0; i < msg.length; i++)
                        res[i] = 0 | msg[i];
                    return res
                }
                if ("hex" === enc) {
                    (msg = msg.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (msg = "0" + msg);
                    for (i = 0; i < msg.length; i += 2)
                        res.push(parseInt(msg[i] + msg[i + 1], 16))
                } else
                    for (i = 0; i < msg.length; i++) {
                        var c = msg.charCodeAt(i)
                          , hi = c >> 8
                          , lo = 255 & c;
                        hi ? res.push(hi, lo) : res.push(lo)
                    }
                return res
            }
            ,
            utils.zero2 = zero2,
            utils.toHex = toHex,
            utils.encode = function(arr, enc) {
                return "hex" === enc ? toHex(arr) : arr
            }
        }
        ,
        69131: (module,__unused_webpack_exports,__webpack_require__)=>{
            "use strict";
            var mod, Buffer = __webpack_require__(48764).Buffer, __create = Object.create, __defProp = Object.defineProperty, __getOwnPropDesc = Object.getOwnPropertyDescriptor, __getOwnPropNames = Object.getOwnPropertyNames, __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty, __export = (target,all)=>{
                for (var name in all)
                    __defProp(target, name, {
                        get: all[name],
                        enumerable: !0
                    })
            }
            , __copyProps = (to,from,except,desc)=>{
                if (from && "object" == typeof from || "function" == typeof from)
                    for (let key of __getOwnPropNames(from))
                        __hasOwnProp.call(to, key) || key === except || __defProp(to, key, {
                            get: ()=>from[key],
                            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
                        });
                return to
            }
            , __toESM = (mod,isNodeMode,target)=>(target = null != mod ? __create(__getProtoOf(mod)) : {},
            __copyProps(!isNodeMode && mod && mod.__esModule ? target : __defProp(target, "default", {
                value: mod,
                enumerable: !0
            }), mod)), src_exports = {};
            __export(src_exports, {
                Account: ()=>Account,
                AccountInterface: ()=>AccountInterface,
                Contract: ()=>Contract,
                ContractFactory: ()=>ContractFactory,
                ContractInterface: ()=>ContractInterface,
                GatewayError: ()=>GatewayError,
                HttpError: ()=>HttpError,
                LibraryError: ()=>LibraryError,
                Provider: ()=>Provider,
                ProviderInterface: ()=>ProviderInterface,
                RpcProvider: ()=>RpcProvider,
                SequencerProvider: ()=>SequencerProvider,
                Signer: ()=>Signer,
                SignerInterface: ()=>SignerInterface,
                addAddressPadding: ()=>addAddressPadding,
                buildUrl: ()=>buildUrl,
                constants: ()=>constants_exports,
                defaultProvider: ()=>defaultProvider,
                ec: ()=>ellipticCurve_exports,
                encode: ()=>encode_exports,
                getChecksumAddress: ()=>getChecksumAddress,
                hash: ()=>hash_exports,
                isUrl: ()=>isUrl,
                json: ()=>json_exports,
                merkle: ()=>merkle_exports,
                number: ()=>number_exports,
                shortString: ()=>shortString_exports,
                stark: ()=>stark_exports,
                transaction: ()=>transaction_exports,
                typedData: ()=>typedData_exports,
                uint256: ()=>uint256_exports,
                validateAndParseAddress: ()=>validateAndParseAddress,
                validateChecksumAddress: ()=>validateChecksumAddress
            }),
            module.exports = (mod = src_exports,
            __copyProps(__defProp({}, "__esModule", {
                value: !0
            }), mod));
            var import_minimalistic_assert5 = __toESM(__webpack_require__(79746))
              , import_isomorphic_fetch = __toESM(__webpack_require__(94301))
              , fetchPonyfill_default = "undefined" != typeof window && window.fetch || void 0 !== __webpack_require__.g && __webpack_require__.g.fetch || import_isomorphic_fetch.default
              , hash_exports = {};
            __export(hash_exports, {
                calculateContractAddressFromHash: ()=>calculateContractAddressFromHash,
                calculateDeclareTransactionHash: ()=>calculateDeclareTransactionHash,
                calculateDeployAccountTransactionHash: ()=>calculateDeployAccountTransactionHash,
                calculateDeployTransactionHash: ()=>calculateDeployTransactionHash,
                calculateTransactionHash: ()=>calculateTransactionHash,
                calculateTransactionHashCommon: ()=>calculateTransactionHashCommon,
                computeHashOnElements: ()=>computeHashOnElements,
                feeTransactionVersion: ()=>feeTransactionVersion,
                getSelector: ()=>getSelector,
                getSelectorFromName: ()=>getSelectorFromName,
                keccakBn: ()=>keccakBn,
                pedersen: ()=>pedersen,
                starknetKeccak: ()=>starknetKeccak,
                transactionVersion: ()=>transactionVersion
            });
            var import_keccak = __webpack_require__(82192)
              , import_utils = __webpack_require__(58040)
              , import_minimalistic_assert3 = __toESM(__webpack_require__(79746))
              , constants_exports = {};
            __export(constants_exports, {
                ALPHA: ()=>ALPHA,
                BETA: ()=>BETA,
                CONSTANT_POINTS: ()=>CONSTANT_POINTS,
                EC_ORDER: ()=>EC_ORDER,
                FIELD_GEN: ()=>FIELD_GEN,
                FIELD_PRIME: ()=>FIELD_PRIME,
                FIELD_SIZE: ()=>FIELD_SIZE,
                IS_BROWSER: ()=>IS_BROWSER,
                MASK_250: ()=>MASK_250,
                MASK_251: ()=>MASK_251,
                MAX_ECDSA_VAL: ()=>MAX_ECDSA_VAL,
                ONE: ()=>ONE,
                StarknetChainId: ()=>StarknetChainId,
                TWO: ()=>TWO,
                TransactionHashPrefix: ()=>TransactionHashPrefix,
                UDC: ()=>UDC,
                ZERO: ()=>ZERO
            });
            var number_exports = {};
            __export(number_exports, {
                assertInRange: ()=>assertInRange,
                bigNumberishArrayToDecimalStringArray: ()=>bigNumberishArrayToDecimalStringArray,
                bigNumberishArrayToHexadecimalStringArray: ()=>bigNumberishArrayToHexadecimalStringArray,
                cleanHex: ()=>cleanHex,
                getDecimalString: ()=>getDecimalString,
                getHexString: ()=>getHexString,
                getHexStringArray: ()=>getHexStringArray,
                hexToDecimalString: ()=>hexToDecimalString,
                isHex: ()=>isHex,
                isStringWholeNumber: ()=>isStringWholeNumber,
                toBN: ()=>toBN,
                toCairoBool: ()=>toCairoBool,
                toFelt: ()=>toFelt,
                toHex: ()=>toHex,
                toHexString: ()=>toHexString
            });
            var import_bn = __toESM(__webpack_require__(63742))
              , import_minimalistic_assert = __toESM(__webpack_require__(79746))
              , encode_exports = {};
            __export(encode_exports, {
                IS_BROWSER: ()=>IS_BROWSER,
                addHexPrefix: ()=>addHexPrefix,
                arrayBufferToString: ()=>arrayBufferToString,
                btoaUniversal: ()=>btoaUniversal,
                buf2hex: ()=>buf2hex,
                calcByteLength: ()=>calcByteLength,
                padLeft: ()=>padLeft,
                removeHexPrefix: ()=>removeHexPrefix,
                sanitizeBytes: ()=>sanitizeBytes,
                sanitizeHex: ()=>sanitizeHex,
                utf8ToArray: ()=>utf8ToArray
            });
            var IS_BROWSER = "undefined" != typeof window
              , STRING_ZERO = "0";
            function arrayBufferToString(array) {
                return new Uint8Array(array).reduce(((data,byte)=>data + String.fromCharCode(byte)), "")
            }
            function btoaUniversal(b) {
                return IS_BROWSER ? btoa(arrayBufferToString(b)) : Buffer.from(b).toString("base64")
            }
            function buf2hex(buffer) {
                return [...buffer].map((x=>x.toString(16).padStart(2, "0"))).join("")
            }
            function removeHexPrefix(hex) {
                return hex.replace(/^0x/i, "")
            }
            function addHexPrefix(hex) {
                return `0x${removeHexPrefix(hex)}`
            }
            function padLeft(str, length, padding=STRING_ZERO) {
                return function(str, length, left, padding=STRING_ZERO) {
                    const diff = length - str.length;
                    let result = str;
                    if (diff > 0) {
                        const pad = padding.repeat(diff);
                        result = left ? pad + str : str + pad
                    }
                    return result
                }(str, length, !0, padding)
            }
            function calcByteLength(length, byteSize=8) {
                const remainder = length % byteSize;
                return remainder ? (length - remainder) / byteSize * byteSize + byteSize : length
            }
            function sanitizeBytes(str, byteSize=8, padding=STRING_ZERO) {
                return padLeft(str, calcByteLength(str.length, byteSize), padding)
            }
            function sanitizeHex(hex) {
                return (hex = sanitizeBytes(hex = removeHexPrefix(hex), 2)) && (hex = addHexPrefix(hex)),
                hex
            }
            function utf8ToArray(str) {
                return (new TextEncoder).encode(str)
            }
            function isHex(hex) {
                return /^0x[0-9a-f]*$/i.test(hex)
            }
            function toBN(number, base) {
                return "string" == typeof number && (number = number.toLowerCase()),
                "string" == typeof number && isHex(number) && !base ? new import_bn.default(removeHexPrefix(number),"hex") : new import_bn.default(number,base)
            }
            function toHex(number) {
                return addHexPrefix(number.toString("hex"))
            }
            function hexToDecimalString(hex) {
                return toBN(`0x${hex.replace(/^0x/, "")}`).toString()
            }
            function toFelt(num) {
                return import_bn.default.isBN(num) ? num.toString() : toBN(num).toString()
            }
            var cleanHex = hex=>hex.toLowerCase().replace(/^(0x)0+/, "$1");
            function assertInRange(input, lowerBound, upperBound, inputName="") {
                const messageSuffix = "" === inputName ? "invalid length" : `invalid ${inputName} length`
                  , inputBn = toBN(input);
                (0,
                import_minimalistic_assert.default)(inputBn.gte(toBN(lowerBound)) && inputBn.lt(toBN(upperBound)), `Message not signable, ${messageSuffix}.`)
            }
            function bigNumberishArrayToDecimalStringArray(rawCalldata) {
                return rawCalldata.map((x=>toBN(x).toString(10)))
            }
            function bigNumberishArrayToHexadecimalStringArray(rawCalldata) {
                return rawCalldata.map((x=>toHex(toBN(x))))
            }
            var isStringWholeNumber = value=>/^\d+$/.test(value)
              , toHexString = value=>toHex(toBN(value));
            function getDecimalString(value) {
                if (isHex(value))
                    return hexToDecimalString(value);
                if (isStringWholeNumber(value))
                    return value;
                throw new Error(`${value} need to be hex-string or whole-number-string`)
            }
            function getHexString(value) {
                if (isHex(value))
                    return value;
                if (isStringWholeNumber(value))
                    return toHexString(value);
                throw new Error(`${value} need to be hex-string or whole-number-string`)
            }
            function getHexStringArray(value) {
                return value.map((el=>getHexString(el)))
            }
            var toCairoBool = value=>(+value).toString()
              , ZERO = toBN(0)
              , ONE = toBN(1)
              , TWO = toBN(2)
              , MASK_250 = TWO.pow(toBN(250)).sub(ONE)
              , MASK_251 = TWO.pow(toBN(251))
              , StarknetChainId = (StarknetChainId3=>(StarknetChainId3.MAINNET = "0x534e5f4d41494e",
            StarknetChainId3.TESTNET = "0x534e5f474f45524c49",
            StarknetChainId3.TESTNET2 = "0x534e5f474f45524c4932",
            StarknetChainId3))(StarknetChainId || {})
              , TransactionHashPrefix = (TransactionHashPrefix2=>(TransactionHashPrefix2.DECLARE = "0x6465636c617265",
            TransactionHashPrefix2.DEPLOY = "0x6465706c6f79",
            TransactionHashPrefix2.DEPLOY_ACCOUNT = "0x6465706c6f795f6163636f756e74",
            TransactionHashPrefix2.INVOKE = "0x696e766f6b65",
            TransactionHashPrefix2.L1_HANDLER = "0x6c315f68616e646c6572",
            TransactionHashPrefix2))(TransactionHashPrefix || {})
              , UDC = {
                ADDRESS: "0x041a78e741e5af2fec34b695679bc6891742439f7afb8484ecd7766661ad02bf",
                ENTRYPOINT: "deployContract"
            }
              , FIELD_PRIME = "800000000000011000000000000000000000000000000000000000000000001"
              , FIELD_GEN = "3"
              , FIELD_SIZE = 251
              , EC_ORDER = "800000000000010FFFFFFFFFFFFFFFFB781126DCAE7B2321E66A241ADC64D2F"
              , ALPHA = "1"
              , BETA = "6F21413EFBE40DE150E596D72F7A8C5609AD26C15C915C1F4CDFCB99CEE9E89"
              , MAX_ECDSA_VAL = "800000000000000000000000000000000000000000000000000000000000000"
              , CONSTANT_POINTS = [["49ee3eba8c1600700ee1b87eb599f16716b0b1022947733551fde4050ca6804", "3ca0cfe4b3bc6ddf346d49d06ea0ed34e621062c0e056c1d0405d266e10268a"], ["1ef15c18599971b7beced415a40f0c7deacfd9b0d1819e03d723d8bc943cfca", "5668060aa49730b7be4801df46ec62de53ecd11abe43a32873000c36e8dc1f"], ["234287dcbaffe7f969c748655fca9e58fa8120b6d56eb0c1080d17957ebe47b", "3b056f100f96fb21e889527d41f4e39940135dd7a6c94cc6ed0268ee89e5615"], ["3909690e1123c80678a7ba0fde0e8447f6f02b3f6b960034d1e93524f8b476", "7122e9063d239d89d4e336753845b76f2b33ca0d7f0c1acd4b9fe974994cc19"], ["40fd002e38ea01a01b2702eb7c643e9decc2894cbf31765922e281939ab542c", "109f720a79e2a41471f054ca885efd90c8cfbbec37991d1b6343991e0a3e740"], ["2f52066635c139fc2f64eb0bd5e3fd7a705f576854ec4f00aa60361fddb981b", "6d78a24d8a5f97fc600318ce16b3c840315979c3273078ec1a285f217ee6a26"], ["6a0767a1fd60d5b9027a35af1b68e57a1c366ebcde2006cdd07af27043ef674", "606b72c0ca0498b8c1817ed7922d550894c324f5efdfc85a19a1ae382411ca2"], ["7fa463ee2a2d6a585d5c3358918270f6c28c66df1f86803374d1edf3819cc62", "a996edf01598832e644e1cae9a37288865ad80e2787f9bf958aceccc99afae"], ["3d4da70d1540da597dbae1651d28487604a4e66a4a1823b97e8e9639393dbec", "45cdef70c35d3b6f0a2273a9886ccb6306d813e8204bdfd30b4efee63c8a3f9"], ["1e448fdbcd9896c6fbf5f36cb7e7fcb77a751ff2d942593cae023363cc7750e", "30c81da0f3a8cb64468eaa491c7ae7b4842b62cb4148820da211afc4caffb3a"], ["6531acf1a7cb90a4eb27de0b7f915e387a3b0fd063ba6e1289b91f48411be26", "31330f5daa091889981a3ea782ae997f5f171336ed0487a03f051551a2cafa2"], ["54be016394d5662d67d7e82f5e889ed2f97ccf95d911f57dd2362c4040ed4f4", "c6cb184053f054d6a59c1bf0986d17090d25089b3fdcdaf185edc87ef113e5"], ["35b9ecd0499ca1d5d42dcbb0c6b4042b3733c64b607ca711e706e786ef2afc6", "5624b476a5b21c3a544f0712d4817b06ad380a5a6529d323bf64da8ef862d8d"], ["4ce0378e3ee8f77ed58f2ddbd8bb7676c8a38bfb1d3694c275254bd8ca38e23", "5a16fcbff0769c9cf2b02c31621878ec819fff4b8231bff82c6183db2746820"], ["648d5c6f98680a1b926bfeb01c00224c56fdcf751b251c4449c8a94f425cfcf", "72c05ac793cd1620a833fbe2214d36900ebe446e095c62fcb740937f98cca8c"], ["bd09be3e4e1af8a14189977e334f097c18e4a8bf42577ef5aafa0f807bd89b", "6e0e72ed7eb65c86cee29c411fb4761122558ee81013344ba8509c49de9f9b6"], ["35ea4e339b44ae7724419bdfbe07022253137a4afb7cbaffad341ea61249357", "3665d676a026a174f367bb4417780e53a7803cb02d0db32eb4545c267c42f14"], ["36457bc744f42e697b825c2d1afd8f4029d696a4514710f81da52d88e178643", "7c93715896735492a68c7969a024b3a8fd538bffc1521538107de1a5f13ce9c"], ["5b3a08ebcf9c109cc9082f70d9df2b9c11b5428ee23917b4e790c4c10f6e661", "9d7b42ab0c20f5510df7ea5e196eec99342739077e9a168198c89da859753"], ["21883ef8580fc06e59481955d52ece3aca6e82c8c9fc58e216dcf46f96990c6", "51a6423543e6e8a43e71da34cd90f5b520b8d33b67c4bf857573ab9e301aa4c"], ["19e86b77f9b581e81092b305c852faf53940a8f15f0a6990c414f04c0fa7ef9", "515630e35d4398c9c79fc4ee08e1023fa47d8e03c6e7819c6d2ccef45398fa"], ["888ab8eb4c31bb2ac5b54aa320dbe1a69c96b864e8a5f54d89c1d1a6b86c24", "730e148467f6a55ce22c5296f5380df88f38de76ef0b2de844cd3094aaaf3ea"], ["75e79ff13a894e7120dac17b7429c0c32ce7828f726c9973728c0977a5f5977", "4960526e59c1c736561a201bc56f7d762641b39f609d273cc996f5d9197cfb8"], ["640fe009249115d7254f72ecafb3006139e4bed7e9041af51458c737282d1d5", "3cc6c978a575246e2ce4f7ef1fcc7f63085db9ff98a1b1f3fe374087c0332c"], ["6d6fd09ccab7c26de9b3906191235deb5c34685580c488275356a05e209ca96", "7157f81a34213dd8f91dea4f6df1bcfabc4ee091a3049eeeb3b7923d39b8645"], ["5531ca1d00f151d71da820918f74caf2985b24dca20e124721fff507b5a5876", "518529643d3f25e47f72c322223ba60a63d6bfe78cf3f612215d9c19bf29200"], ["6192d454e4f8fe212bdfccd5b15dd5056d7622ffe456c6c67e5a7265aea49c4", "2377a45dc630017ae863cb968ddb38333a70c7946d8684e6d7a6213f634b7bc"], ["542fb44b4ef3640a64fdb22a2560fb26668065c069cf31d1df424819a39ff18", "5dbae9b0948e0361aea443503840341c322aa1a1366ce5390e71bf161f78f8c"], ["299ff3e3412a7eb4cb4a3051b07b1be2e7b1c4b789f39ffb52cba3d048b71de", "1951d3175c02761b291d86b6c0a08387ad5e2a2130ccc33c852530572cb3958"], ["628ce3f5367dadc1411133e55eb25e2e3c2880d6e28754a5cb1c5d109627e73", "ae3e9b7d50964e28bd15380400b7659b87affdef5d2586cbefcd9be7d67c0d"], ["6ea54aff064895eccf9db2283225d62044ae67621192b3346338948382f5933", "6431507e51aadacfaf39f102a8ff387756e9b5e1bc8323d44acae55130d93db"], ["28097d50d175a6235320fe8cfe138dd9e46895d189582e472c38ad7a67d923a", "7f9eab4133d7d09a7ff63368d6135c26262b62336eca1b5ca33f2096ce388ba"], ["619fd09cdd6ff4323973f256c2cbdcb224f7f25b8aef623af2d4a0105e62e02", "2c95f0ae11d47eeae1bc7f1350f75f9185c5bc840382ceb38a797cae9c40308"], ["641c18982ced304512a3f2395942a38add0d6a7156229c2a7c8b8dfbe9beb96", "6f6288c9c659b6af5ac975f4180deffe53d516399b2cc62f31732e9d4ba9837"], ["58ab546e51fe49fc5a382e4064a2bd6cfc268904412f86c26de14f28a71d0f2", "124b7217943e7e328408e8afdfa7da00dcbc94a2bb85fd8e01fb162d2c2c0a9"], ["a82c2fdedbb26c3c762a12f7e86b0e01e65320e0a25a8399d665f6e266bf74", "1a1de28e253f3e10f44d0111e8074f882d7f42e5900780ccbdc31da372d3fd8"], ["744c725a7455a992e3cf5bd007bc234dd4668dba285f553f38350ad94c1615b", "7f721a87f48798bdc4a9c0eb88559e2ad7a74112fd901e70ea159e67a9c33f"], ["434df142ddaa60f7881b6348d91687de40457de7ccfb07f0304b9e820705d0c", "7fae425e3b53f97dd1f5b20e49ed9fe24ff1efc341ba5e017ac89cf8df0cc39"], ["7a1e2b809dff46277021cbc376f79c37e1b683bbd6bca5317014f0dc0e1ae73", "56790278a231912c334eff05281e08af1558e85516b4411ef64647c13bea431"], ["4931b7990348d41cf8907be79f45bb7991fd18f8a57868351c92fa7a34cbcd7", "ca35091815cdf0837d396e25aad6052ad32d497a33b123256cffdc008bc50e"], ["250b815d352fd89f8210b624b147ea7d0a4f47bcac49f3ac9b777840da93ebe", "1173f10e9691948b7da7632f328520455aadcba46e017f891e0a1d7da2bef04"], ["2223b85032fa67292f6e1f822628e6756e5c3cc08fc252ab88d63d624e4dfb2", "55619ba96a7dcec77832fcb22cd5c21c7dcebc0280d730cba0002b67e0a8c63"], ["249b131e04de73af9820d3e22492d9ec51bdc0c4c4f34d95352fa44dd61f245", "7576d3b5d136368ff01170a77d8286d0d1c7c40688862fb40813b4af3c6065e"], ["6777915d9b4769027eb7e04733f8a2d669c84fe06080f55e8a55674dfbf9efb", "640d0ff384c9635e1af364760f104e058e3c86209fa9d2320aeac887b2e02d8"], ["2abe3f237681052f002414399111cf07f8421535af41251edc427a36b5b19c9", "636ce4deaf468a503ab20ccb2f7e5bdc98551656ebf53e9c7786b11dd9090be"], ["4d5cc5414758ea1be55be779bd7da296c7e11f1564d9e8797ceea347c16f8ea", "1a680c4c410cf5ddc74e95ff2897c193edaaecce5b2cde4e96bbae5c0054eff"], ["46c375c684b30adf4d51de81e92afee52b1a3847e177403372c82109373edca", "1eaadc5783c90a0261306423d52009e991126b3f620e9cb6cffca41ca096f4f"], ["2ddfb71f51205888118cbabba8fd07d460a810289bfdeeb7118707e310cb152", "1fd905d07b3933be886f2518246bdafa6f33259a174668808223cd7c28183c7"], ["386f3879960713d41fdb3b1e41bbebf26b1c0e27a9a75bb1adcc1a0d3e8547b", "2b21498c0f34ec6f17c720334dc0f36021c2f87afbbbc8847d0bd536eb265e5"], ["407eae62c6c4de3b942195afec3f45efec71ddb5e6edee3d427631bcdbf9b90", "436e7f2d78268ef62c4172d2ff1469028bad1f1d0f97ab007064418e61caa8f"], ["1b881175e21201d17e095e9b3966b354f47de8c1acee5177f5909e0fd72328f", "69954b1a9b8bfccf8ec384d32924518a935758f3d3662ef754bcc88f1f6f3ec"], ["7d545a82bff003b8115be32a0c437f7c0a98f776bcf7fddb0392822844f3c5e", "34b6e53a9565a7daa010711f5bf72254a4e61da3e6a562210a9abc9e8b66d69"], ["299b9fcd4fadfc4b6141457a3036aaa68501c23df579de26df69d4def89b913", "b95bf2c2bb303c38bb396382edc798ca6a4847e573ce19b7b08533d1912675"], ["551f5a4dae4a341a3e20336a7d2f365ddd45849351ec6dd4fcbedfe4806d5d5", "5865c977a0ecf13ce85ae14c5c316872080bd36f0f614f56b6dfc7ece83792e"], ["7a1d69c08e68c80ad8b310736e6247a53bcba0183b9b8798833bc696a0fb6e2", "3ce803a20ebb3b120d5eaf0ad64bed0522fad1a0f2ce39a5c5cbae98c4438f6"], ["28acacc0bc41d84e83663f02b36981a2c8272ecd72d3901164be2affb09c504", "7a5aee0b160eaff5b5968ab1a0304ce58c3d5ae0148d9191c39e87668229e5b"], ["1f78cfdbcc767b68e69a224a077468cdfcb0afd6952b85bccbdb96d1fb8500b", "4772ba173c6b583284eb001cfc2a124104833f464ff9df096443e10ef3e9dd4"], ["2774108962ca9897e7f22c064d2ccedac4fef5fc9569331c27cdc336c95774b", "9e13d79b68e8dc8091c019618f5b07283a710ddf1733dc674a99fc32c12911"], ["770d116415cd2c4ace0d8b721dd77e4a2ef766591f9ec9fa0b61304548994ed", "42165d93c82f687635aa2b68492b3adffd516beb4baa94520efa11467a209fd"], ["5e6e4ece6621e2275415e1fda1e7c4f496de498b77c0b913073c6a6099394b9", "3d92ce044fc77fa227adc31f6fc17ef8b4ec1c5aafc44630c0d9195075bf56d"], ["6e69c717b5d98807ff1e404a5187a9ceaf0110b83aa15a84f930928b1171825", "1ee7cfc3a9744d7fa380ba28604af9df33ac077724374c04588bd71fa16b177"], ["404318f2d2ceb44f549c80f9d7de9879d8f7da4b81e7350c00e974ebf2daef1", "3934831b5af70d17a3f1da9d2931bd757e6acf2893236264fc7e0d92ff1a1cb"], ["20dcb6f394fea6d549b2e75748f61b7ec03b6e52319cb14163373a9c22bb9dc", "106a8c96cfb95a331618b7416d1498554730499e194a58fbf63019890480fc7"], ["119000f277ccee013e6bb121194ec1ab5460fb6a96eb702a14079865f4170aa", "1737a32f5415e8720a5606ec1dd4756f02e7c6817e3723b453d091f2d192773"], ["45d0fb5cd95db76d05dec3faa12e467a308eabaad363a062353db3cd2d9b749", "ae08691b5b0cdd19ec499132421638f470f493320e4003d123ab1da761b965"], ["1257b3e65cdfb6367c6d0942327e799bc66eb221e70c6573a9862889eb51c38", "593309fd45755dd2cc4afd2b9316bc4638b0c5ddb3009694fcb7b250d0c8a2f"], ["186dcf9950f72e868014a8accf14aa36e82a7a2a29f86ba37f6632da4189db3", "55684c9f7a043fc523ed78f756f834b4db823d5e4161bd79602c17d55a5cd8c"], ["58791d5569f282f5c3b01ecdc9388df7ba3ca223a2dc1eed5edaf2a1d302fb9", "6298d7dd51561a045bb4089deda9f40b2865589ed433e56d54554f8b45e79f0"], ["13fd87144aa5aa4b24d5a7bf907d8280d15937fed262d41084898cb688fc28b", "3fa54367770cc4479a857411ddcabe86627b405ce1cd14ad3b2863bde13abe4"], ["48118139445415f0c1879224e2dee744ed35280ff00537260402a1741ec3676", "4dfa39dadaabecfc54ecb7a25319444f8e952782d863790e42a9887064fc0c1"], ["4ad031bb9eda84f2fe5d354c7948d41558ca657a04508654721810ee72ef158", "620ebd5d0086b92c6009a42777b946a351c2c7ba852b57d3c9905fc337459ef"], ["4a34abb016ad8cb4575ea5bd28385d2348e5bcc0cbba90059f90f9c71f86e8b", "4f781829ad83f9ed1e1b6de0e5f4ac60dfdfe7f23cb4411e815817e705e52c8"], ["7fc632d7512aab5356b7915dca854c8b12b369ab54f524fbce352f00eb9b9f9", "2ce80b944fc9158005f630b34385d50c3ad84450a9e1e529925b3211dd2a1de"], ["65ed10347503cbc0216ca03f7536cca16b6abd18d332a9258685907f2e5c23f", "3be1a18c6bfa6f2f4898ebefad5a8e844c74626d5baa04a820d407fe28bbca6"], ["1a8abba1be2e276cdd1f28c912280833a5ede1ec121738fcca47dc070dcc71d", "21b724378bc029a5199799df005922590d4e59cae52976f8e437bf6693eec4a"], ["3a99c22dafcfe9004ebb674805736a26aeed7ed5d465ae37226dcbe270a972b", "5bf67552af08e1e6e2a24bf562c23225e89869cab9bef8becb3669175a3c94f"], ["4a6a5e4b3501f2b7bbdd8da73ea81ffca347170bdfb6776a037cdd74c560fb4", "5af167ebb259c2da88740ec559ee04052bb66480b836cadd0e2590c32d7111b"], ["6890d95308525f0bac9dc25cc1189eb92d29d4b3fe61bc8aee1c716ac17b1e8", "e6f23f78e882026b53ea4fac6950e56e3da461e52339eb43d2fdb2dade7ca9"], ["748f4cf4f027efdeaed7c7f91ef3730ff2f2bb0bfc2db8f27aadde947f7d4d5", "3a1cbc550699411052c76293b8c41a3a8a1ecf12cbbc029a1b2b6ea986fca93"], ["7321f3f581690922cd0dec40c9c352aae412ec2ccdf718f137f7786ab452cd3", "5be5130c9277cdb76d7409452438ec15d246b211dd1e276ee58e82a81c98fd4"], ["6c4d6cb7e7ae70955224b8a912ff57ca218635a2436b36cee25dce8a5cdf51f", "32f8c03c6db3246946e432e4148e69f5628b200c6d7d72449df6eeac0998039"], ["1dad5f2e795ea6fa5177f110989516eacf8fb37bd6a091c7c93f1d73a2fe309", "56b2298c538180e99dea3e171dbb5c6fba0bd0a9ed40537277c0c2373a8e2c4"], ["1610605baacc9bc62c4cc923dc943347cfece7ae241e746fbe6c2c878221dbd", "431a82d657e0d109d00dea88cf3fa9b999845221b7b5590a20c40fc71368c1c"], ["6a4f5c787fb09a5be2b04d2eafa1e6f3d3c863ee22960eb0b64f6eaf6659162", "14dbc3eaea6146ee7eaace5a91ed9430dad3a47e9ca2f68b455171f8fe6a7b3"], ["738415b73e55412b0e582e45ff0d7bf4b1bf2922db581783fdcc75559f40e", "33825aeb3fd8459999eb418d15102ba5864b069c6ea517f0c6e9eab8d9aca47"], ["2603e72ce53985c70782774057a17944f7b4ce224a809be4e2b5af3606aa1d8", "92822921809c42318f42dac4d773325f41c43069e990adac7818a45e2554dc"], ["181cd967ab4615357cc96c82eae9152ce7598c1a1dfdd91a458bddb016ae9fe", "5d562fdaeb0e12647e230e50eaf216bed52fa73c6b7378821a3bfc4cd66d4ff"], ["1121726069b9ef5954ba6490100b226e0be53fef3e071b7c58a1286174b789a", "4b25594cf4e9eb2d14b3f52f2661a9992234fc222c0a0d44517cb77deb9c16f"], ["e543663969b915337f105f80995a77b356f1a51d8b4a4fb12d44364130e873", "34b2e3c009fdab4cb7349a580df2e64c0098a123280078e5da6623a9ec6b44f"], ["4e2f8909bb62de5ef65600e61bbf969293815296b6e23702875e049b3ce5c45", "3cb81f2c21f22a7add26fa38a9ce5d9cce1bb251bd2698f90c34ff0a84f7af"], ["37b546e403a1ba970c17b67c2f1361ab9c803f8d2b5cd93803014faa08861ed", "37079184ea46272f5809b523d060686633f7995167897a153be1772fd6566f6"], ["27bddca77f7bd7f66b3693567a4238f2e6751d95b0bcb409f6b24d08f84798c", "6417a85cbfd6fc02df560d3963a241a986baacdfa423f65d7227ce49a96c57d"], ["2de71a39aa043057d1bc66e45f804542acddf18f7a6d88c0d7fb0ca240debdf", "306c1ce39ab46300f7cca0f3a2fbfa77296a27e24bc66b0b8044968ec0ee413"], ["307c877154364c0c03534e7327d5a88e1380ceef6481567ade37a14ee7c1a72", "3404bc7dbfb33b95d922d0693aaf9358f77888d7d95e773c38d83dbe2e5f995"], ["79f09ff7c60850e5f5ea020722659a1ed27db4c95dca131f99552f785c8afbc", "40429528c099349b426ddbf129497176951a64a53db5f9d8bd2be0252cb22b2"], ["4027dc6b56d446e5972f35464eeac85c5254ef377c902d9fe37aea841bb5292", "7c3ea37689ef679fa2f5c7e031a78e23d484a8317990fd34d44d95cc1db3717"], ["645dbf78a3c228c4b7151450b5e65edb58e71f37e1e4bc5f471e0f1abd6d9c2", "15cfe7850f327b256e23b00627451560c5c6ab60db78d45b7ab286afb6f13ab"], ["1503ca373757677ad1d911a2b599d01c46eb879d1ce21ae171c7e439846a85f", "583eb269b7030da6a0c324026919de3f9489d2ff6ae0e6320c36f05469ad66c"], ["66e1819ba3ec4ad4ae9f7d7588d23baa004e29d3aad2393d52af204a81626ca", "505249980cbe6273b82ad5038fe04a981896f4117345ac1abcc67e2525c0ee4"], ["5ec20dbb290254545f9292c0a8e4fbbfb80ad9aab0a0e0e9e9923f784d70ed1", "bdb1ca3a859227cf5d00eaae1f22584e826ed83b7ccdb65483ed5213dc4323"], ["a5c1a5011f4b81c5c01ef0b07c0fbf0a166de77280f0ae241f2db6cba15194", "4444521fb9b33d7dfeb1247d0ee1a2b854ad166cb663d9dd2e686909362a689"], ["1f35335de40e00c62642dac2fda8b30f071986ce4f11db849df11bc45ad4e0c", "7801a2c761b90fd4477ba0be9a775003d5dfcd959b1ed198b4681f15e7acbf"], ["48db4798cf6821c1ffb8178b1d3bb6020e04186c96aaf4670972d367f4ed5f", "781019494df95b888f1578f1b4a3f8e125ea60eca47ef9207a10630671217a3"], ["17f653d904210148a8e74d8e719a3061683c164aa6d79c902a19f185ab437bd", "6780e97985932c3860d810af1e065d454b1cb4be0e7ffe2d8cea7d52526e223"], ["5c4d0c7432f9b0070436240f9855adae1467cdc9826952ae01b68cd52a3ad89", "1c5747f968ed91261b7ae9bf1023c999da9816e37de602d6a1a50d397752bff"], ["6fedd7639fdaa2f7bad4ca0b391710f6f8a7e890250ae8ae4252bb8b39a1e58", "436a215f655a3fd3778b2335ffdc9aca6b98474e43d764c1f8362830b084f0e"], ["7fbd45a889c5e9d127bb4f8474d6be7cb9796bbfff923b75e42a1ad4cae37d6", "484bd12622a6ba81cd53049c550d9ed682a8e765b656b1cbff9bbea637bd1f4"], ["17d984d47937263f7966a3e7b1eea04071e678494bd749c9e02b48b3234f06d", "7b341ff08722c4e161005d0037204a7a2001fdda7af2cc1a0b04a027f115a0f"], ["7f1822045db45ea07e1519c3ee1f7705915f35fe4dd8db1e8921b5d1c740edf", "33d41e06b93320ad1b3d9580380ec797a05dac3f1cc8008899110ebefde2f78"], ["7b19453ecb74b7d0e2a66b9890ff73bfbbcd61a266abd6d82dbe665bf32f34d", "6dba2355420dac582b1f349609ea1c89b89bba2d1a68a0642f1dd12d86e73cb"], ["273e82a15f395ddf2489a95685bec8bac62c4b459d1b28987d3cb27e4bc9128", "653375b48a4cf5d5b101c9ef533039bedce5dbeef3f59e8f168bdc99b06ca5f"], ["3006c9e7fc6a553d8eb4e8a47ce9f10d1a39576ac255ae9e0a4ce3869e76212", "65fe9e2ef2aae608be309332d464f57e28f1df5de1a6a519751b056971f932e"], ["5e8f384c8a4607fbe9789fcc52d54249d304d698562597d114c1d81452d3dee", "3c8bc78066b5d947dc1e405e326ee55ea606c7988f666748d259850fa259a22"], ["7841b2102e9aa103fb53a642b3e167b21113ea44751ab38e0b5ef8312654db9", "71bf5c8308fcf9c4a7847494cd9bdd946fddf7d3a37e8bb0b201ff2343deb8e"], ["40f68027420c11e3ade9aae041978dc18081c4f94943463aac92d887f922a62", "499c6062594a6c7e21a3cb91ea451813393bff365a27a08f1a515439b83cf42"], ["6ce77a50d038b222634e87948df0590b79d66087b01e42b9b6d8fa30ebb1465", "35f5c46bb1be8555a93f155a174d54ec048c2ac8676e7c743054ddc52709d37"], ["604f8b9f2dacb13d569262864063c2d4bb2b2cd716db6eeb2b1eeabc57746f6", "68c6799e24f3b44eec3049973445174727a66970f1614a782efa2b91ab1e457"], ["73d620f3bfe77f672943d448d7dc05327adf64b8e7af50039c469d7f7c994c4", "4859deb36eaf0c802f0d1514602368143a33ec6ce8fd55248b59025debc6afb"], ["3fd2bcd1c89d706a3647fbd354097f09c76636e93ae504973f944d8fc3bcc1", "677ef842cf5eb2444941f527abec567725e469469192354ad509a26ebb3d0e0"], ["39222ea924ac17b533c72ffb2c47ffdc11d6a7f7c70fbde3a10fb0b8f35eb2f", "20dc4bd1089019bc1d7379b4feb3eae6eb5af59e9f253845da9fd633057e952"], ["326f58994e1347f62e4102183215b5db956378d2f61f14aba4dec94577f53c", "7a03284c296003bbe05178a1d82efdb7b8125511d63e20e50aed789c2e52e1"], ["53aa8939c74d4ee58f03bc88bace5a45c7bfcf27466201da05dc6723a5f5632", "2e32535ca7732904a048183247b04b426ecf9b39fc393a9cebe92fb1dc7a7f1"], ["6cee1a03145e93b3e826e6067005f09c06099c98198c91c222407ba5c8c132e", "beaecad1274e7c6e5476a100c271aa1a6f86ee5a9fa5c2f26124d5886fa63"], ["3ec659b8175e1be1bd5a252108714776b813e330393f587814f5f1f32a73332", "529a5cf9f8c237ae69a94217d173c8d19c156952041f5c980da557990863fa7"], ["3d66ec5963d0c534d4139c8cef2e1ac48b3e7965fafabf58be26f903318af4e", "3d3f2de7a95f59b683725ee6283cbaf31f97c4b600df9a4621413223a468740"], ["7fb38ace8e0932fac2ea0d3eb676db8d684db1817e2e4d59da7996ce398b4a", "68f92bd5768cdd4710249f9d49ef1d5654e497b9a4ba10bd2971366d83fb400"], ["1c4a49314d6b4969cdd142c76ceb7682bfb868ace7f7568b0fc8635bda5a9fb", "5fc0519f1f4cc10b5771312458748c036313b87707ed0540026ac64a5955aa9"], ["3073c95d08d3b97caea5f0be16b2789bee766f76b7e5499f8ce8f96abb0f344", "52a8974b4eb9a1f6a0ae2c83cb4715bf18d73f057255fcb3f63b74f7e78f590"], ["44485b16d597a5de3604df6f7ed7e00b8aeef9e7e8dea8688255153b8bb16aa", "6cccb0ba170123266f24b5d93a744397dc2c44820edc4f8f5b9a0f5c9b3b940"], ["7618f77b7b32d512688dd62e0b48231d9574c6361e8be353a7dc04f7c3a115e", "78ffcd16d80636381ca231aae70d99c9e20298b4f5388fd823ea9fa2b8ddfd9"], ["7dc82fee1ef95cf5b3720fcc07f63246654bfe39762627839da40e51c75654d", "4c0ccdd70955da74558de20c88352df8a02aa97e4d5971c500e884740a8cb62"], ["7fa5d460dc10cbb418b444d9bde97e92c70a99a222b99f244dccee7e62cc04c", "636163901baa5b7576c38c43407af578b8c4607e01e86011ae2dde587a89f84"], ["758930d46006623a756c89bd0cc378f6a3c1f43c9a0edbb42274c35e75c16d2", "1d74dd9f81c2fec811b8cbd6168a745b0a111932b2a345265ef2853b50b6245"], ["7332ee0626b044d664ef228f8cb84df7c643e52f6a2591ae1c9007ad61ec16e", "229bd8e630572cbdee54283234cf3e9f060e6382f99943bf234119d47b54470"], ["78a16ef803aa20a075bb2f66c61bb2dae5698bebb94a0995fa74c3d53de1614", "246d588b68edb6fed96c128349908c42dcd64c46341b205e79f4aed9b5d3675"], ["6e1933939bd03b67bba753cc0cbe7d2f25bad68c993887ef8c9e2fcd59b0647", "599413f7c204a11a5ce315eab11299ab7326603412bb00bc1c59ff75a37d6b4"], ["4a79957a5a1888ad063b51c69565a2b48e8eb917183e220a1c8d3374526d30e", "1f092de0e069bba7fc5386e2e9a114c1618f88c4b95e220cd35ffe96f99fcad"], ["3148aa3df9ece39aca84f59489f2710522216f14be6055ee0027529d1d55e2d", "617e9a52a92975db0ba1977f71116f7058a0d31b869ac7f3ee2fd80b0c5100c"], ["5c1188e72384160ae39d07328346cda4f6c12d227448e6236f04dc971625287", "1643006eb3a3bc6aafd5f685cf054f2a572e6ca58c0118bcec0b833741f116d"], ["3f72efc93c9b71adc4c51d8fc69d3940b20d08733af2b7d05140fdb1d1c1004", "7399259987c8f4ebfab46e522380707e58427d3962ee0c2a91760813f76d232"], ["3129b34c03c51aa8f611e91d5cfcc9bd3ef108ee66e6d3ee35a0e0e50055bb", "563b18b5650085efb4cf179a029e6afff27b1d3091cd28eaa68d24fa1f801c6"], ["16eac0f9fb4c67cf89a7fa4ee615bbe731d8edcb709a1b9b50c7d873a530f52", "7ff8288b6e199ca8f316192881424a37fb080c29daa76b1f0edaccaf580a80e"], ["75f6b6028c43ce832f65d7e8e620d43b16cba215b4b94df5b60fc24e9655ee4", "35e9ccfaed2293a8b94b28de03bcb13eb64a26c831e26cc61a39b97969a2ff0"], ["3c6152fe093bd6316897917ec56a218640ec1b2148f21db9b14fc7a5ff362e8", "6eef2df27ae7d63a28856b07b73e7aad7ca94f317201a1e675ffc6f9a1710dd"], ["54e01b5fe4fd96052aad55b3f26b1d254dfc7e2525fffb9ae0a77eb8cc5579", "7c3d39232ab333675b219abc766ed9b4782c840e6b046614dedb8a619696eb0"], ["d1e63f8ea8a76429cf254a6d3b668761f0dc572d4bfac4fd56d9eaf58fb6c0", "2bd0a84d3908a63085824c9329a0983913006ba155b56a58eb3f9becab29c45"], ["2d6122f2a702edd4da7385b1580796a71d13bd72be94cfb3fec01149c006c2d", "70eb282fae992efa6f5915e578b640653549f23385ef3a29ab29b1b9b8ad63b"], ["752fec14beaadb5ddbba6b3a17fcb86579fa588ef407fad0ea07dbb22a640d3", "3feb6728eca21a1e84e8f9f23010387a53a96a1cb62d86fb37996150a1299ef"], ["63f94a92f27acde8f5ed949b459506f51d70c85bcc61a34d647264ecc53c65e", "37e5dce0646ee66f4fdb93b82d54d83a054948fa7d7fa74ab6b36246fc7383e"], ["d6aa909287a2f05b9528690c741702c4c5f4d486c19a46c38215f52ef79c7b", "5ebe1128dd81093df4aca0df365d58adab848d1be1a94b95eeb649afd66a018"], ["12866812b3053e2f7a9572bdaf5ef2b48c6fb62a0eed9ff0356df50e7d05557", "6785f7eb2cd1c120e4c7167b46861d10117040a2e9f2ca86a71e9d67df90613"], ["46a730d05330b1b13673cb8a1b8f45460035e4a9f1a1751cfba099c4355c1c", "76fb0ec6cd16a8141cdcd875c8b2de9fce42d296072643d148ac7e7fa7472df"], ["4bd4380a22900bd34835e0a908eacf4b6edb61eda0cf483f9212453b37e7516", "5e9551cd20d8d7ddbf4366880b7d5267385afa1966ff30da4baaf273b009d29"], ["71f1994ad40baa2922424ae222663a64f93d8b67929e9a10f9e4c1ab19f3833", "85320fe68ec0d37cc19fdfd03589d66906ffa4046c80e1b094a85f27676346"], ["5a63b1bf5232f28f808765c6be7ce1f81c52145b39f01c879fae0f4303bee61", "3bc5d6df68bb6d0577bf9ae2ae59ec0e9b2dc7dd56ea179fb38a41e853db950"], ["161ded55ff1087032381e6c1449704f63ad2d88df82dfc44a71890fa09b3941", "78a52e0013842037274ea75daaf8eb4afc04ccc4b07bfaf3f5ee47d165e01b"], ["1bfce5229c5fbff5c0f452a22317fcfcd9262f23df41840f84fe7d44cfba1a1", "66b387872c00e63c73006a955d42cf49c46c5708fc9d1579b9ae38341b24a3d"], ["56d47dadc9cbd1dcb2ee3efcd5d4af5e6aea71df10815c68b54a14e81d11b44", "47e966ba54df48e9b612a903685e0060a67e4725402e8cb4cf654e54e813a3e"], ["4b1c44438afd4ddf20a2cf612df2ee494ce84c7274c5529e857693e73018491", "430403bd31d8f0677e06abff7159384560f27b9622943fea1a3192f14bf40d4"], ["7f7281728fc2214aa1dbf13176a4624b53814734abd570eb6ef7c7e32379606", "312da47be347fb3fa2c9089b38df372560dcace2effeeacab4d96ab11567295"], ["16a28884a1be8183e0d3fc0db84a9afbf47126fd3be548c2a584aaafbfa7dfe", "7c3f57b3b895564ba562c1cd80b71fda6d2e611665c6ab87744f5390858fe24"], ["323339f37b327a731232a9580e79952063c7c232bd1380146d8a83c285f4b8b", "4f16be1d983c7232f92cce6b9690695978d42cecc8eeb8c206e125d1098a265"], ["624d26cbaa197e104eb83cebf2adeed09a5cdad359993fe5e3529d4d0def21d", "261b7da3cfb55c788977e0d8d640e3e93ae5a325d962ce85c816d7d32cfc430"], ["f24ecb7ee83a3e28dab54a330dc93d0429a7aea36412e922dce8fbff40d60d", "b043e36a258d1df1d21b0cc7be9c4dcae1bd4ed326c110e668ac23d86805a6"], ["686cea46b710bde1231483bfdbc700cfa3da6ecd5841c0e0c782f9ea24328ec", "7eb7407aa58edd6911c7c7e8d1e03bb52ead4a2415a0c33325872ff3a521dd6"], ["3866ee1186264549df3dfcdf8705c0380c9372eef6d4081c2454d3aded1720e", "634c6d3e8eb8af652a4be73e3b613452c2213104ca875b66b4b15ee5b1716af"], ["484c687cd2969a1d20a58cdfb9a60f280a473284503b1ecff5de514aaf8206b", "34d44d26b7427e51a646d1b924084762f5b461685450f21d6a472de565bebd8"], ["203561333771fa0fe22c4033349f7b877d15b0542a5598e81e067968768247a", "2b6a533aff6e2163a36a2a89cb7415848bef48db40f952ffd380f47676707c2"], ["2ffa6cca6233695760251206fc5e34c8d3692498589478cdd3d5b09f0b7c05d", "6c57d605478fa9626c4ed769554d075daa53e1a1d0bd4d94174d3bfeeb11ad6"], ["5dccf0fa46a5571f204d0b033b45f299cbb3d9f80fded57253ea4f1c64faaef", "30a38e131ee8756ee5ea2a3e16618a5dbc28b5b9311308bf037ecc2039dfc7d"], ["57b0a2eaebeafd950221facdd24790d7d1ab8883e5c5d55635f0d14a1ee4741", "7b41cc478fa6be38417271db8ed12efc0da6982552c1496025d2df0576bf4ad"], ["611b5725101f611c387ccaa13889ecf3bb5595071a179ce350029bfca4ad7f1", "3129755977abc8995fec7eec1123a1561e429fde37ff36af002d3211831ecf4"], ["1c06bbd0c52fdab9fcaf680c7a93fb821e538a2ed79f00f3c34d5afb9ea6b31", "3873d3bdfe0be0157bbc141198dc95497823cc222986d24c594b87bd48dc527"], ["275cdbabc989c615130d36dabfa55ca9d539ed5f67c187444b0a9a12e5b7234", "2b7f723e68e579e551115d56f0ae71a3b787b843cc04a35b9f11084b006521"], ["6cc702eb20f8b5940c7da71f8b1801f55c8c2d8e2e4a3c6c983f00bc1ffdd95", "5d15b3727bc66f3aba6d589acdd139fae115232eb845abe61fbdfc51341352e"], ["44defb418700cee8c9bd696b872adb005490512d8bba081f8f99a9f15cc981c", "3b2072cdb1d919b2b65b5cb3557f0a3381d7ca293c267ca4a38f83e77bcc96e"], ["fd83ce77b1578b3a9b8c3cbeaddb1504d2fd4a19c901c21ac65961224e4966", "110cbe64fc10c6b9c66f15ca406a35f50b723b35d83c5eb9797a57f8395f4f9"], ["9dc6ff90e341875e113bbfb507724dc7095a280d2f32cb6ba61a1e0c2d2aef", "4aeb622896c852c2747454e8f172c9482955a42ecbe522d6ce07ecde79d0a51"], ["71c58b0e47b9dd9107ebd8a8c8fa9f0534e78231bac612c1ddc7a94edf33eb7", "7f90edaf4792bf8334adbaa0f4ee7c654312725af188682d75f34874c4eccb9"], ["1f6de1f14988778ceb2dfe844f92394f1f1e72fd1581ceb3bf336c95ce50345", "4f6007ed4e022d2ee9fe4ca8207c5f6c766c4f3b85260e941fb24ad0dcbf0bc"], ["3ddc3ac25ede4a67a97547ed27dc920239b585fb3624177e2e8d59eba678115", "a9afd8f8bb759cbd1dff2addc63f47da4ba1291ea34229c09c0637dc5c8d24"], ["c56b0269d8431556e471cab9d70edda3a37b391696f107b2dc370631de51d", "729c52f6b134f733eb750c14bd9f95c077f0f6f6ff4005701e5bedc6544599d"], ["44d32ce19ac6807cb22e4f25fe1486a36a13926f147fbfa054b63ff0446177d", "212a21e8c124c9cd37c80d2dd66913ceaa6b6f666522f115c39382b2d5925e8"], ["35dfc16f3ae6ccc06a267bf6d931601e52f3e45359ffc513570b65b96adc4f", "74311d10f4bece01b5ae65a6affe5c931463aa1b73a3320eeb41bbb7bb1ff62"], ["e0acd9d2d907031b319b80121dc90699d003d220ea785d50e5033cdb3b1a03", "3911ba78d6e507485d6374b0f7d2e6198f6462a7d6d3cf046404a07af690357"], ["3c57918ca254c0cb7dac251ef4e10c7d82327969552eae15d26c4c52660922a", "5fd5f5ff3f14e671548074114c72c48409df8a2e71fc8aa3c8acb506e2a88df"], ["222ad8b61e219ba2b581f606b7c996516850a46a3db72fe1f72b5a9be6c324c", "72015a5e2db648112abd284fd867b59fc5606645177d26cf6e9a655c9912d42"], ["3c86d5d774bc614469768ad38f7be9a53e9a233942c5c553b82e49aae684764", "480febea8229e130dedffff89c11f3c43e11724e6bd89d5566d78752859d41c"], ["adb73bb8352d0c10175df371f7868ef2c9e0c79ac788430c480c0f7d85c187", "60b564785248111502e6f39c4994d6293fac22bc25f4d764b2fb1957d3c9bd8"], ["3836ab8b46cf4f453a22532c886940b982029b29c42adca90ded5bf77e6bcb9", "7b15e91d6355f147b171a90b064a9d8b2d7bf3699bbf4987664c61c950d8996"], ["12ed96af1a97c45ec31f1531e96f6fb28a03ba52ab8484545fbe0dddc97bb32", "6d1f522b6c6cad0940cff8e23decc72bb8d4164696af031415508b025aa8be1"], ["27382994ae5878223ef802e9b4882f481a1b4008f1eec8484483471f7aa742b", "c31750d242b3975b0026a0e86ccdd17d0f680a8c6f53f197fc25eb1f777917"], ["431677eba3715455bc235557518a74f3b111a88844ef13e159ad44bc16de3e6", "30000e1eb6a17d9df776981e65c6e500fded1ac12003adc9446b269812c9197"], ["4b563e6f42589671579eabfa2cda5502b361c46a5ac8d45c8ed44741a925b33", "627bdb41678443fdd1aa607709e9699b652308615f4bea760a3b79ee0d9ab5c"], ["2932fd3f81fc973ca9def6b7f1bb50f980fe589187cfe9e9f52ba4d356cf2c8", "1e6bfd00fa976c4770263a227048214c38850fe0f059e7b3d2c7871ef07d68f"], ["e44e4f3d96d9dec775b996be57e57fdc28e7c68023109b221c414a244a0dbc", "58b1e52fa274812e5184e00e9ad812bec2463140adfb4bea3b2d665867dcc9"], ["7fcb89be1f4bec745887bb891e53fefd665c53d00a9e74de16b8a7e1f7adfb5", "74af0b06633f779897e199609c71cc5649bbb65bc2c0abd4c678f0480c198d1"], ["62a381ffb904ea3ff4d451d4c8459457cdbc3dc2fd2da646a95d8c1e90c0b7b", "1ba058658e09db9e319fa73de8ab4a992b71e4efc22c273725bdcab84e2a315"], ["1b0fbb7a84c67e668450a54449c7a46261a2d355589f8b84ebfbaf9a77ee938", "44f8fffa33dd33a6146c35d196595e22cc4a215f61ee9197cd751400970a1b"], ["78fe920bd96a356d4d95ee34adafe8fecf071d3107c36f047b4024ddc4b3eea", "6162f29607fdbec10181fbac6e57d5cb41b922c5791fb24bd28bcdd75d16c41"], ["5629b849e026e65d119ac11821d7ab7efd9c52226f75c7427505d6818bb0c8d", "1539c0f90970ee8b490e45bbe5568170e5708521a0e59f976be680595906feb"], ["62bc853f349bac8c6e5921d27ba85dbd9ba20a375d70a7bc008928f3e123b04", "6acfeb1de05ba43c3ef1a9110a983a320e77b3ca294abbc04aeca19b194f26f"], ["4cf4bed663464418285cbae359b5d84ec76b5997d24f3640984c7663421190f", "941f818e3e3e8fb1568da85217d17f9250ebc948379014d900a7b1a848494"], ["52ff3d9ffe9a302f6dfaaf74bab57c08027d5cb699a69b30830540c0a2d47a1", "987dd8876873778d933fbfed37aab2f7d6f669c37024f926b1edcb2ca55782"], ["1109ee32f0bc53de6bfa457060b366e909d7c18061ec9845f46ac715496897f", "38f36f172bdfd454b9285f86e6bdece8fdffc95182c7d801b03c671cc55139b"], ["4b4482f1d84efe23dadf3bb10df3dcaa251312dcdd604f616f1eb540e1f3232", "7c9c149dcae9135f940fb54482f9c3cd8193721643a6e23157b8020410d439c"], ["69cb459b9e415b7581ca163611c470d875971d5d7949de732d1f0f200544a73", "a7136fa9dd00c0469863b7def3f83a5611ed628810d7e807e7a873da5a9897"], ["b66a4e32ac9a4baa8f64780acd94ed3628b2b0ea874ba4dece629af65f9e62", "24328ba9996a24389658e3467b8b90dc3927ef8419fe28b3f55b1c1aaa51915"], ["5ecc3080062dd451236de0e4eb91c5c75100733364bc5469f5fa76f79021ecb", "6da4abb9031a27b5be94529324fad8026e7d871570780081b0f424d4fe543c9"], ["1e3146f00880bb22486d5bc73e54367d54251f4002bcf342d0393b05a4b9ce0", "23b6fb8e945d3205f633ba724202db5a99305f807137edf942cd60eef867699"], ["2e1da8013285598b899f026c6974185db12c97b4c63509769d3d4ad1d18a4e5", "1e7e7b668674d1593c39d58bc7bccbf568208732b3519bc2cdf93db34366862"], ["d26c3f389d81709506f184b53871497c8d36c5c9eee8e3737358204c1acba3", "34649c3d39f3b825947fedbca215ae30c5a5995e93b1c8efca4944cf85a082a"], ["91300478a83595d548f32f259033291fc7d083953b0b8bde88c7559660c563", "e5d2bff57fc6551e9b80c06ac7314a71907cdcc66ce82f2cce721a670df10a"], ["1f7abcb9d462c63ffe92aa56619ae8590089cca4d93ee3e5f34a63882452cc7", "7e9f85c7b7ca6e9a4f3a026d1048adbeef69ea9d876c6f647c257b879a81bdd"], ["4d2caa1323012e4c83b0ad387308b8aef5637bc35ddd882e7f5e41cf2ca410f", "47150e808c81a540b6f8864e9d6636589cacaa516f82caaa96506edfbd6f0e"], ["3c10a6083c38351deb3e6d1b386827d0acf48979b66b95249eb8700ec26b069", "47e34bfe561d903cffdd1d849b85aa3cbd31cb4a9bbd8cc2e5fd2f95016cabc"], ["758bd54868eec045d0b4d3d2bc415d24bce13fee47cefdfda46425c109b657", "3392a7c66ea3bd7b044680bbe9f78ae86752097404c067e9d2572f55330df83"], ["19e718e0ca1d2d6fadbc6006ee7dda7a385430e29f5e239cdd4bb7c3fdcb2f8", "5c68249b7fe03ea2e13481a63b6cd4bf74ce42009a89fee0b3f8f968b3ec709"], ["28077f57ea62401806367e6d54fe45d02de5b072db787ffdcc3854e12a3e855", "14f3762689072f5fb41d03e94b01808c739f6d42b7b785b0e464100b150efd2"], ["3b8a8cefd017363ce867265af3293cec081fa589fe561830f0078778cbd338f", "69ccf2383cb7b4f9c806d72535812483e7c5e9a1a5928529d64ca7e085e758d"], ["77878f388d22161a2953e5aca6bac1ea480e102f329574b4b201640d44a296b", "7eb35706a90a03aff7c2fecca72659136547cee98038746db5aba16fd7178df"], ["97332e6da70961f2ef31b7b628f1018d21db8db015922a301fca7d6fc6a8e6", "2e37b06f639fc7a82601b744570a2619e543cbfaf60e474107fcaf4686d3223"], ["a81518d452d3aac48bf0386c3ff170ef4e684a4def242c964e129c64f4d647", "37506e44c85908ec7b7adda9547fbdcc2e3605151fefa77fbf127ce3bc938f2"], ["e80336b2220b1d666074f6b0dac85353d0e4c2e8bd0f37055a2236a6a9fadc", "1cae76d73eda7a5964c5d9d3ad6748aff51f5543c56441d2fdb7b444a39846a"], ["2c01fd8430ecb44e066f352c4f697fc9fda177dbe162f82862d7b9ea8c918de", "6e1dfa99640fdf5b30603d34c7c97c1aa6e6b7f3a2c52a21fc64b0fcac7d591"], ["744e37b511cd0ddcfe15f3581947014c159de81ed055d15a13c7a2d1fa39f0f", "685caa8ff6979a6c63640ac638a3f9c75737f2031bd55322a47384357af164d"], ["40e627ff84e1a7a9068b4368770f5956128a4d9e9e33e9cf5e24d9a242149fd", "2465bd6cb20bbdf810e2bc5c3c458cecf4f3aa163a7ac99c2579e5f33417f2e"], ["5f635af7f554a17bceb6ccb6e637abf89ab6dadd399189b0a0390e87b1896bc", "2aa6238a69f89665646c0e3ca2ba5f709cc6e14351cf71e1b00ec45201417a2"], ["5edad3063c9fa8305978d7e6a4e037c9fa519b8023c7608dfc3b66e5c1e8985", "49f405d07d7d01919da51159ecdad1031a5ac208c026fdfc14d38f633d92183"], ["2fdf2e8a45858c12926a1f25a62255fb2d02d0149a15ef669f859806683e649", "61cfb686bb31e2524470d4ad2ae09e3cc91b16305a21d748098feb1d8ce3b3d"], ["ecdbd7c37f1dffa3943977278da3bb429afdf948b4ea6cdebace3d3be82381", "190b67fb34f7f3ad6afd3d6b6427aa327547d8ac0fb4deeb0feeba1f63d6c60"], ["233021b483f578dfa5222f8cccba5766ceee0ac65f6d4a3b1673b302a21fb3c", "7d4b6d44d175d4b593f06f5a6dcba2cdbc4eaa2097abaf613123546866cf4ef"], ["42db4e953c2a7a743de9fe20c5798f2247f51db4eabc6f40e86c13909a310ce", "12c1a0764a0b9f3666e431923ce15e7fcd0ded5ab153f0b48d362cca1604e65"], ["30d539e2b545fb957e40e2255f6463b52d227c9808472cee6a3d521aa283a44", "5f9eccf747fe6313570f99e845db32b40070acee9ce9e34da7f3c29ca53a07a"], ["4bd64e5ade3e2733580a6116b4af328751198e7128f9acfe3a3496b545efb5a", "4d584768900dabfc0dbaa086632b8051bb3905ef79b84d96c01514441d0cc93"], ["62d6e771f02e591557197d13c3e77dfa2d1794ac1808407bd8227c4be31b466", "5c6f5607c1808e899ba36a425911fa8566b7ea9cc80de8a80538c0fceb837c0"], ["5ce406218cb2852b1d2fe1836b19462f664631785216e87ffbce26030e2101f", "5225f107743c255ab50e7be4a090fe39478d1ef4ff558468559d8cfa87bb94"], ["670286486e8dda3dc66b0ed3149be7697d3e06c8279844079daa7e42d5af728", "26becabe7430380c56e320f5ae3329569cae7b0af06fd5327ee23979d200eb0"], ["3ef448df33a4394c43e93e5850cd0c5a6dcb18ae1cd865d00fe8ede9336a9f5", "56711f6ab7e0e4f7365ac34e284ac2879f40208c46f6febcc1dcf7146ecf015"], ["4b63fc130288e92f2d6ba238caa7a6364804e29829ac037c57df32fbf762bc3", "1eb8c80af55278b4113286c038fff2bfad2da62763bb03426506b869139da0e"], ["4e7e998557b29a95f805a6e2e26efc1e970108272d4755738c04f28572295c0", "97cfcc2f447bde61bde71049d8200a74a3028b21703bc139143d81a3623f09"], ["574b67898f02964c408f68e9470e7b615be037e40b824e6617f89cb56c21219", "49392d5f8e6740a1b0b7444f56d7a17363f8656c6e4c628678c86223f2e46c8"], ["7e8cb50ea5d5c1b09e219e7305bcb601d99b6d7185b1c388aa8e36fe1e56554", "47fefa308645455c12ccb5817da338f0c4f423b341aff4a9d158891a4fd69ba"], ["67266dea9e71b4ed2bf24a597a823dd048cf31e725db511edceac72998c9ef6", "39babd65850befde1f7c28e41dbdbb4caf82bbcf3bcb5b33161f1c2960b2d8"], ["63e99c2cb9c74eb9227d48065e27abb8f606df8fc83b2c44e4ea38b046bad2b", "60494a53dd13ecf34e08079d343c88fb655d6d810785af81f08d5aa9bcdcf9"], ["3cf0600b0f5a2a4eb78c487cd385350e8c7848e3f6983231881d7f1bbe28543", "56dee4288528de609976ef6b903b652127c37b0590e91a2fdbebc3f11df2628"], ["758f09245fa4b8b23d290ee2b3bfcede199b4fdb11f3cf2502a8ceedd61b129", "622d9baadfde781e985d9722e0a04715666769a4cc7a9bea0b96d6386be1746"], ["38e1a45b81492aa95d7abea2b08b8c14dc0b8a41108b036871fb737910ae18c", "145c611262656385e5ed6243568cd3f9f59dbfed7a01ba11e22bb8bb272e08e"], ["206e54ca53a2f155bd4fc45bf2edb77798ae6623defd4cf22f2dd4a7d119dad", "6c94e7f0825ad81680e4cdbcaaaf4df806d57a0d1fb2331926c3fe2b79d22e8"], ["56e98d2862893caebf66180e84badf19ffc8b53041eaaa313ae7286a8fac3d", "526306f9c01afd6e0c1198ea5de17630f5a39c4ecd02d8e6f0d613c355995c6"], ["4fa56f376c83db33f9dab2656558f3399099ec1de5e3018b7a6932dba8aa378", "3fa0984c931c9e38113e0c0e47e4401562761f92a7a23b45168f4e80ff5b54d"], ["450cfaadfecdb8a2fbd4b95c44cb1db723ee5ac9677c9c188b3d7c8eff4ca58", "1a552bdfc0c81be734f1f6ca9a6dd3ab4daa61c11fb53ebb7046eee25d617c7"], ["6fe20e5c8a8004e33eafc84d16ef770f2f0b7bace19adaaa150f987d295a34d", "28a35040a2ebe9a14a162d3208d5eabc6e2f3a8310f926bd80be65aa71775e2"], ["1bd65f45a35bf62ae8f9ffcbd7de2976b90518b6820c219f039c50043bb1edf", "fb5f0f8659f9b6ed7cb0ddd7999506d0c20b26bbe69d1915a31842cfac41eb"], ["4ba4cc166be8dec764910f75b45f74b40c690c74709e90f3aa372f0bd2d6997", "40301cf5c1751f4b971e46c4ede85fcac5c59a5ce5ae7c48151f27b24b219c"], ["21cfbc678f5a279ebb6ed124273c8df37eaf12a2d04180403ae6b5ec0b1e1ef", "4478ed6a346d899ad7b0b10350270aad39ddd5b68529297e4c91a54357f0a7f"], ["350bfefbe3d864eaadac9cc1195c14159bb736be743aed7380d2384cadd2046", "5e2a4b3ad0e1d7b9b8ef72b10d68a80e5ee691d7db591fcfbaad6240d41da8b"], ["529acd569127f73c8d34345f87e96cebfb48ee12a00a3861cda209337ed94e6", "3120671a89b705e5bfd99b0e7fd2118b4914a3ac309b3d74527cacb5ad7491"], ["55d3d7956a97d10e65a4d8ffeba40deaf0db0b57f8e022cdb3df6df613f5c6d", "159e59a6f92f48fcf85aa96c1a03749a4c4e2cf9e2bc94dd36796daebd9b8b9"], ["405f019ee8f2e972a005c549b0884b5051f63d1e78480b73208dc07d8c65a1f", "4301a3d0c285ad309ff24a12c100ead7f48ba1368143712f32ac141ab4d9e8d"], ["376d59b298d982f02dccad0edd5bbd4e5e8fad7898750675ed0856850a7babe", "5233b12bbc50564eb61cc098a17d3d97f06ec7a230380e4c5d3b725cc318eba"], ["2f55624af6109ef04b2ed035a44a904ace8627f55889f011f768aabf4de9a38", "7f64209ce7dfb63337ccf3d8c14f4093295f86996cabfee23b1655549aca089"], ["3b8965e942bed2714bc2e685fb103496e1e3595ac6a343d6df45fb5ef6979ed", "5b7cac7a165cb69ae103dd9052fb39c00ed0aad47989005aee53972d82d45b5"], ["7abfe3accdec1eae1a50049efdd9a8eb7c2921a08e8bf1fe606e9d5a4039ec4", "3af178e7e831f8148244d2d2b284a32991852db6212ad0a9d77540ef648a5fe"], ["4983196df6ad7d6f0a8d76f86af3863ad8611374a03fc0fd00793181dbde9d", "204c1f91b70f975a21d24a8face664e496f00f602daaafa69a3b56098a4cf89"], ["79e2b91c1531a3b16dbd53e72d94e16bf265cbec261658151acfaea3718ea72", "3d9bdb47e8b148c1c5e9e694ffbc2cf71aac74ae1a85e8d8c3f77e580f962eb"], ["297efceec61b3be17565843cae465c52524b4ecd9331a4170f54f7de8c4556c", "6ccef1733624cc8b973ac63dd54e7a53604929affe81c3439525ae5ed6af993"], ["44f04b1966264a23ccdc870c8563ad2efcd4c8087b5469b90e792287a5581c7", "1c417f0e9829fa3d3cbb7c3cf4dc7aac04c5bf66ff3f86b833a42c533aed1fc"], ["6ff83f5d8b51db3be0bda80eed2e2adb7037f2f58f705e88f0f98197431ac26", "64f59b8428894c2b7afd740866065ded42e716c7d48accd3f117f22768ed9fd"], ["14aa8187c9559f77cd1cf96b2dfc949182529936f2b0b4050ea56e134073b24", "5f36508c68b1dc586f3fd3f4e2bd29c6d8258491b8a6aa19ede811ce0d3d0a1"], ["95e8882a68c5000d1c2be7c0b43e7f2a6f8de906485241f0285a5c73a27a83", "1e4cb67207ab73bc1e5d19fa2146fde6d03021393b77a55df4ddda1fd28f5b1"], ["2ae0704dacb3da47d564514b4c3543505b403ba09a248c6e74593cba1867ff5", "5a4b5818088dc9ef4066b90a8893ae80fc89584f987ec1928ef9d72cea2bd67"], ["61a10898a76fb99989e51c0e823cb60b95ec7ccccb917c42b2b28014f5fd94d", "23d8ec1de45366d3b86c64c2da05a2ce3d171adf52ca5522e652ffd0eeee795"], ["79884133c879cf07734976fd64de220c5a972e04c2a3afb74c362d6c3beecbf", "2aaa0e6d4891b792b5643fdf09873343cd0e3fbba3cbd0601b481a4083f32b6"], ["45f73d2fa82be6c5ccd0f62d2237efe8727c479967d27cce28e42b9a44bad5b", "2fa4932215f72d56d8be5205c5851c9b3e5f2a14468e4a7acace5437c6b27dd"], ["37f53f771850f52f9c8f87b53c6bf0c93c2bed76f5fd1d5697356d0b2325007", "50f1a052b79b446fbc7b93ffa1a4515f6c3be3a76a2b0bc5eb8ff327549960c"], ["71bd6d23e0d2f312d47582efa609101f15b9ccc571fca8ac4fe3457c67fbc9b", "3b3fdf86bd4c7fc26d60540a6439b4d179dcbf7b91efb0ddc60dfbff9a148c6"], ["78219ba049438385b829c13a4993874a4a326c4143de0dd581c7b9956f99b06", "5505f1268dcdd4ee01b77abac3bfdcbf3f0513ab097c69ff777b4a631aaf256"], ["b81e924a86536dcf68bc5a2ca2065a61103ba6c9eb0ae4cf8cce9dbe286f15", "653a6dfb51acfe8a844fb8362795e5549d424aed88d3a090366a44f840b5b83"], ["441c0d7b7aa705046dc0e07ba5f33a7d9df23f694a05192ff8c2d7be2aa3fdc", "4c06568c0902bb99d428bfa0a946ed0f0ca0a51fbf07cad88e06e9c78e38a59"], ["2569c8c78b6d6b92533f29f767c95720d377fa63ad5a3b9827ee0a74b0488aa", "4b59c81d3cfe08834f946d9d57614f5366e0bcd9349475aaaebe01341196fe0"], ["3f2fa285a0471647b214eac652bbad9d58a9f2dd2e812aff0210d0d8a6eb32f", "4cdb18e1c2848c2b52c1a6557165bd1a8f55c2f7562f5cc0b326f73c25b696c"], ["5bb5141ab4fcc5290ae9151b8045a2cd8391547ce7b3b33cbbb10f8fb538092", "5a36bfd52acc6a83a9913b937ec086cc27fed030b5fa70dbc5d3c12c9515f56"], ["3f3fed272edf91aa7f8ca5d70005d390fbc67830ffc69c5fa3ae17582d2771", "459057e0883c44d8776fa217405f443e5954f08c4a5db68e437becaa664a999"], ["5237ca6656237a717a739a4509f70db1b9dedbb6cd232f60c9bd8c4563a6b1f", "56c7799dd02896dbe7d69dd8bb9718270549592099569d107b7b49c34bf5a49"], ["1cf6b8499ac881e0b2fc7def9bc1a28937033b2fc52de99e75909a620c7a281", "5769cf4f735366fa386b6858043dc99a100f86fbc77b16d57d77766197ba27a"], ["1b74b8a6b86dbf9638cdb0601e1a332b8d880753423d38c3394902c57f15e40", "6bb2dc10d2ecbb913219d0ebdc8d3337d644ed8b6c4e70637ef4c7e50887488"], ["61e4da415661bba52a4737e2bcde1a837787c4796b2e1854778534f1582c29b", "27c43e632cb7652e8508c9c38e3b4ad0d3dd6ba748d42dc84ec2685e64b9aad"], ["7c460a204d23f20ce86596dae6ac9b36734e4a9f7c5b43262c97a36c6a41c6e", "481a11f9300ab4c4bf6924c5ca884728cc361247377065920966785d043fbbf"], ["124ff5e55e4effa40daa5b9618d75c49c8b6fad95cbe8c0bfdd83cb9bed8316", "33a2ea15d0f71f58a00de71acd7f22ccf9002115e49dd1f7631faa0d32f9987"], ["61c9f8fc86715e95ff43583a865c5a6515f93381839d557ef884a68637eaf4c", "5877daaa42bbab9083b571e12648a9d62ced4470d71653092b6546f4a5acceb"], ["70a6b9a9e5d1fcc07dd9ebef6d8f5fcf04c6cb34932d0fe2335330ac6dc8d3d", "3f0cbd332ac56922e886656bee74f6e9bb4bb88f7af7bba9098678af1f38fc"], ["41db8a0f1ea78443a39e08a54323743c8897eed1ddc28f41aec6f2655040d9f", "7d4bf32f8f4719c2e4af8b7889f3b65cfdd033dc2f971798a12170f2b26efce"], ["62f035e01acdfe841104942d6c8c07f0fbd618cb85998ea24bcc24cfac1f8", "1caa886104b7d753fda93645a746989794cd825c62473b526ea34b3d51b5771"], ["441c6f016d270e86c19843727b83b864cec060cafc813b23d7e41e5abb1a60a", "29fece4e40400f3acae0586f4fc8ed535e805e472123ec38d662d8a0b01c086"], ["2c791ba0fb0b66177815c98191fa6188dba9c795e34a7c3c8a19086215e3cee", "11123151389d4b330db6a665a560407e7cd8c3807c749e2b0cffd9c3074ba77"], ["5292da4ca71ae75ed0554c267747e39c7a129b3b863e1af3ebb3e368439c4ea", "63af6a5016deea8cc674c44f16c63c1db31f09af4fb4d2ea7917c28116661fc"], ["3367388d5d1b7758dc3d92e244f227bb8a54e3d9909e7b7dd62ab5965e3efc7", "7ffb4833071e4b03ea755ccb9938487a478248fe9b1158a08f1ac298801c092"], ["95c863314b7f18090f8eee602403be823a367a1b416d54c32e5f914e67d922", "159c2824f899171deee23e0ed520d4825bd667983df0a8d45d3a1f7156d91f9"], ["621c6e08b3c57404644ad49ac7629832c141273fa1f323781b3395393fe985c", "65d1eb0140652958c4371ebec791e03317d6b2e689d90e304666f1b610783dd"], ["54313129bf13993952cd2b31ed06013aba85e74c1b8a00e062031f32188a84e", "680129efc9eb8ec07fc180e8f6877e5f0f9f44e3000a2c586ed4ce49d12a313"], ["21ea57a1c8286bb45872e78617853c47b89091670ba51c124afa3362e7260d", "7087e5c1536df233ec9bfe2f983e8d7622892b9bf64c450c9823898e2cc2fc8"], ["3793b05b99e7a57d88db4ed0dbc3b771285abcd9052da50f88595354409f3f3", "12164105041c056f127e737c7cd63981e05f246bd2b6b65d1f427019c7c3801"], ["befd345cef5fcae22ac37dacd6b9128cc58cbba3e3fd774e11b421c2ba392", "6209d25f24f88f7876ca604db23d05f78e6b3b67fb033f2f1bee221f352b8c8"], ["15fa536045fda4c65ff74f10b4e669ce88b9996c6772288289d3ad725987fa6", "30e0c2124a35e265e931ccc66ce5ac3697d982814beb407144ff6762cb691df"], ["38b795bd77ac573576dc204857a488cac2cce19809882631ca2069598c577c8", "786ba555d55ebef688b068bb9186a34a08cb00bdfef51619bbf911890ae9a13"], ["6c66853592196c3eb8d9526dc155205e2c64097adf8684bb0e15eb460ce1c72", "1bb4ebf654f4250c8dd1061a4e1b464b31a8a9999ac9960446ef8108a66871a"], ["5b08dfbc87ad9c00b88e78816973ad2f9c10c70f2156908892cc7b7a2a1fd30", "1151f407a77e2556073173d8f5c9ff561d8a23742121ca15f7d0ac391af50ea"], ["309190eba106aa6ead54b5ca5817969aa68b4b4c627700799a49fc6bdd32ba1", "505b6a2bc7b0d78ca6ce2abe7dfb7312369918a4599cccf8a615f6701cfd851"], ["89cc205966af08acc8910d563af7443d5dfbb5d88dae79c013c678c65dcecc", "1f8cf955694b246a423ac725791231257b88936e00347ecaa1e17045c0ab540"], ["480086b61a80c36cf1e1a350baf554e58ee8d9333186b70c9c512fb9e9d5a84", "511edfe58f8d36a6170df743731da1ff525cfd5108be20e30ac4183d1281570"], ["3caf14fb1d2e90a13ad4eb091250fe37133aabf6029633e905e5a93ead41dbb", "49122aff6059dfda19e4b973aba5ebe3804c91728936c6381c1ed1ea9380920"], ["66d1b8fb2cabc46cd79741ce1cb7326077ad8ea3227a6427244bdd3806bdadd", "4a52eb74f4d5371ba3265dffd61c844f9e68d4ff0b44dc4936182f9280bb66b"], ["373330c5afd53c31257fcc9050fef873e15ea9f81d9810f30744309b04e02b3", "5889806607b3dc97a9c5b0c8a2f16d1792099a22866b879ca480cb89a11ef5c"], ["26840d0ec69a22c6818ff64b8b14633b531508c866e21d1dc9239778ae9e8c7", "157971f9a6e3a24d3b307be0e7c8cd352e2eb5cad33cf276270c0f309ee63fc"], ["ebb84848f1c38c19a754d1b5d9460e39624dadbb30800987c9419c0f933b9f", "517b297cf32f4064e6d6c8e761ba8db89809604a701c7b3aa1a9c6beb370ea7"], ["25780380bc0795ed0dca727c55240f1d63593e552d224adb40df2d3721c0f66", "10215fb5a893e0275e9f1f66b217dde35addee91ed0e8f7d79531a2ff57b8c8"], ["243e1581cd1abfbf18c31c19a4c3d1cedfe69a40bb57b607c9af2717eefc742", "1296c27929f14535718c3a4ebe045f00afdc60afc74c7d398d8ce1b6609dc0f"], ["48babb8649e054bc8e0b902c89e6940c265f48464520649502ef1064eb94562", "3235be7852b0526d1a16f6969ec0e5b0e09cedaadc65863dea4e47f4f398264"], ["592db7c27e63489ef4bcef2eafce89f40067cd9a1ba48bc3dc76b5fc62ad9ca", "48b7711b570cd9ac65910e75e752f4b751fdbfb4091a28f59b8c046d3d9f8bc"], ["31d133456222586ae42a9ec7ce8539ee04afbe0b2ed00a2564dab0798d9b55d", "a77c52fa1fd718db5c83e7fda6d7d4d9aafef9ad95cad621470f2b753729e5"], ["4651668379883521e7983aafcb93811b4a72ef2975b3277773746708ef3e3fc", "512507f3f544d80ba5d47f73b571881e8d70d7b1d305b9704bdad036b7abc47"], ["26069e359b2e847affaef604f772f36224608b7642245d0e643889ed231bddc", "75ae1ec379f074ebc91270077c74b4d34347ce183b676b4dbe100bfff143b9e"], ["3196d01d1fa11dc3803b4813c4bbc6326869f61410f2bd14bc0f570d875aebe", "20313217cac79875bd2a503db1e86d1e5559911667a02524759344468d9561d"], ["483256607f75f06fb126addc60cadddd602154cc4782bcc08351a48745d0b97", "2950a7e500ebbe9775f08be37cc2e62ccf9030de18948d1bab07a4a9173f75d"], ["65f07b6050a2fc6eebe2c29ffa62f764060f7f9d3c82d2cb5e4e368aaa442c9", "562c9654b646cb84a213b41de203c871b3eae0a05c9c105a66a53c319c06373"], ["284870f6181c43f3b01d94baa9c5b6ada0deb861145523ad9169580eb7bed35", "5e03e6c40c1cfa3cafb01fd0622349871832a9d35499d06408a83edc1b76d02"], ["32229810a52137f0e6c3d37595c46f6132822d4b05f42674b48d7a7ac3ad85", "7babde959a0cf2c53ee59fc52c77c3adf899453f077f441965629f9aead30cd"], ["1ea8b98a6b85e74e0a2fbc18b206e290f3ed94ce99ca665e8e2351dfade990a", "478e93c4724115fb1648c8d5347422adbc1a0bbf962b2312e14aec80e1be742"], ["270cbaa08c79140c85b864475a0bf569cc03ac785e57f543dc444f37ce746cf", "3a9b8d894016680ae9d1bf3deb931d8987d4d8d8bfed45b81ccc595ec79046b"], ["6943922708b8ae5b40dd7031ef2e487abc4ac39a3591368285e83d6c9c51f4d", "5f157c37d09634e8cbfbef90ea50af59815d011e419a691c67ca3402b5efc33"], ["48ac6a80979fab4912cf0cb557d917a0bd68825d8658ec100496eaae6ff62e1", "2b6931350ab183402e39476340eb1177b7006f7a552915581e29a79bd7203a0"], ["e3adf9517d92ef22d1e2a787740a292ba32d5ca69faa9e8675f63ed816dce5", "36bccf69bb12dadd610145a3399213248d193660d8dc90a2e206f23bf2c7997"], ["5e6c8ae5afb2fa470f767581f3d578cf6a49547e4b78665edfd45776948bef8", "6cbfc11953dd7e195d2ce74e52a60df524767b44c4608bdd755be4bc85eb74c"], ["15a576a1242d39300f0db3ad770983825988da0457718ecd596c63a0a0eb4a6", "69a42e5f6f5a63349b57683a4609bba90f556a1680fa1ec3b02ee7d3211f903"], ["274cd14e4fbf2ed07402e8ad8075b320c5f76b7ea45ea36af523e95ed63ab50", "6ca640f9557c5f2d8b27f6ce95b108880ff4e4816b26b70b6506114389ce656"], ["4d8284e132e2fe81c5f71be1e3c79ab51b229e2c56c323e207cda179999d123", "116cfc00e9fbee1cf16af6282123cdf20eed13021c2037ef4c86f94eb6e6cba"], ["4056194fb5643e97991942ef5b63cadd89080bf57a01489c4398aca03f0980a", "2e2cddb434fa6f6da7859c3d518f0ced8795eea043a6c9613fb3e020103339f"], ["5d119d5c5ce532afc0875e0ee9b026d878c8773d34237f90a0d0670da6f01b3", "4a79fc025ce076b6a4742fbcc8cad313d0a8220c58024a41a5a674c0947e64b"], ["11800ce4061d99b9d53fd4138802335258f7798c5a935c9979f5a949ce1d483", "36745a4741a5c7290eaa8f2a3f9ec955ccb7ca323272e5d35d35c2a724ffac8"], ["4302525bceb97fa642fd5560a4a39fba3d2c06f68e6aff3332ff1854439ebb3", "e31edfd081ce82f8177b2d7d96e69851d09e908c2517114ffb37ee12c0ac64"], ["2f5fcbb96f0a66fd3bdfbcc78bda361cb812570f50e7c476533d56eee01c0e3", "527428a34855b5695c479d8fb7e831a299f7897f36682a74169cc60d160df2d"], ["52167df045ad0dc999b98de3d035aced9da4434211149b8cf4bf20e774580cf", "19051d2a1ad3fab190c5dfaf45188b49b4e90cca22aae54f0a785562d3d3f41"], ["541b5332491dbdb2b6f6bccceb7634970c046963891fae936dd950f4432b961", "78fa54da996a51e3a9c06091d58c2405a806649da2bb1f323807c4eec50eda2"], ["5f11e973da659b7738f87ca5bd4f3bd02207dd3c8d978f0d3e83fe81030febd", "137aba7027069f62d25caed416e13537687bb1428e71e5f0a0c52d52f2e65bc"], ["15ec941ee6c2110b819b5541be52981c09d83484c9dc735c43f39f5778718b4", "4561826142dc5b56acfcf605a78a4090472bb61235bcd605a765e05d0a7e549"], ["68ba398736d659522f484406110b43c68158bf4992094acf797a38979c587a4", "7c1d9e1702e28afddf22fed7a7a79df4315c174d0c6c4f4c75bc77d9b56777f"], ["67889cea31c81a429fbae643a4fce0ecd690a5c32b99397e39ed6d7a08702df", "7ea277c80b671146c9e455b98f42f45b941ac95ca2d15c8fa9ea82ee9b45e01"], ["596f2c68390ac26505d3c2eca5c77d46f8f3acbed192a2649d8c525a58d2334", "49f3bd8c62c610d5c19c52d970bde24b270c4ff7ae900453b909e72483974a0"], ["567779fb8b0afe592cea284629e3621ccfae3c4d7d3dc559c9fed750591a395", "6010bdc33f1cdb374facefff537e7910b72a1120502f312a7ce41df0d552ddd"], ["cebed0233e810aa6a29a8b0829d28f1c92f303d14dd73d6b12da98117dfc7", "4bdd51e1192a00df23aa8d0673e4915877ca41ddb8c9eaf21d39dd167fde7b7"], ["4c7085f066adeb6781596771972b188177e63f2e2b3788d03e033cdd5af1f06", "2929ee89f525862b0cedb3ab9b5166e1680cb77fb4668f10a6a3d76b5434566"], ["760e341bd836899c226176f47685f69438270c150c6fe7744cd723cd1e72359", "1bf09f2f1aac1a10ce8bdf20d5d178db747f01a4aa0aa8a5e4bfeef562cd94e"], ["6016b94c00b54920027ef64902c61478244b1936337d2ad41d9a8d43dd6a4b2", "3bf3dd9bce7f6d6f120de87fcbce6219340b59c2c1d75ee0d45105d33aab1cd"], ["4929e44ff692eb944d1045bee96e750219cda3bda0500029f0df49a1db30b5b", "2e138dcbd092242699004b4ce98764ffe4e892841f56830af298581cd1e523f"], ["5972d0e526311bacb70a04e88969b6c63c7399b578f0dc28bbd00d65ef01da7", "76b22bca9ac12d26530e7b0757e646beb3bbc5680d0f3f82fb8ee57ed4b5e39"], ["2ca0a42a26e26934ca2d48db960b4719113d87c5e57fb437d557c5eb4e03ac7", "62778c02561d4ec5d83a132afd7763a8349207c6b5d01fba70b56ba660cba2e"], ["5137ee53f076e21a2c23da09f63c0d275408c31e4634a6b6373be5cf13e6c00", "14fb446c077beb78e04de3282a63bfde12f9af85caaca4ddfab506cee31c0c1"], ["7d944853d1627b63f560aeda33acf640d35a4ee4d23a744957a2dae9d5b7c6c", "bcb411a210710acbcb9ea12680d89e3e4e652228b6786d3886e95f4d9e6970"], ["37d412c2ffb173a728477446b60b2b702d07a5243cb5fc8963e623a5ee75843", "672c79968908f92cd0cb0b4c65ba86e8f359b015623a89441e1bf859bba84cb"], ["5b37f472aa80398bff12cc74c8ee784c4fc89757292580d3a498bff17e9f114", "7d79da1aab9cfef58a5f3d1c9ec466956a45f8d2af0c1da6dd4c93f720fae6e"], ["25c09b3f1188c562571536202eb0f5fc4b9a7590417b8ea58b4343685d88a63", "3d5b817c73b37e9a1d24ca923351359b42ced2f3cafbcac8c2d6322dc767bb"], ["32e60904e73f9756f71e0a918d302aeca17cad4acacc81bab15702ab5ff78f0", "bcf4c0204f8275072f98a65b09ac58b87cdc9c70c4edfe99fe18870a3a5459"], ["49c35575996c1517d2daed90d2fe4a58e674d6b4aaa7288d0642c8bf59e562f", "57eeee00adea4ca80eeabab57852cbf03f1a57e21872cd44221e0550b9193b8"], ["10e1776b4c2a867bf1b028c6edec224cc6616c747e272f49e69b67b02a893dd", "8d45d62ec8e627b56950f2f7622a0438647f9e9f28e723e4a37cebc039a1b0"], ["79a93a75ecbe943acc964fd39ecfc971dc6555b2bc335e7b53f52f4eb16cd36", "146132a68ce2ca8b48363612226771ac547eb3cf52b6eb7981718faac08aa3c"], ["6b22d32e0590e169504e7f19864fd646d0994e7ed3e578a5b88f6e095913439", "68c3b22d859fb85e5c8fa0a8aea932285945b230957e603394333e9ad5acd82"], ["71ce5ec8286eb8c93b8481c6d19cf0a288ef4da4397e9c80f65023e516bc097", "54470babc742780cd8a05499026e738ccbf81d4170d1731734de68a8e5b402c"], ["27beb13a43bc6a1f6ce046da438b0beac5899ff4d57962dcfb6476b563f74b", "14074e9e93ee45394dfbe833998b9d1691961f8ba3166224b36404448c61bb3"], ["6b1de6c8f161aa6509a1dcacf2c0aa1bcf6ee9d9b40e032a9d72f77a6fa298c", "5e9312eb5b59d6cbadd7d3dcbc39f1b5bd9a8346fdcfdf1107bada6f9cc048"], ["32670fc3fa43bf39974ba72ea51f0d045d92d084a81fe5282dfc8309aa900b9", "518fee521bf1af62356aac3b7e53fdbf57121e030c6e9572b3de69912ca4eb4"], ["4b9ca363eabed9c66091a347375f7065cd28f49f914447de7cc1461f1375f1e", "3a1a3a2e5e7e72476befe2571ece708052d740d02cbe6fed58740968ae609c4"], ["4cc6da42863a3deca62fa218b7a3b50e034eb4bafd393eccba3f4cbe192ef10", "20bfa683c884f203713953b26d2821287ecd305fa2cb70570474533fc07f918"], ["87705353c44a5ccec8de65cf5433be6b3d9bd21eea49b60e6c907cf1a67a6a", "112804b13eee56e3b01aff75fa08fa8374c44fc461aed8a30ad54acd09c24eb"], ["6cf6eeeb9d339c0a05f72fd5af73fc7588e6d957100ee8999109437bc126cae", "54fa257cea22032eac272fcd034dadf2e00d602ef9e519cf7072023c130aad1"], ["19b32925048c5519d929650c833661b452ef7be7963fab0b6b328ab7dd7a28a", "1bd0c14a10bf9b88ea61011c0b2e64d07da151c6203800d5a5d12063838a510"], ["12a5fc5559428bc3b4eff97b21b63668b866e0722807f1db1f19696bacd9b0d", "4c2eb07f0c24047a3d73b560144f3fd32c99d6dbd9fc7cd2fd2a72a6e4b24c7"], ["13662b7a7d390aa76eb86a7c3bff6d9913eb28db6bd1a7c42de5cdad2e35ce2", "40626aded7f56f82cc431ae30527b096f57fbfbc04d3e12a5abae3edf301cf1"], ["255825bd49b8a2cce114360bd9c8fe8c641af64c8e7710107213cfcb006f43d", "3619cce4482335232f9e76a1460be9d296f2d468d26e4f95a78c71524fe59cc"], ["7f83009eeed4f12f54d341bbf06066480cfcdf51dda103ac54d4bcecf6b3b31", "4269519d28faafd7fd68bebfd8404d71ba05d62c4bb6d65d24aa6802fb84ab6"], ["2f325650eb316646b4eec903fe44828fcb11054f1bd42ca3a77f7e734110b35", "44f976082271016f9048e22c507d97d628722bb431f8d5cc1890524e6c386bf"], ["750b166bb6edc0ee80fae39c7c106879036738df2d79fb2294e1c21e9a24d6b", "54f8aa297a1afafe2a17a3254f45861167414327e918d17003c6aad01d0b24c"], ["3aedb10db9cf3285cdeee375879396fac1fb50dd259e1716f8c01e66f67ca72", "7feb9400f621f58c21601f23b7ec7c94a9b6b193c1cd74a8a60846aedadd359"], ["4ab7151702de76faa493e7a0b1ac20ee4d10c33b83fec9477547cb1236973eb", "63f1f122e3ef3acc46b0915ac69c3f5772879799cad889a817f55f5853d1235"], ["1675ead0d20e5bc3a7a7331999a87ac4c916ae29669e54197bb02aa6364520f", "4d1122da90d49e491922d9b533a6a668e2f65a2737ebb391ebb29fb7c1f8a9d"], ["2f7148111ef53c613157aeec12e16a20f13481da4390b6ce18a85d1d8547087", "2eeda779ab395597651d2a0b833ccf53b10280750139916ae2baf4ec57c633d"], ["4439c7810e7b2ba772b701ec3acdca0b80c9df23047710b87f7dc3f13b337d3", "5029cfe704c602a8a4662af0a5860ec03fb88f046d0e3400f2ce7638014c621"], ["2248eec40b5732a6a488b681f093643af7937071bc73118acae295a32b51b05", "1577e4aec30a97b648de4d0b19cf8891151b4eb11f8de9c6d7312f091552e19"], ["4738424e558d4e0d87a3124ca02ea24f0adc6b7a9768b0d3945ed2a6104857c", "33576f92aca3f0c8ae689c3c274c2de6b918940d86a6852e02fc99e35d1614"], ["7829edd8b866ebf7baaf604ed13d19a9797578f44bbc51b1cd67ca53803e96b", "5559040a6083f2af1f9133ccaf5bc2ce06e56ddfc7dd410e9635c0116b62722"], ["7f927b881f2cdc05e1a69e40bb714af47b630d1425f08ab5d574ee698f33d51", "26a465288e96572de303203bd38f4a03031e8158da0591cb037c0a5111d1056"], ["36a65598552f8753580d1655417d645a140966e10a1e1663015f9fdfae44881", "33d5bbfaebf59eae72b89b1aea12ab2ba3c9617f8c3baed1ec16bdf668381b5"], ["403becfa545c826782026ff409cc16c9d4fe428f1b5b6e630c92439d2fa5fd", "47bd6f2bf5d74f710ecb479c79b01fb774fbdad590e683a415cdedf33f71dc5"], ["3a747826d241b877d3d56b16e0b810cf088eda4fd6048da174c9991a942a5eb", "2c7ba19b0a3486a2cdb84d4a388d34beb077a0e467ba44590166f93f6a09d2e"], ["3d60cd375842714b37bda89dd1f13a7e0f3ff133b522209617d031bce05a537", "f77f216451ab01ad5226844d2162a7f32744688bcb4325445539e2ce5cec4"], ["235bf66f67c9100e7f0e22bb299cdfaa603644b240e0770aec7e7fd163e2a65", "37110b3fa83ece3990afca2bea8d5ebb3c7aace60a0147f8e6ab733e2f2b4d5"], ["3b796d4eb69a55471fa86108f787b3604874e92b6887a7667a6c2bfbbd9a42b", "4912d6dc0419732ef82cb3278415851d4e2d7ca89e0f4d7128cc9de51b810fe"], ["48d53516dd51e49faa7ab46c8c10db1befd10f23c6a9d9bc3640a2f0da44518", "73a2fb3d064adadf21aa1362c04affc660598f38a9e069b3afb74d0a99ae9ee"], ["48c32cff161ed145da0d5b73084897647abb777adf65738559ceab6939cf3e0", "3d99308978e828f857c382df32b472bda81e8ec8e30c8844077ba6d6d2ba903"], ["2947ff091a8ec9684affbc9a62e09e598841c4a6dc638088492aa47dea57097", "19a2cc97975e547f97a4d02e42f89e6ced6f5a953cfccdec347867d26926541"], ["1960d85f30475615f82484eba0bdafb7ea7cac3809f0518a757d66f02b01676", "36c8f77baabf0cc8805d993bbe62041fcf4e3239cf9d53278a4fbd91e75eeb7"], ["2765f28074d21d5a055340b6d40092d2bbef807e02009fabfa08ec0b9bdf38b", "7fb189e0553d5df52b6843661814824b3f3cbebbd54988f042fb256c6bf30b"], ["348836cb2aaa00212f4b1a4e2d7fc5417f246bf2fe5c9a16ebabda449e2e08a", "3f7276fd7d69e0d55ce5ee1d2d830534a27227fe0b6d8a36c93f9a78b872969"], ["7afb9d34b6a42ea8c6d870e4b8191c274201dc1f93a1a2219a2392b7e345a31", "42bbc20dc7115e0758b364a110227b16b64ec58fc535ce5ff1a9ad8b8a09fdd"], ["2cae0c2afee1767fd4c66f52e1f176d217e92e89cc19eb36d5a6c1715f641a", "5335efe2d9bc3667d25ea88bf76438a4d6ab9ba5c512f9da7d0529b79b62d83"], ["1cc5fde334707723c3a06f00c106db88664284a2df47bb6b144d9f960aea3e2", "dbbf610d100316938bcd8bcd078513512ecb50d4579690dbefaa419c05980d"], ["54e90cb8f3a2998d2675c5780679e06c0556b1e618f8fdf07f9a4b2466fbf1e", "16248676b6f06ec5e34994bc3115f85c8147b54f34d8500928f2fdc051e2089"], ["525c70a2ba0dbdd68d75640f47f13d0d415ea595f7030f533f4625c2a46523b", "58292c8675e5e1a438f49e0c05648d9a7aa997f2f1fd77d5de1944afe5d7eea"], ["54726d78d099007393348787a03107ab492e59690a46c87fb02ec554f2353bd", "53b54b77184ba75a3391e0ebfa6d6974db028f3f8e34bbd5460759a5848dd76"], ["4ac81a66903537769d3aac6c483ccc08535cb767b6b5e1ec8017a7393ab70ae", "2cb22b77a8a05d26f11a4dec80eff292633aa05553a889c5ab16b6ac6e2ab17"], ["21d0175349e21114988a2930b9a607d43245783cb4a0c984ce27f4c4206708", "59f1f49342cc5496213d3329bf4ca7fb0044337449c579bf53147a1dac9e67c"], ["167f821b381f4c8adcc39789475fb55ba639e5124fe75f26dd61be396dd5e66", "22002c87d4cafb47ac9d27286d5cf5ff7a6715d69814118269b0729be9e4b3a"], ["31010666c6db83a9f9e4db4c48173afd405783ac53852a6e38a8ff925528843", "1f466dc9b5d9094107c741dbf380f9fd98d8549cd50f67169901516f8cce74c"], ["1ad3875769a5053388a86edc85dd80fdffbbda6a456aea497ff81a0f1f6707b", "2de7cdec5e2bad56a71bd2f33a4ae4c874e1ad4210a6ac32b443cfa34e85b1b"], ["c489650fb7f459ce09cd05a456fc5a46b849b38a671298ed645bcdaab168b0", "45610d092b8af1c43ceed474cd17f7bbee65120aa6fa4d37f949e7e41f25327"], ["394256a5ef4d7af5459587a0bd2edb8acaf5ecfef2563c9a04daf34a4abe4c6", "1ebee390dae1403c0c53994e1d064fa64e20fcb45392e209b2b99486a559ffd"], ["410a1511fead6151e9bedb089b9832d0fe01fab76d3f8459929f767525aeb27", "361f0a5ffe09fcc3ad4eff3f5e89508ac247af80267100b69de3c59df561cfa"], ["38cd437c9f659e110a869605c182ee9fdc26de36baf559d9229e258267bb734", "624b1128ea7739bf1cbd0e423af92a4884323c868d2ba0ee9d362946edee2d1"], ["78b126e50b7042d2a019f95cb87a3213c664ca1bafe345999b1e9e2dac1e608", "19e398196b22f4488cbe854c614ad8c353839abc5ab3a4f3f5c03c16ba8a198"], ["6d3a5ce91132f385a91823c5c8046c4b638f5fe63357424410d901457cdb867", "7b80bae16d2d487e122495174f7a70992bc5dafbed72bf84127ead7c57302bb"], ["32d053a904dc4d88fbe7d0b96e0cbeca22a00aa5c79c753d52b0b60abf31602", "3af6a02e5cae6d6490354ae51185149e3fdb6d0d9caab90e95ff58aa0c40377"], ["49b1fbff5bdb0aa6938b066dde0ed772c0d81f9eff52e7fe038b0ccbd78adb5", "1c6e57834eb14d507eed8b36c81ddf92fa91c242467061927a742fafa82b43d"], ["2f28b8994ca6f234d9293d26196b43b9d1d5306844348c4a638102c05de85f5", "759cfb172eab065d477248b3569f4ff5791055f01e95fe71b94b8e615d73c96"], ["3c2ee954ff534f856f59188fa0f29ed8a022aee0cac52d634f6dc58cd514d70", "22bd162e74925f0a876bd8a206b8767dfdd7c898576a73a490f138d9a7f99c6"], ["5763a7cab001e1aaeabf9ab5b9b2fffe6cc2b299ab04ec4933da74d960e1ab", "715ee4f8ee93ab5a1dba00f0a6abc4eec47d49b61254cc27fc36a031e32f0f8"], ["19976ad8d7b7f47c785408243a227401996b36e47c7a78a7bc7d4256233ba9a", "896b713c5d7777b0703821a73c1d9a4c3755501042120534ff13990975e1f5"], ["61674b992c29827186cab5ff454758dbbed8e89bc23d0bd33193afccc3a04bc", "38e1020744c13903809ea30a0662fdb5226ae760cdcf10800faabec452e00f8"], ["2ea2d48bcb83c0c9cda4efe11f07165cfcbc9ccd26526e5fb12556316d4b1df", "1d2d68b74ad384c5c4a9c85453104216357bfcdf635680b40215f0f800974cb"], ["7881212050264c40c336ed3a15dd2cd868ec9a558f5b728869eab66e8b8ed54", "21aaefcc8ad8a161b8971d6880321781dbd939570c540da4c330922b8c81e9b"], ["b6be88ce0461d20f59c5199573cda0170b61decf6e8e69a6d32f1695adc4ed", "5536e4808370716f2bb3423a9a49a38ddbfe91faf3b7a35eb53d3519238b6cf"], ["e5972af1655eb6dde2e8c77cc58044299922441b5ee41ceaf5cafedc765bcc", "550282f37a4783dd60801c237045992d6fbe82a5902e7d837ea25f6f98c7b3a"], ["7efc1aad1f580d8f50274f1c114c40056be19a8c96fa8c4cb5bf85e1e7f3e4", "2689f1c3898b114d668be6413643ee9f879913d40c262541fd0316264c60a4f"], ["7939db98037f59b0113e9d60051f75ac9c3cfd1a3eb535c73e2d945068c6c5c", "410914ca8bbf3c65cdf3e9772ca790c19131c50068d34b7346c10260a578a8e"], ["225b77ad00a2b83d26690190b74867326eca4f55bfbc3a13be036225ca3b1b5", "411faafef89042ce6beb64309fdaff70fa53e9d32d79a21e7f82f80e79ff05e"], ["1501e64c99c8b6658b0479f2c05c9142d246eaabfccf2fcec8dc4399539d8e1", "3bab1e3339e42c9ee66c65b0b20236fdd9362d3ce786ad3a9779ab578af50a8"], ["59b907b941f24fb8ea2458153e55f07534b388e835af7b69f3c9f54392a335", "1d5438c4f2f68a417f3d56f916d899a6ffe910f5f2989ca31687f1b10f60db8"], ["2887d08a26f484546f360e33abbf7a998b7170a5b30070938b84f072c676bf3", "62a78e8d00e5d3a59e2fc424ffa08961567ba1ef24c8531cd7bceee6074a535"], ["6e3cc8076b3d45377929033af35aab0c6d19ae4fd47c0daf844079ca04c46eb", "7b90f338e4d848aa8f19d0b5c3bca916a2a9024acbf14bddb278bca2aa39e5f"], ["34844dacdd3ec54a3af328bb9d67715ab33425e194ac9977ca02ef22e8f7a88", "3c1affc6372f32a1634748124f9e1a03c4f0c993971da0dc28888b0801279d"], ["436b192e03a49796cf9bc5e93c88268b71c9c24f9c3a85322bba634ebea309d", "67a8091ef69d62abcb28ce5df4dc7d53f8dc2b9690344f75ecd03a6d9386044"], ["592d25b68baff87a6d7fd41ff0dadbddc1bd1316683de3b2d677501c0eb14e4", "27ad1e1099683f54589010faeefb19e38569ace43653be8787a42b0591e7bc5"], ["89a5111ae911512ba62e87b97f643c0219702f235c70f62c6678a129302009", "557fa3d98e9ce7b83b47545013a4498f3de43787fb66b1a54521222242f7c1b"], ["1c9b5e53377e72da5066cb08566bbf9ec31ec1877f455d932cd9b1aa375d34e", "72f79555a8bc207863f32d482fca54692825449fd8963fcea3de3a8183a739a"], ["574a6e05eb14591729515be239ea8c1fa9e12d4049d42876f76c8ff37bca03", "5f99b3af43ca68c1c73e8190d5f73c8de162ba643d7d5f0cd73cfa8135db6d3"], ["513fc5c2e16505b2b25a2f284e167d5401194bcac0dc3ecf8b7c9acb560daa1", "687ee7a1a8954d08d3856e1a16ded808e419e789736d3f55f79f7693bad69f5"], ["53d48bd1205274b1c2b0a0ceb3d21c5fcd7c8892a784931603240b288a598b9", "35387abd7ea59c9b956de44d36533cad1f6668c438d666651695ff3862159be"], ["213eb1ea99e08825110dd61094eb6e8145119dc1c507636f068730b1e086d44", "744f6853f4f02f4f042468d0739e0c9f64df720b87ed77d1979547084ef7a89"], ["735ef017d091ca23264ad0aa7bb9b2be3309b4539605e79ed4a652ccb2fbe3c", "7f0ccc7a5747c4e921fff97d431169f690763427e2cfd1ad74d7a0308d7faa9"], ["3f36babc5a30070b610ed97db44997e6d9115c9c0579ad8f75d295a17130001", "79047908a2474e32d5c712a07bf5c4ad522590bb5d6cefda410d30528e12ca8"], ["51c04907ae88a5926b242fb2862cb1f2c651a94e6caad5bff8601c079fded74", "10a585a269f460aed43f54c7de13cdf623fc8de5957526997278be939ef32ad"], ["c1e1bd626a735aa2c065831317217ecce68e377eb1f67e54ce2e97bc2ef2dc", "53c5af23a9b482f420be6dfd37b6886154cfd130794098e1f51c1885ac2556a"], ["5aff3b30775ae4758e604a4a6262803a545f5ef4e7855fa245ac6a6431a9ece", "39a4799e5519047f29333bee9c86c99bfa8056d4aa381c396c4a44331fe795f"], ["3d753e9723701a8e9d99b91bb93dee2eda7ffa5072fb2cd5c5fd99aebcdb299", "15798bf5c17d6d5880fed1553af32dd8d8baf2888c715a886575448a24c7975"], ["6593e5078466b07a4222d2e544da826d2c583c9cc5f2eaea148b129b00d4aa0", "11b352b08a0a61d3cd67d1dc08069dec3bde907b3da0f56de5011b956bf8744"], ["7a6eb353c5be9ff03fe4a06c01fb71aad2b38144179a291ebcbb2c2417cca65", "3de3ecb12f2fa699b46a9d399abf77ca17bebc3e491bfb2542dd0fba991e2bb"], ["2c7ead583d6c32162091034a9eddfa775b4e84b8bdbea939edb2a80dcf64f6", "461790ce40d9c276d962b2a1e9a74d66e9d7335962e234e8a2fc6963d31722d"], ["34285af023d9b4c2c2b88e8704bf2c05a9b553b00b2e70ff05f8c2970cb134f", "33fe678e7671760a83836107428dbade68c3593fbe568f3f8f1b2c568099c44"], ["6222f720a24466263db6a11842f117fc4bb78da6705f140e48869db3e087441", "6eff5b9bf3aeedc962bc5a24b66e7bdad2153450ed53a058bf2c8dbf2907693"], ["17c6ec5ea206eb97cbf53851e37ce391080e0d2bf1e5395610f79ab0503f7ce", "3adb71ca3523d88ceb1e365f12dfb24895453c14daf0046b2626cddadfdf5f7"], ["70859f9771a713e54974ce11cdaf44b0dcc3e9befa0c0834908d877eeaafd27", "d18f794bf0cc0623b711e7450030424e52326c45ba9b03341883ae4828a5f8"], ["2a820cfd0fd4ab0871e7b303cd545a3086caf8fa818c087a4017197da74efbf", "5f992683ff37f6c041b84bfc01503d333ac9763505cc8f69473da01812969d1"], ["5b0526de2c07fe7cd73e3884f642d57a0ac5e13c68590ed03a14e530616e8c1", "eec69d0cbd92c9fca31ec967dba848bec368e792d6678797946a5e34fe3487"], ["6cf6b3efee707210cb3a72f1e885c3d0953aefb43e5e148c740aa1641725c61", "911cb630b898e2c1a9115f9e45bafe3b819edfb1eab6e15612d14289939984"], ["74e913de55f1e46143cb2ecfc580f8d3d3908f200281322b84e21c989cda293", "761d2736c9ac7670ba905bc2629c6c0dbe988820a4454ff415ba68710f7df92"], ["44084305e0c911a40b7cbefe5f13cffe9a99375d1a584c4a2200958050af7a9", "249c83877371564708ea525b64b1e7e12785460d83364446531c9adcacba5f0"], ["2bf71ad4d1bee1a67fb300477029f54bdb0e09f78bf2ac2e8afc7465a7adbcc", "6244dd6cad282539049be57487bfd9900bb0d5da805d02b535096368fcb4cd5"], ["3a62d8f763b62def36e4089458046a49c5ecb91b861549530773e0548ff2bb", "6a10a03ba61e6ac657270465c09aa9526cf1ebe96bdecdf0e7000476a47b9eb"], ["284eed3a17c51e0677d4fe897f056abe9def8af07a4630e6ca5723e2aa6677", "516a06ac1d5626ed03d2eee9de6f60f0311eca703a99b0fb31b9c66b01c27c7"], ["2a2c63b16cccd685f731d06fe93ce2cffb358d34d03dda9a7368185c1eb0c32", "7180baca0ba81284809f92eca1654cd76b925a9242e5d5e0f18d0a55d13c6ec"], ["5f9466017ec09769611389ea5370ad68dda936d3f5816c9e928ff9574abf9a7", "6619b5b145bb5f4f29deb7a4cd68ef4da3995312fa6537f0d01684da4267ece"], ["74f229babe01b4962b3307589c1a13019134b1db6822698388bebb55d21c30f", "156ae857ab3279f754facba0db36398dffec8c31e5e160473198f2f891b7531"], ["334b9fe3a5fd99bc966ddd1309698fd32afd1f235062f2c275b6616a185de45", "221a60053583cc0607f6f2e6966b62fc9dac00538bb7eb1148e007a92116d2"], ["7ad710ba002a67c731efbaba2149d16fec5d2f7aa3d126fd9886172e9f4ea30", "3a10f8e902a7a13aec94d66415347e1314f9bac83a7db176096b809b25ffb86"], ["4306dd0a184a3283c3097ff8f7434cec80912e9dc04b7df21ba73fda9f8e6d8", "6d42bd3d1a8dbddafd09e872e2aa3891ae79ec939dc1b382196bc21c4ab749"], ["1c3f2124e1135c32a426d1d14e471edd9e0f2c7bd703ee123cbbd608e8c4be7", "3cc607a3c3f1ab68dd5fa56c65996002721b8ad8ad4b0dd9e5b1467d316583"], ["294af33272ffcee0b56a436de1b73759cbddebef4c07888b42c2f92b0b68e1", "d837164311d5dca8d37b99ef9eb22708643c83d1cbdfe852f63ea07b06fbad"], ["753bdb5439a19bbffdfa02b1dc24e8368f22d0a8276b109c11e6feb26f56f39", "6ed396231af93647633eab467f1a034f38e76823eb85baf97cae56e2dcd9f75"], ["5674f0cb892b733fc0b50e121d8679afed0a925c32594cc65ffe83bebe7748e", "7fbf0325dd38dd94905adab2c52758552292a6a103d9edfcb11938828e828c8"], ["4a8f053573a0a74251059d0229d89b6660407ba0b491779fd10f87a5117c81f", "21b70112485398bf67ec9d733df24a1df30dea718a93b786f41ed04e3ae3c5e"], ["726c01ec4a08df8fc8de173311f50d4f3b97c5a9cf68c1536146f827db95ae8", "15013cafadefa7f1c4e4dfdd70bd4d3979dd18bd7f0332572ce2a3fd8773d12"], ["38ac0fbfa98937257460db7e6645d7e5112b6fce7234813fc8a704e8ade8da2", "73c0109f86048aad08c443f781ae60ad13b99f7b9cfdf3128fe6d6eeb799a7b"], ["6f6d3a38621582ace092eb50ecfe9eff265df141ebdcab8653299116fcea291", "4a1bf3f39bc919c8f1b720a0b1ce952cad17f2ba98308ee6b76dd9b6f3d7b75"], ["6a307fc28e1df8d9ad01766419e097797d65cb674436fa1c8f012d3de2c2a1f", "26911a635ba824db004875d79dd84834a97ac12643e42829015bf88c1fd6f05"], ["2a74860e3336d6db916555894cc8028f41508812925db1925457afe40257155", "5f8da573f4c39816ce2dba8a20224223a7cfec53117ec78973930c0e9b60244"], ["4d2b49e1ed0799f719b8269f092cb489a466a645bc0ccabafdc678864c176d7", "5410083df7d256f18cbf5697ae5e52c31e075d8a3b27e21d6f5177ca882f6c1"], ["110ecb9fbf6c333d168cee473cc5ad98809b6cb9eb5d1f6cd28ab5fab504fd3", "7e3c54d7533d9f8c3310f219dab0cc3ea4d39b418a748eeffd6bae2b8637a43"], ["5be4d711b80da70e6d3ac493250bbfd16f20b25f31919b3a91cf14ffbac1096", "7f55a0919f082e8885f1515e83c5b39b6022404503507498e1b4422d79c43e2"], ["2605125b95ca4ba93a21cbbba5762898a7cf9e988f07ab9e64cb3868e3b139d", "62f0ccf55b9fc0eaf9736fc8ee484e2acdbe259813af9803cf815829a5e9d3b"], ["1092bbbf206f2a3068167c3dd99a72de31e206f6c504c071c8214d105ff814d", "309f489f68a62089f53b96df5d4fbc3ecc5a1a42eb7ece0e49bad17ad490ff4"], ["2abdee9409d9c92559ca3f4e6bddd649c31aa09b90bfcb4a612af491241e18d", "3ffa8eac180a29de3f8a69efca84bac046f921f5725e96a6ff0530be1436aaf"], ["376313f27d00bb1aae7ec991745efe6ee28c6b50de0c6cd9845cc4bb4f83543", "6a8e0a9389ba528b156fa94ac090a895d7b795818d4941c29415d9e2984c547"], ["a80380c71bd466a696b3f0fbf02817c9459d9798f4f3899cf32edf647fe066", "6a09805e814e7cdfc76eba4b79f1df5ae559e0f0aba9f728d3cba4ea5c57471"], ["223694b921d247d989a79b9b2b2f07496036c40cb043eab074a9d6a2cd2ffed", "c247217f1b1df35e30d9e15fdaadf42d6fb0edd3a5a7e265d4cdc426c120aa"], ["102333620df278c6714bbc880fc087db58c1b9b4d77ed4d61b32a74bfc7c3e2", "6a77d37727ccf71c2caeb151faf4404d4b94e9047f9f0a7c3966367f3b53c65"], ["891626f466536929ee7eadcd18b41925706dedab7528ed5f0f7abf039eb9d2", "5f73d11c141c933a35b2d0d06e5cbae614a20d17dc3b439f8bcdc3413c5ea37"], ["215c23fd3f073f870e5e80303967391bf173f8adcdbeec72d131c557babc203", "10634332e9d9439a321597dc5b0fac9ff478834c3d6e281735f21a4a5e13266"], ["21ea0bdc1332bc36e6aeb43be9071651c27e4ea2eadec636c8d818d4af72a36", "3a523d9643dccc6bb9c7c58413312caa3e60ba9c7c7f0177e0f3f469a3241e3"], ["60deaed1bffb6190beed40caaf2bfab5e43d3707aff7ad3f278d571aa247eae", "e41f71ff254c1418e6a66992af307789fe04d6606fb2670900bb1a089fd879"], ["1e1fac4a1646253fb1332fadc21fbdd3e3a24a840d129400f520ae4116a4cf5", "69c406f9f46576afad68808de0ab7e8922b6226af748e721d9097e21f1800f3"], ["5db0ddcdf79ffe74d6454c12d2bc60b06776db03c75dc413f5be42ea9a91b5e", "134c3d6c699841f17306835bb193785228ffe7ab212a01a861c56b086a18cec"], ["626814e320fb5bea505b248fd1c1389ad586c1cfe04923fe2f83173e915f4f8", "7ae407a926e887206a8b85cf485f1f327c9bb8ccbb6897024e2d122877d8ee0"], ["23186237dc7d3b570cea645282ad4c359731bbfa54e7f036426bf6493812cd", "7d1fbab7e61a22d3b00993290d9f4cd5d820061573e787f66c2cff9a18e1eaf"], ["54302dcb0e6cc1c6e44cca8f61a63bb2ca65048d53fb325d36ff12c49a58202", "1b77b3e37d13504b348046268d8ae25ce98ad783c25561a879dcc77e99c2426"], ["13961b56b9fc0e412e468c385c22bd0680a25624ec211ffbb6bc877b2a6926c", "62f7f7792c77cd981fad13cb6863fe099c4d971c1374109185eae99943f16e9"], ["47abd7308c70659af3f00fafe6837298af3cb530b6c2ba710ffd07a6bc1ae98", "75d0c8a7377aa9f0663d0c124a5659750847afabc29e39893fd27534a4a03cb"], ["2c6276b764fb398fa555857dbe0ce0ec18fab7a233bf23851295739801f0585", "5d8f4897ce44007ec5bfcb9aeb78b8f6e1d40a514f72d213c9300d2770d2b8c"]]
              , ellipticCurve_exports = {};
            __export(ellipticCurve_exports, {
                ec: ()=>ec,
                genKeyPair: ()=>genKeyPair,
                getKeyPair: ()=>getKeyPair,
                getKeyPairFromPublicKey: ()=>getKeyPairFromPublicKey,
                getStarkKey: ()=>getStarkKey,
                sign: ()=>sign,
                verify: ()=>verify
            });
            var import_elliptic = __toESM(__webpack_require__(86266))
              , import_hash = __toESM(__webpack_require__(33715))
              , import_minimalistic_assert2 = __toESM(__webpack_require__(79746))
              , {ec: EC, curves} = import_elliptic.default
              , ec = new EC(new curves.PresetCurve({
                type: "short",
                prime: null,
                p: FIELD_PRIME,
                a: "00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001",
                b: "06f21413 efbe40de 150e596d 72f7a8c5 609ad26c 15c915c1 f4cdfcb9 9cee9e89",
                n: EC_ORDER,
                hash: import_hash.default.sha256,
                gRed: !1,
                g: CONSTANT_POINTS[1]
            }));
            function fixMessage(msg) {
                const pureHex = msg.replace(/^0x0*/, "");
                return pureHex.length <= 62 ? pureHex : ((0,
                import_minimalistic_assert2.default)(63 === pureHex.length),
                `${pureHex}0`)
            }
            var genKeyPair = ec.genKeyPair.bind(ec);
            function getKeyPair(pk) {
                const pkBn = toBN(pk);
                return ec.keyFromPrivate(removeHexPrefix(toHex(pkBn)), "hex")
            }
            function getStarkKey(keyPair) {
                return keyPair.getPublic(!0, "hex"),
                addHexPrefix(sanitizeBytes(keyPair.pub.getX().toString(16), 2))
            }
            function getKeyPairFromPublicKey(publicKey) {
                const publicKeyBn = toBN(publicKey);
                return ec.keyFromPublic(removeHexPrefix(toHex(publicKeyBn)), "hex")
            }
            function sign(keyPair, msgHash) {
                assertInRange(toBN(addHexPrefix(msgHash)), ZERO, toBN(addHexPrefix(MAX_ECDSA_VAL)), "msgHash");
                const msgSignature = keyPair.sign(fixMessage(msgHash))
                  , {r, s} = msgSignature
                  , w = s.invm(ec.n);
                return assertInRange(r, ONE, toBN(addHexPrefix(MAX_ECDSA_VAL)), "r"),
                assertInRange(s, ONE, toBN(addHexPrefix(EC_ORDER)), "s"),
                assertInRange(w, ONE, toBN(addHexPrefix(MAX_ECDSA_VAL)), "w"),
                [r.toString(), s.toString()]
            }
            function verify(keyPair, msgHash, sig) {
                const keyPairArray = Array.isArray(keyPair) ? keyPair : [keyPair]
                  , msgHashBN = toBN(addHexPrefix(msgHash));
                return (0,
                import_minimalistic_assert2.default)(sig.length % 2 == 0, "Signature must be an array of length dividable by 2"),
                assertInRange(msgHashBN, ZERO, toBN(addHexPrefix(MAX_ECDSA_VAL)), "msgHash"),
                (0,
                import_minimalistic_assert2.default)(keyPairArray.length === sig.length / 2, "Signature and keyPair length must be equal"),
                (arr = sig,
                n = 2,
                Array(Math.ceil(arr.length / n)).fill("").map(((_,i)=>arr.slice(i * n, i * n + n)))).every((([r,s],i)=>{
                    const rBN = toBN(r)
                      , sBN = toBN(s)
                      , w = sBN.invm(ec.n);
                    return assertInRange(rBN, ONE, toBN(addHexPrefix(MAX_ECDSA_VAL)), "r"),
                    assertInRange(sBN, ONE, toBN(addHexPrefix(EC_ORDER)), "s"),
                    assertInRange(w, ONE, toBN(addHexPrefix(MAX_ECDSA_VAL)), "w"),
                    ec.verify(fixMessage(msgHash), {
                        r: rBN,
                        s: sBN
                    }, keyPairArray[i]) ?? !1
                }
                ));
                var arr, n
            }
            var transactionVersion = 1
              , feeTransactionVersion = toBN(2).pow(toBN(128)).add(toBN(transactionVersion));
            function keccakBn(value) {
                const hexWithoutPrefix = removeHexPrefix(toHex(toBN(value)))
                  , evenHex = hexWithoutPrefix.length % 2 == 0 ? hexWithoutPrefix : `0${hexWithoutPrefix}`;
                return addHexPrefix(buf2hex((0,
                import_keccak.keccak256)((0,
                import_utils.hexToBytes)(evenHex))))
            }
            function starknetKeccak(value) {
                return toBN(function(value) {
                    return addHexPrefix(buf2hex((0,
                    import_keccak.keccak256)(utf8ToArray(value))))
                }(value)).and(MASK_250)
            }
            function getSelectorFromName(funcName) {
                return toHex(starknetKeccak(funcName))
            }
            function getSelector(value) {
                return isHex(value) ? value : isStringWholeNumber(value) ? toHexString(value) : getSelectorFromName(value)
            }
            var constantPoints = CONSTANT_POINTS.map((coords=>ec.curve.point(coords[0], coords[1])));
            function pedersen(input) {
                let point = constantPoints[0];
                for (let i = 0; i < input.length; i += 1) {
                    let x = toBN(input[i]);
                    if ((0,
                    import_minimalistic_assert3.default)(x.gte(ZERO) && x.lt(toBN(addHexPrefix(FIELD_PRIME))), `Invalid input: ${input[i]}`),
                    !x.isZero())
                        for (let j = 0; j < 252; j += 1) {
                            const pt = constantPoints[2 + 252 * i + j];
                            (0,
                            import_minimalistic_assert3.default)(!point.getX().eq(pt.getX())),
                            0 !== x.and(ONE).toNumber() && (point = point.add(pt)),
                            x = x.shrn(1)
                        }
                }
                return addHexPrefix(point.getX().toString(16))
            }
            function computeHashOnElements(data) {
                return [...data, data.length].reduce(((x,y)=>pedersen([x, y])), 0).toString()
            }
            function calculateTransactionHashCommon(txHashPrefix, version, contractAddress, entryPointSelector, calldata, maxFee, chainId, additionalData=[]) {
                const calldataHash = computeHashOnElements(calldata);
                return computeHashOnElements([txHashPrefix, version, contractAddress, entryPointSelector, calldataHash, maxFee, chainId, ...additionalData])
            }
            function calculateDeployTransactionHash(contractAddress, constructorCalldata, version, chainId) {
                return calculateTransactionHashCommon("0x6465706c6f79", version, contractAddress, getSelectorFromName("constructor"), constructorCalldata, ZERO, chainId)
            }
            function calculateDeclareTransactionHash(classHash, senderAddress, version, maxFee, chainId, nonce) {
                return calculateTransactionHashCommon("0x6465636c617265", version, senderAddress, 0, [classHash], maxFee, chainId, [nonce])
            }
            function calculateDeployAccountTransactionHash(contractAddress, classHash, constructorCalldata, salt, version, maxFee, chainId, nonce) {
                return calculateTransactionHashCommon("0x6465706c6f795f6163636f756e74", version, contractAddress, 0, [classHash, salt, ...constructorCalldata], maxFee, chainId, [nonce])
            }
            function calculateTransactionHash(contractAddress, version, calldata, maxFee, chainId, nonce) {
                return calculateTransactionHashCommon("0x696e766f6b65", version, contractAddress, 0, calldata, maxFee, chainId, [nonce])
            }
            function calculateContractAddressFromHash(salt, classHash, constructorCalldata, deployerAddress) {
                const constructorCalldataHash = computeHashOnElements(constructorCalldata);
                return computeHashOnElements([toFelt("0x535441524b4e45545f434f4e54524143545f41444452455353"), deployerAddress, salt, classHash, constructorCalldataHash])
            }
            var json_exports = {};
            __export(json_exports, {
                default: ()=>json_default,
                parse: ()=>parse,
                parseAlwaysAsBig: ()=>parseAlwaysAsBig,
                stringify: ()=>stringify,
                stringifyAlwaysAsBig: ()=>stringifyAlwaysAsBig
            });
            var import_json_bigint = __toESM(__webpack_require__(4400))
              , json = alwaysParseAsBig=>(0,
            import_json_bigint.default)({
                alwaysParseAsBig,
                useNativeBigInt: !0,
                protoAction: "preserve",
                constructorAction: "preserve"
            })
              , {parse, stringify} = json(!1)
              , {parse: parseAlwaysAsBig, stringify: stringifyAlwaysAsBig} = json(!0)
              , json_default = {
                parse,
                stringify
            }
              , stark_exports = {};
            __export(stark_exports, {
                compileCalldata: ()=>compileCalldata,
                compressProgram: ()=>compressProgram,
                estimatedFeeToMaxFee: ()=>estimatedFeeToMaxFee,
                formatSignature: ()=>formatSignature,
                makeAddress: ()=>makeAddress,
                randomAddress: ()=>randomAddress
            });
            var import_pako = __webpack_require__(96456);
            function compressProgram(jsonProgram) {
                const stringified = "string" == typeof jsonProgram ? jsonProgram : stringify(jsonProgram);
                return btoaUniversal((0,
                import_pako.gzip)(stringified))
            }
            function randomAddress() {
                return getStarkKey(genKeyPair())
            }
            function makeAddress(input) {
                return addHexPrefix(input).toLowerCase()
            }
            function formatSignature(sig) {
                if (!sig)
                    return [];
                try {
                    return sig.map((x=>toBN(x))).map((x=>x.toString()))
                } catch (e) {
                    return []
                }
            }
            function compileCalldata(args) {
                return Object.values(args).flatMap((value=>Array.isArray(value) ? [toBN(value.length).toString(), ...value.map((x=>toBN(x).toString()))] : "object" == typeof value && "type"in value ? Object.entries(value).filter((([k])=>"type" !== k)).map((([,v])=>toBN(v).toString())) : toBN(value).toString()))
            }
            function estimatedFeeToMaxFee(estimatedFee, overhead=.5) {
                const overHeadPercent = Math.round(100 * (1 + overhead));
                return toBN(estimatedFee).mul(toBN(overHeadPercent)).div(toBN(100))
            }
            function wait(delay) {
                return new Promise((res=>{
                    setTimeout(res, delay)
                }
                ))
            }
            function parseCalldata(calldata=[]) {
                return calldata.map((data=>"string" == typeof data && isHex(data) ? data : toHex(toBN(data))))
            }
            function parseContract(contract) {
                const parsedContract = "string" == typeof contract ? parse(contract) : contract;
                return {
                    ...parsedContract,
                    program: compressProgram(parsedContract.program)
                }
            }
            var import_ts_custom_error = __webpack_require__(13631)
              , LibraryError = class extends import_ts_custom_error.CustomError {
            }
              , GatewayError = class extends LibraryError {
                constructor(message, errorCode) {
                    super(message),
                    this.errorCode = errorCode
                }
            }
              , HttpError = class extends LibraryError {
                constructor(message, errorCode) {
                    super(message),
                    this.errorCode = errorCode
                }
            }
              , import_bn3 = __webpack_require__(63742)
              , import_bn2 = __toESM(__webpack_require__(63742))
              , basicAlphabet = "abcdefghijklmnopqrstuvwxyz0123456789-"
              , basicSizePlusOne = new import_bn2.default(basicAlphabet.length + 1)
              , bigAlphabet = "这来"
              , basicAlphabetSize = new import_bn2.default(basicAlphabet.length)
              , bigAlphabetSize = new import_bn2.default(bigAlphabet.length)
              , bigAlphabetSizePlusOne = new import_bn2.default(bigAlphabet.length + 1);
            function extractStars(str) {
                let k = 0;
                for (; str.endsWith(bigAlphabet[bigAlphabet.length - 1]); )
                    str = str.substring(0, str.length - 1),
                    k += 1;
                return [str, k]
            }
            function useEncoded(decoded) {
                let encoded = new import_bn2.default(0)
                  , multiplier = new import_bn2.default(1);
                if (decoded.endsWith(bigAlphabet[0] + basicAlphabet[1])) {
                    const [str,k] = extractStars(decoded.substring(0, decoded.length - 2));
                    decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(2 * (k + 1))
                } else {
                    const [str,k] = extractStars(decoded);
                    k && (decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(1 + 2 * (k - 1)))
                }
                for (let i = 0; i < decoded.length; i += 1) {
                    const char = decoded[i]
                      , index = basicAlphabet.indexOf(char)
                      , bnIndex = new import_bn2.default(basicAlphabet.indexOf(char));
                    if (-1 !== index)
                        i === decoded.length - 1 && decoded[i] === basicAlphabet[0] ? (encoded = encoded.add(multiplier.mul(basicAlphabetSize)),
                        multiplier = multiplier.mul(basicSizePlusOne),
                        multiplier = multiplier.mul(basicSizePlusOne)) : (encoded = encoded.add(multiplier.mul(bnIndex)),
                        multiplier = multiplier.mul(basicSizePlusOne));
                    else if (-1 !== bigAlphabet.indexOf(char)) {
                        encoded = encoded.add(multiplier.mul(basicAlphabetSize)),
                        multiplier = multiplier.mul(basicSizePlusOne);
                        const newid = (i === decoded.length - 1 ? 1 : 0) + bigAlphabet.indexOf(char);
                        encoded = encoded.add(multiplier.mul(new import_bn2.default(newid))),
                        multiplier = multiplier.mul(bigAlphabetSize)
                    }
                }
                return encoded
            }
            function getStarknetIdContract(chainId) {
                switch (chainId) {
                case "0x534e5f4d41494e":
                    return "0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678";
                case "0x534e5f474f45524c49":
                    return "0x05cf267a0af6101667013fc6bd3f6c11116a14cda9b8c4b1198520d59f900b17";
                default:
                    throw new Error("Starknet.id is not yet deployed on this network")
                }
            }
            async function getStarkName(provider, address, StarknetIdContract) {
                const chainId = await provider.getChainId()
                  , contract = StarknetIdContract ?? getStarknetIdContract(chainId);
                try {
                    const hexDomain = await provider.callContract({
                        contractAddress: contract,
                        entrypoint: "address_to_domain",
                        calldata: compileCalldata({
                            address: toHex(toBN(address))
                        })
                    })
                      , stringDomain = function(encoded) {
                        let decoded = "";
                        return encoded.forEach((subdomain=>{
                            for (; !subdomain.isZero(); ) {
                                const code = subdomain.mod(basicSizePlusOne).toNumber();
                                if (subdomain = subdomain.div(basicSizePlusOne),
                                code === basicAlphabet.length) {
                                    const nextSubdomain = subdomain.div(bigAlphabetSizePlusOne);
                                    if (nextSubdomain.isZero()) {
                                        const code2 = subdomain.mod(bigAlphabetSizePlusOne).toNumber();
                                        subdomain = nextSubdomain,
                                        decoded += 0 === code2 ? basicAlphabet[0] : bigAlphabet[code2 - 1]
                                    } else {
                                        const code2 = subdomain.mod(bigAlphabetSize).toNumber();
                                        decoded += bigAlphabet[code2],
                                        subdomain = subdomain.div(bigAlphabetSize)
                                    }
                                } else
                                    decoded += basicAlphabet[code]
                            }
                            const [str,k] = extractStars(decoded);
                            k && (decoded = str + (k % 2 == 0 ? bigAlphabet[bigAlphabet.length - 1].repeat(k / 2 - 1) + bigAlphabet[0] + basicAlphabet[1] : bigAlphabet[bigAlphabet.length - 1].repeat((k - 1) / 2 + 1))),
                            decoded += "."
                        }
                        )),
                        decoded ? decoded.concat("stark") : decoded
                    }(hexDomain.result.map((element=>new import_bn3.BN(hexToDecimalString(element)))).slice(1));
                    if (!stringDomain)
                        throw Error("Starkname not found");
                    return stringDomain
                } catch (e) {
                    if (e instanceof Error && "Starkname not found" === e.message)
                        throw e;
                    throw Error("Could not get stark name")
                }
            }
            async function getAddressFromStarkName(provider, name, StarknetIdContract) {
                const chainId = await provider.getChainId()
                  , contract = StarknetIdContract ?? getStarknetIdContract(chainId);
                try {
                    return (await provider.callContract({
                        contractAddress: contract,
                        entrypoint: "domain_to_address",
                        calldata: compileCalldata({
                            domain: [useEncoded(name.replace(".stark", "")).toString(10)]
                        })
                    })).result[0]
                } catch {
                    throw Error("Could not get address from stark name")
                }
            }
            var import_bn4 = __webpack_require__(63742)
              , validBlockTags = ["latest", "pending"]
              , Block = class {
                constructor(_identifier) {
                    this.hash = null,
                    this.number = null,
                    this.tag = null,
                    this.valueOf = ()=>this.number,
                    this.toString = ()=>this.hash,
                    this.setIdentifier(_identifier)
                }
                setIdentifier(__identifier) {
                    "string" == typeof __identifier && isHex(__identifier) ? this.hash = __identifier : import_bn4.BN.isBN(__identifier) ? this.hash = toHex(__identifier) : "number" == typeof __identifier ? this.number = __identifier : "string" == typeof __identifier && validBlockTags.includes(__identifier) ? this.tag = __identifier : this.tag = "pending"
                }
                get queryIdentifier() {
                    return null !== this.number ? `blockNumber=${this.number}` : null !== this.hash ? `blockHash=${this.hash}` : `blockNumber=${this.tag}`
                }
                get identifier() {
                    return null !== this.number ? {
                        block_number: this.number
                    } : null !== this.hash ? {
                        block_hash: this.hash
                    } : this.tag
                }
                set identifier(_identifier) {
                    this.setIdentifier(_identifier)
                }
                get sequencerIdentifier() {
                    return null !== this.hash ? {
                        blockHash: this.hash
                    } : {
                        blockNumber: this.number ?? this.tag
                    }
                }
            }
              , defaultOptions_headers = {
                "Content-Type": "application/json"
            }
              , defaultOptions_blockIdentifier = "latest"
              , defaultOptions_retries = 200
              , RpcProvider = class {
                constructor(optionsOrProvider) {
                    this.responseParser = new class {
                        parseGetBlockResponse(res) {
                            return {
                                timestamp: res.timestamp,
                                block_hash: res.block_hash,
                                block_number: res.block_number,
                                new_root: res.new_root,
                                parent_hash: res.parent_hash,
                                status: res.status,
                                transactions: res.transactions
                            }
                        }
                        parseGetTransactionResponse(res) {
                            return {
                                calldata: res.calldata || [],
                                contract_address: res.contract_address,
                                max_fee: res.max_fee,
                                nonce: res.nonce,
                                signature: res.signature || [],
                                transaction_hash: res.transaction_hash,
                                version: res.version
                            }
                        }
                        parseFeeEstimateResponse(res) {
                            return {
                                overall_fee: toBN(res.overall_fee),
                                gas_consumed: toBN(res.gas_consumed),
                                gas_price: toBN(res.gas_price)
                            }
                        }
                        parseCallContractResponse(res) {
                            return {
                                result: res
                            }
                        }
                    }
                    ;
                    const {nodeUrl, chainId, retries, headers, blockIdentifier} = optionsOrProvider;
                    this.nodeUrl = nodeUrl,
                    this.chainId = chainId,
                    this.retries = retries || defaultOptions_retries,
                    this.headers = {
                        ...defaultOptions_headers,
                        ...headers
                    },
                    this.blockIdentifier = blockIdentifier || defaultOptions_blockIdentifier,
                    chainId || this.getChainId().then((chainId=>{
                        this.chainId = chainId
                    }
                    ))
                }
                fetch(method, params) {
                    return fetchPonyfill_default(this.nodeUrl, {
                        method: "POST",
                        body: stringify({
                            method,
                            jsonrpc: "2.0",
                            params,
                            id: 0
                        }),
                        headers: this.headers
                    })
                }
                errorHandler(error) {
                    if (error) {
                        const {code, message} = error;
                        throw new LibraryError(`${code}: ${message}`)
                    }
                }
                async fetchEndpoint(method, params) {
                    var _a;
                    try {
                        const rawResult = await this.fetch(method, params)
                          , {error, result} = await rawResult.json();
                        return this.errorHandler(error),
                        result
                    } catch (error) {
                        throw this.errorHandler(null == (_a = null == error ? void 0 : error.response) ? void 0 : _a.data),
                        error
                    }
                }
                async getChainId() {
                    return this.fetchEndpoint("starknet_chainId")
                }
                async getBlock(blockIdentifier=this.blockIdentifier) {
                    return this.getBlockWithTxHashes(blockIdentifier).then(this.responseParser.parseGetBlockResponse)
                }
                async getBlockHashAndNumber() {
                    return this.fetchEndpoint("starknet_blockHashAndNumber")
                }
                async getBlockWithTxHashes(blockIdentifier=this.blockIdentifier) {
                    const block_id = new Block(blockIdentifier).identifier;
                    return this.fetchEndpoint("starknet_getBlockWithTxHashes", {
                        block_id
                    })
                }
                async getBlockWithTxs(blockIdentifier=this.blockIdentifier) {
                    const block_id = new Block(blockIdentifier).identifier;
                    return this.fetchEndpoint("starknet_getBlockWithTxs", {
                        block_id
                    })
                }
                async getClassHashAt(contractAddress, blockIdentifier=this.blockIdentifier) {
                    const block_id = new Block(blockIdentifier).identifier;
                    return this.fetchEndpoint("starknet_getClassHashAt", {
                        block_id,
                        contract_address: contractAddress
                    })
                }
                async getNonceForAddress(contractAddress, blockIdentifier=this.blockIdentifier) {
                    const block_id = new Block(blockIdentifier).identifier;
                    return this.fetchEndpoint("starknet_getNonce", {
                        contract_address: contractAddress,
                        block_id
                    })
                }
                async getPendingTransactions() {
                    return this.fetchEndpoint("starknet_pendingTransactions")
                }
                async getProtocolVersion() {
                    throw new Error("Pathfinder does not implement this rpc 0.1.0 method")
                }
                async getStateUpdate(blockIdentifier=this.blockIdentifier) {
                    const block_id = new Block(blockIdentifier).identifier;
                    return this.fetchEndpoint("starknet_getStateUpdate", {
                        block_id
                    })
                }
                async getStorageAt(contractAddress, key, blockIdentifier=this.blockIdentifier) {
                    const parsedKey = toHex(toBN(key))
                      , block_id = new Block(blockIdentifier).identifier;
                    return this.fetchEndpoint("starknet_getStorageAt", {
                        contract_address: contractAddress,
                        key: parsedKey,
                        block_id
                    })
                }
                async getTransaction(txHash) {
                    return this.getTransactionByHash(txHash).then(this.responseParser.parseGetTransactionResponse)
                }
                async getTransactionByHash(txHash) {
                    return this.fetchEndpoint("starknet_getTransactionByHash", {
                        transaction_hash: txHash
                    })
                }
                async getTransactionByBlockIdAndIndex(blockIdentifier, index) {
                    const block_id = new Block(blockIdentifier).identifier;
                    return this.fetchEndpoint("starknet_getTransactionByBlockIdAndIndex", {
                        block_id,
                        index
                    })
                }
                async getTransactionReceipt(txHash) {
                    return this.fetchEndpoint("starknet_getTransactionReceipt", {
                        transaction_hash: txHash
                    })
                }
                async getClassByHash(classHash) {
                    return this.getClass(classHash)
                }
                async getClass(classHash, blockIdentifier=this.blockIdentifier) {
                    const block_id = new Block(blockIdentifier).identifier;
                    return this.fetchEndpoint("starknet_getClass", {
                        class_hash: classHash,
                        block_id
                    })
                }
                async getClassAt(contractAddress, blockIdentifier=this.blockIdentifier) {
                    const block_id = new Block(blockIdentifier).identifier;
                    return this.fetchEndpoint("starknet_getClassAt", {
                        block_id,
                        contract_address: contractAddress
                    })
                }
                async getCode(_contractAddress, _blockIdentifier) {
                    throw new Error("RPC does not implement getCode function")
                }
                async getEstimateFee(invocation, invocationDetails, blockIdentifier=this.blockIdentifier) {
                    return this.getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier)
                }
                async getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier=this.blockIdentifier) {
                    const block_id = new Block(blockIdentifier).identifier;
                    return this.fetchEndpoint("starknet_estimateFee", {
                        request: {
                            type: "INVOKE",
                            sender_address: invocation.contractAddress,
                            calldata: parseCalldata(invocation.calldata),
                            signature: bigNumberishArrayToHexadecimalStringArray(invocation.signature || []),
                            version: toHex(toBN((null == invocationDetails ? void 0 : invocationDetails.version) || 0)),
                            nonce: toHex(toBN(invocationDetails.nonce)),
                            max_fee: toHex(toBN((null == invocationDetails ? void 0 : invocationDetails.maxFee) || 0))
                        },
                        block_id
                    }).then(this.responseParser.parseFeeEstimateResponse)
                }
                async getDeclareEstimateFee({senderAddress, contractDefinition, signature}, details, blockIdentifier=this.blockIdentifier) {
                    const block_id = new Block(blockIdentifier).identifier;
                    return this.fetchEndpoint("starknet_estimateFee", {
                        request: {
                            type: "DECLARE",
                            contract_class: {
                                program: contractDefinition.program,
                                entry_points_by_type: contractDefinition.entry_points_by_type,
                                abi: contractDefinition.abi
                            },
                            sender_address: senderAddress,
                            signature: bigNumberishArrayToHexadecimalStringArray(signature || []),
                            version: toHex(toBN((null == details ? void 0 : details.version) || 0)),
                            nonce: toHex(toBN(details.nonce)),
                            max_fee: toHex(toBN((null == details ? void 0 : details.maxFee) || 0))
                        },
                        block_id
                    }).then(this.responseParser.parseFeeEstimateResponse)
                }
                async getDeployAccountEstimateFee({classHash, constructorCalldata, addressSalt, signature}, details, blockIdentifier=this.blockIdentifier) {
                    const block_id = new Block(blockIdentifier).identifier;
                    return this.fetchEndpoint("starknet_estimateFee", {
                        request: {
                            type: "DEPLOY_ACCOUNT",
                            constructor_calldata: bigNumberishArrayToHexadecimalStringArray(constructorCalldata || []),
                            class_hash: toHex(toBN(classHash)),
                            contract_address_salt: toHex(toBN(addressSalt || 0)),
                            signature: bigNumberishArrayToHexadecimalStringArray(signature || []),
                            version: toHex(toBN((null == details ? void 0 : details.version) || 0)),
                            nonce: toHex(toBN(details.nonce)),
                            max_fee: toHex(toBN((null == details ? void 0 : details.maxFee) || 0))
                        },
                        block_id
                    }).then(this.responseParser.parseFeeEstimateResponse)
                }
                async getEstimateFeeBulk(_invocations, _blockIdentifier=this.blockIdentifier) {
                    throw new Error("RPC does not implement getInvokeEstimateFeeBulk function")
                }
                async declareContract({contractDefinition, signature, senderAddress}, details) {
                    return this.fetchEndpoint("starknet_addDeclareTransaction", {
                        declare_transaction: {
                            contract_class: {
                                program: contractDefinition.program,
                                entry_points_by_type: contractDefinition.entry_points_by_type,
                                abi: contractDefinition.abi
                            },
                            type: "DECLARE",
                            version: toHex(toBN(details.version || 0)),
                            max_fee: toHex(toBN(details.maxFee || 0)),
                            signature: bigNumberishArrayToHexadecimalStringArray(signature || []),
                            sender_address: senderAddress,
                            nonce: toHex(toBN(details.nonce))
                        }
                    })
                }
                async deployAccountContract({classHash, constructorCalldata, addressSalt, signature}, details) {
                    return this.fetchEndpoint("starknet_addDeployAccountTransaction", {
                        deploy_account_transaction: {
                            constructor_calldata: bigNumberishArrayToHexadecimalStringArray(constructorCalldata || []),
                            class_hash: toHex(toBN(classHash)),
                            contract_address_salt: toHex(toBN(addressSalt || 0)),
                            type: "DEPLOY_ACCOUNT",
                            max_fee: toHex(toBN(details.maxFee || 0)),
                            version: toHex(toBN(details.version || 0)),
                            signature: bigNumberishArrayToHexadecimalStringArray(signature || []),
                            nonce: toHex(toBN(details.nonce))
                        }
                    })
                }
                async invokeFunction(functionInvocation, details) {
                    return this.fetchEndpoint("starknet_addInvokeTransaction", {
                        invoke_transaction: {
                            sender_address: functionInvocation.contractAddress,
                            calldata: parseCalldata(functionInvocation.calldata),
                            type: "INVOKE",
                            max_fee: toHex(toBN(details.maxFee || 0)),
                            version: toHex(toBN(details.version || 1)),
                            signature: bigNumberishArrayToHexadecimalStringArray(functionInvocation.signature || []),
                            nonce: toHex(toBN(details.nonce))
                        }
                    })
                }
                async callContract(call, blockIdentifier=this.blockIdentifier) {
                    const block_id = new Block(blockIdentifier).identifier
                      , result = await this.fetchEndpoint("starknet_call", {
                        request: {
                            contract_address: call.contractAddress,
                            entry_point_selector: getSelectorFromName(call.entrypoint),
                            calldata: parseCalldata(call.calldata)
                        },
                        block_id
                    });
                    return this.responseParser.parseCallContractResponse(result)
                }
                async traceTransaction(transactionHash) {
                    return this.fetchEndpoint("starknet_traceTransaction", {
                        transaction_hash: transactionHash
                    })
                }
                async traceBlockTransactions(blockHash) {
                    return this.fetchEndpoint("starknet_traceBlockTransactions", {
                        block_hash: blockHash
                    })
                }
                async waitForTransaction(txHash, retryInterval=8e3, successStates=["ACCEPTED_ON_L1", "ACCEPTED_ON_L2", "PENDING"]) {
                    const errorStates = ["REJECTED", "NOT_RECEIVED"];
                    let {retries} = this
                      , onchain = !1
                      , txReceipt = {};
                    for (; !onchain; ) {
                        await wait(retryInterval);
                        try {
                            if (txReceipt = await this.getTransactionReceipt(txHash),
                            !("status"in txReceipt)) {
                                throw new Error("pending transaction")
                            }
                            if (txReceipt.status && successStates.includes(txReceipt.status))
                                onchain = !0;
                            else if (txReceipt.status && errorStates.includes(txReceipt.status)) {
                                const message = txReceipt.status
                                  , error = new Error(message);
                                throw error.response = txReceipt,
                                error
                            }
                        } catch (error) {
                            if (error instanceof Error && errorStates.includes(error.message))
                                throw error;
                            if (0 === retries)
                                throw new Error(`waitForTransaction timed-out with retries ${this.retries}`)
                        }
                        retries -= 1
                    }
                    return await wait(retryInterval),
                    txReceipt
                }
                async getTransactionCount(blockIdentifier=this.blockIdentifier) {
                    const block_id = new Block(blockIdentifier).identifier;
                    return this.fetchEndpoint("starknet_getBlockTransactionCount", {
                        block_id
                    })
                }
                async getBlockNumber() {
                    return this.fetchEndpoint("starknet_blockNumber")
                }
                async getSyncingStats() {
                    return this.fetchEndpoint("starknet_syncing")
                }
                async getEvents(eventFilter) {
                    return this.fetchEndpoint("starknet_getEvents", {
                        filter: eventFilter
                    })
                }
                async getSimulateTransaction(_invocation, _invocationDetails, _blockIdentifier) {
                    throw new Error("RPC does not implement simulateTransaction function")
                }
                async getStarkName(address, StarknetIdContract) {
                    return getStarkName(this, address, StarknetIdContract)
                }
                async getAddressFromStarkName(name, StarknetIdContract) {
                    return getAddressFromStarkName(this, name, StarknetIdContract)
                }
            }
              , import_url_join2 = __toESM(__webpack_require__(34078))
              , ResponseParser = class {
            }
              , SequencerAPIResponseParser = class extends ResponseParser {
                parseGetBlockResponse(res) {
                    return {
                        ...res,
                        new_root: res.state_root,
                        parent_hash: res.parent_block_hash,
                        transactions: Object.values(res.transactions).map((value=>"transaction_hash"in value && value.transaction_hash)).filter(Boolean)
                    }
                }
                parseGetTransactionResponse(res) {
                    return {
                        ...res,
                        calldata: "calldata"in res.transaction ? res.transaction.calldata : [],
                        contract_address: "contract_address"in res.transaction ? res.transaction.contract_address : void 0,
                        contract_class: "contract_class"in res.transaction ? res.transaction.contract_class : void 0,
                        entry_point_selector: "entry_point_selector"in res.transaction ? res.transaction.entry_point_selector : void 0,
                        max_fee: "max_fee"in res.transaction ? res.transaction.max_fee : void 0,
                        nonce: res.transaction.nonce,
                        sender_address: "sender_address"in res.transaction ? res.transaction.sender_address : void 0,
                        signature: "signature"in res.transaction ? res.transaction.signature : void 0,
                        transaction_hash: "transaction_hash"in res.transaction ? res.transaction.transaction_hash : void 0,
                        version: "version"in res.transaction ? res.transaction.version : void 0
                    }
                }
                parseGetTransactionReceiptResponse(res) {
                    return {
                        transaction_hash: res.transaction_hash,
                        status: res.status,
                        messages_sent: res.l2_to_l1_messages,
                        events: res.events,
                        ..."block_hash"in res && {
                            block_hash: res.block_hash
                        },
                        ..."block_number"in res && {
                            block_number: res.block_number
                        },
                        ..."actual_fee"in res && {
                            actual_fee: res.actual_fee
                        },
                        ..."transaction_index"in res && {
                            transaction_index: res.transaction_index
                        },
                        ..."execution_resources"in res && {
                            execution_resources: res.execution_resources
                        },
                        ..."l1_to_l2_consumed_message"in res && {
                            l1_to_l2_consumed_message: res.l1_to_l2_consumed_message
                        },
                        ..."transaction_failure_reason"in res && {
                            transaction_failure_reason: res.transaction_failure_reason
                        }
                    }
                }
                parseFeeEstimateResponse(res) {
                    if ("overall_fee"in res) {
                        let gasInfo = {};
                        try {
                            gasInfo = {
                                gas_consumed: toBN(res.gas_usage),
                                gas_price: toBN(res.gas_price)
                            }
                        } catch {}
                        return {
                            overall_fee: toBN(res.overall_fee),
                            ...gasInfo
                        }
                    }
                    return {
                        overall_fee: toBN(res.amount)
                    }
                }
                parseFeeEstimateBulkResponse(res) {
                    return [].concat(res).map((item=>{
                        if ("overall_fee"in item) {
                            let gasInfo = {};
                            try {
                                gasInfo = {
                                    gas_consumed: toBN(item.gas_usage),
                                    gas_price: toBN(item.gas_price)
                                }
                            } catch {}
                            return {
                                overall_fee: toBN(item.overall_fee),
                                ...gasInfo
                            }
                        }
                        return {
                            overall_fee: toBN(item.amount)
                        }
                    }
                    ))
                }
                parseFeeSimulateTransactionResponse(res) {
                    if ("overall_fee"in res.fee_estimation) {
                        let gasInfo = {};
                        try {
                            gasInfo = {
                                gas_consumed: toBN(res.fee_estimation.gas_usage),
                                gas_price: toBN(res.fee_estimation.gas_price)
                            }
                        } catch {}
                        return {
                            trace: res.trace,
                            fee_estimation: {
                                ...gasInfo,
                                overall_fee: toBN(res.fee_estimation.overall_fee)
                            }
                        }
                    }
                    return {
                        trace: res.trace,
                        fee_estimation: {
                            overall_fee: toBN(res.fee_estimation.amount)
                        }
                    }
                }
                parseCallContractResponse(res) {
                    return {
                        result: res.result
                    }
                }
                parseInvokeFunctionResponse(res) {
                    return {
                        transaction_hash: res.transaction_hash
                    }
                }
                parseDeployContractResponse(res) {
                    return {
                        transaction_hash: res.transaction_hash,
                        contract_address: res.address
                    }
                }
                parseDeclareContractResponse(res) {
                    return {
                        transaction_hash: res.transaction_hash,
                        class_hash: res.class_hash
                    }
                }
                parseGetStateUpdateResponse(res) {
                    const nonces = [].concat(res.state_diff.nonces).map((({contract_address, nonce})=>({
                        contract_address,
                        nonce
                    })))
                      , storage_diffs = [].concat(res.state_diff.storage_diffs).map((({address, storage_entries})=>({
                        address,
                        storage_entries
                    })));
                    return {
                        ...res,
                        state_diff: {
                            storage_diffs,
                            declared_contract_hashes: res.state_diff.declared_contract_hashes,
                            deployed_contracts: res.state_diff.deployed_contracts,
                            nonces
                        }
                    }
                }
            }
              , import_url_join = __toESM(__webpack_require__(34078))
              , protocolAndDomainRE = /^(?:\w+:)?\/\/(\S+)$/
              , localhostDomainRE = /^localhost[:?\d]*(?:[^:?\d]\S*)?$/
              , nonLocalhostDomainRE = /^[^\s.]+\.\S{2,}$/;
            function isUrl(s) {
                if (!s)
                    return !1;
                if ("string" != typeof s)
                    return !1;
                const match = s.match(protocolAndDomainRE);
                if (!match)
                    return !1;
                const everythingAfterProtocol = match[1];
                return !!everythingAfterProtocol && !(!localhostDomainRE.test(everythingAfterProtocol) && !nonLocalhostDomainRE.test(everythingAfterProtocol))
            }
            function buildUrl(baseUrl, defaultPath, urlOrPath) {
                return isUrl(urlOrPath) ? urlOrPath : (0,
                import_url_join.default)(baseUrl, urlOrPath ?? defaultPath)
            }
            var defaultOptions2 = {
                network: "goerli-alpha-2",
                blockIdentifier: "pending"
            }
              , SequencerProvider = class {
                constructor(optionsOrProvider=defaultOptions2) {
                    this.responseParser = new SequencerAPIResponseParser,
                    "network"in optionsOrProvider ? (this.baseUrl = SequencerProvider.getNetworkFromName(optionsOrProvider.network),
                    this.feederGatewayUrl = buildUrl(this.baseUrl, "feeder_gateway"),
                    this.gatewayUrl = buildUrl(this.baseUrl, "gateway")) : (this.baseUrl = optionsOrProvider.baseUrl,
                    this.feederGatewayUrl = buildUrl(this.baseUrl, "feeder_gateway", optionsOrProvider.feederGatewayUrl),
                    this.gatewayUrl = buildUrl(this.baseUrl, "gateway", optionsOrProvider.gatewayUrl)),
                    this.chainId = (null == optionsOrProvider ? void 0 : optionsOrProvider.chainId) ?? SequencerProvider.getChainIdFromBaseUrl(this.baseUrl),
                    this.headers = optionsOrProvider.headers,
                    this.blockIdentifier = (null == optionsOrProvider ? void 0 : optionsOrProvider.blockIdentifier) || defaultOptions2.blockIdentifier
                }
                static getNetworkFromName(name) {
                    switch (name) {
                    case "mainnet-alpha":
                        return "https://alpha-mainnet.starknet.io";
                    case "goerli-alpha":
                    default:
                        return "https://alpha4.starknet.io";
                    case "goerli-alpha-2":
                        return "https://alpha4-2.starknet.io"
                    }
                }
                static getChainIdFromBaseUrl(baseUrl) {
                    try {
                        const url = new URL(baseUrl);
                        if (url.host.includes("mainnet.starknet.io"))
                            return "0x534e5f4d41494e";
                        if (url.host.includes("alpha4-2.starknet.io"))
                            return "0x534e5f474f45524c4932"
                    } catch {}
                    return "0x534e5f474f45524c49"
                }
                getFetchUrl(endpoint) {
                    return ["add_transaction"].includes(endpoint) ? this.gatewayUrl : this.feederGatewayUrl
                }
                getFetchMethod(endpoint) {
                    return ["add_transaction", "call_contract", "estimate_fee", "estimate_message_fee", "estimate_fee_bulk", "simulate_transaction"].includes(endpoint) ? "POST" : "GET"
                }
                getQueryString(query) {
                    if (void 0 === (obj = query) || 0 === Object.keys(obj).length || 1 === Object.keys(obj).length && Object.entries(obj).every((([k,v])=>"blockIdentifier" === k && null === v)))
                        return "";
                    var obj;
                    return `?${Object.entries(query).map((([key,value])=>{
                        if ("blockIdentifier" === key) {
                            return `${new Block(value).queryIdentifier}`
                        }
                        return `${key}=${value}`
                    }
                    )).join("&")}`
                }
                getHeaders(method) {
                    return "POST" === method ? {
                        "Content-Type": "application/json",
                        ...this.headers
                    } : this.headers
                }
                async fetchEndpoint(endpoint, ...[query,request]) {
                    const baseUrl = this.getFetchUrl(endpoint)
                      , method = this.getFetchMethod(endpoint)
                      , queryString = this.getQueryString(query)
                      , headers = this.getHeaders(method)
                      , url = (0,
                    import_url_join2.default)(baseUrl, endpoint, queryString);
                    try {
                        const res = await fetchPonyfill_default(url, {
                            method,
                            body: stringify(request),
                            headers
                        })
                          , textResponse = await res.text();
                        if (!res.ok) {
                            let responseBody;
                            try {
                                responseBody = parse(textResponse)
                            } catch {
                                throw new HttpError(res.statusText,res.status)
                            }
                            const errorCode = responseBody.code || (null == responseBody ? void 0 : responseBody.status_code);
                            throw new GatewayError(responseBody.message,errorCode)
                        }
                        return "estimate_fee" === endpoint ? parseAlwaysAsBig(textResponse, ((_,v)=>v && "bigint" == typeof v ? toBN(v.toString()) : v)) : parse(textResponse)
                    } catch (err) {
                        if (err instanceof GatewayError || err instanceof HttpError)
                            throw err;
                        if (err instanceof Error)
                            throw Error(`Could not ${method} from endpoint \`${url}\`: ${err.message}`);
                        throw err
                    }
                }
                async getChainId() {
                    return Promise.resolve(this.chainId)
                }
                async callContract({contractAddress, entrypoint: entryPointSelector, calldata=[]}, blockIdentifier=this.blockIdentifier) {
                    return this.fetchEndpoint("call_contract", {
                        blockIdentifier
                    }, {
                        signature: [],
                        contract_address: contractAddress,
                        entry_point_selector: getSelectorFromName(entryPointSelector),
                        calldata
                    }).then(this.responseParser.parseCallContractResponse)
                }
                async getBlock(blockIdentifier=this.blockIdentifier) {
                    return this.fetchEndpoint("get_block", {
                        blockIdentifier
                    }).then(this.responseParser.parseGetBlockResponse)
                }
                async getNonceForAddress(contractAddress, blockIdentifier=this.blockIdentifier) {
                    return this.fetchEndpoint("get_nonce", {
                        contractAddress,
                        blockIdentifier
                    })
                }
                async getStorageAt(contractAddress, key, blockIdentifier=this.blockIdentifier) {
                    const parsedKey = toBN(key).toString(10);
                    return this.fetchEndpoint("get_storage_at", {
                        blockIdentifier,
                        contractAddress,
                        key: parsedKey
                    })
                }
                async getTransaction(txHash) {
                    const txHashHex = toHex(toBN(txHash));
                    return this.fetchEndpoint("get_transaction", {
                        transactionHash: txHashHex
                    }).then((result=>{
                        if (1 === Object.values(result).length)
                            throw new LibraryError(result.status);
                        return this.responseParser.parseGetTransactionResponse(result)
                    }
                    ))
                }
                async getTransactionReceipt(txHash) {
                    const txHashHex = toHex(toBN(txHash));
                    return this.fetchEndpoint("get_transaction_receipt", {
                        transactionHash: txHashHex
                    }).then(this.responseParser.parseGetTransactionReceiptResponse)
                }
                async getClassAt(contractAddress, blockIdentifier=this.blockIdentifier) {
                    return this.fetchEndpoint("get_full_contract", {
                        blockIdentifier,
                        contractAddress
                    }).then(parseContract)
                }
                async getClassHashAt(contractAddress, blockIdentifier=this.blockIdentifier) {
                    return this.fetchEndpoint("get_class_hash_at", {
                        blockIdentifier,
                        contractAddress
                    })
                }
                async getClassByHash(classHash) {
                    return this.fetchEndpoint("get_class_by_hash", {
                        classHash
                    }).then(parseContract)
                }
                async invokeFunction(functionInvocation, details) {
                    return this.fetchEndpoint("add_transaction", void 0, {
                        type: "INVOKE_FUNCTION",
                        contract_address: functionInvocation.contractAddress,
                        calldata: bigNumberishArrayToDecimalStringArray(functionInvocation.calldata ?? []),
                        signature: bigNumberishArrayToDecimalStringArray(functionInvocation.signature ?? []),
                        nonce: toHex(toBN(details.nonce)),
                        max_fee: toHex(toBN(details.maxFee || 0)),
                        version: toHex(toBN(details.version || 1))
                    }).then(this.responseParser.parseInvokeFunctionResponse)
                }
                async deployAccountContract({classHash, constructorCalldata, addressSalt, signature}, details) {
                    return this.fetchEndpoint("add_transaction", void 0, {
                        type: "DEPLOY_ACCOUNT",
                        contract_address_salt: addressSalt ?? randomAddress(),
                        constructor_calldata: bigNumberishArrayToDecimalStringArray(constructorCalldata ?? []),
                        class_hash: toHex(toBN(classHash)),
                        max_fee: toHex(toBN(details.maxFee || 0)),
                        version: toHex(toBN(details.version || 0)),
                        nonce: toHex(toBN(details.nonce)),
                        signature: bigNumberishArrayToDecimalStringArray(signature || [])
                    }).then(this.responseParser.parseDeployContractResponse)
                }
                async declareContract({senderAddress, contractDefinition, signature}, details) {
                    return this.fetchEndpoint("add_transaction", void 0, {
                        type: "DECLARE",
                        contract_class: contractDefinition,
                        nonce: toHex(toBN(details.nonce)),
                        signature: bigNumberishArrayToDecimalStringArray(signature || []),
                        sender_address: senderAddress,
                        max_fee: toHex(toBN(details.maxFee || 0)),
                        version: toHex(toBN(details.version || 1))
                    }).then(this.responseParser.parseDeclareContractResponse)
                }
                async getEstimateFee(invocation, invocationDetails, blockIdentifier=this.blockIdentifier) {
                    return this.getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier)
                }
                async getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier=this.blockIdentifier) {
                    return this.fetchEndpoint("estimate_fee", {
                        blockIdentifier
                    }, {
                        type: "INVOKE_FUNCTION",
                        contract_address: invocation.contractAddress,
                        calldata: invocation.calldata ?? [],
                        signature: bigNumberishArrayToDecimalStringArray(invocation.signature || []),
                        version: toHex(toBN((null == invocationDetails ? void 0 : invocationDetails.version) || 1)),
                        nonce: toHex(toBN(invocationDetails.nonce))
                    }).then(this.responseParser.parseFeeEstimateResponse)
                }
                async getDeclareEstimateFee({senderAddress, contractDefinition, signature}, details, blockIdentifier=this.blockIdentifier) {
                    return this.fetchEndpoint("estimate_fee", {
                        blockIdentifier
                    }, {
                        type: "DECLARE",
                        sender_address: senderAddress,
                        contract_class: contractDefinition,
                        signature: bigNumberishArrayToDecimalStringArray(signature || []),
                        version: toHex(toBN((null == details ? void 0 : details.version) || 1)),
                        nonce: toHex(toBN(details.nonce))
                    }).then(this.responseParser.parseFeeEstimateResponse)
                }
                async getDeployAccountEstimateFee({classHash, addressSalt, constructorCalldata, signature}, details, blockIdentifier=this.blockIdentifier) {
                    return this.fetchEndpoint("estimate_fee", {
                        blockIdentifier
                    }, {
                        type: "DEPLOY_ACCOUNT",
                        class_hash: toHex(toBN(classHash)),
                        constructor_calldata: bigNumberishArrayToDecimalStringArray(constructorCalldata || []),
                        contract_address_salt: toHex(toBN(addressSalt || 0)),
                        signature: bigNumberishArrayToDecimalStringArray(signature || []),
                        version: toHex(toBN((null == details ? void 0 : details.version) || 0)),
                        nonce: toHex(toBN(details.nonce))
                    }).then(this.responseParser.parseFeeEstimateResponse)
                }
                async getEstimateFeeBulk(invocations, blockIdentifier=this.blockIdentifier) {
                    const params = invocations.map((invocation=>{
                        let res;
                        return res = "INVOKE_FUNCTION" === invocation.type ? {
                            type: invocation.type,
                            contract_address: invocation.contractAddress,
                            calldata: invocation.calldata ?? []
                        } : "DECLARE" === invocation.type ? {
                            type: invocation.type,
                            sender_address: invocation.senderAddress,
                            contract_class: invocation.contractDefinition
                        } : {
                            type: invocation.type,
                            class_hash: toHex(toBN(invocation.classHash)),
                            constructor_calldata: bigNumberishArrayToDecimalStringArray(invocation.constructorCalldata || []),
                            contract_address_salt: toHex(toBN(invocation.addressSalt || 0))
                        },
                        {
                            ...res,
                            signature: bigNumberishArrayToDecimalStringArray(invocation.signature || []),
                            version: toHex(toBN((null == invocation ? void 0 : invocation.version) || 1)),
                            nonce: toHex(toBN(invocation.nonce))
                        }
                    }
                    ));
                    return this.fetchEndpoint("estimate_fee_bulk", {
                        blockIdentifier
                    }, params).then(this.responseParser.parseFeeEstimateBulkResponse)
                }
                async getCode(contractAddress, blockIdentifier=this.blockIdentifier) {
                    return this.fetchEndpoint("get_code", {
                        contractAddress,
                        blockIdentifier
                    })
                }
                async waitForTransaction(txHash, retryInterval=8e3, successStates=["ACCEPTED_ON_L1", "ACCEPTED_ON_L2", "PENDING"]) {
                    const errorStates = ["REJECTED", "NOT_RECEIVED"];
                    let res, onchain = !1;
                    for (; !onchain; )
                        if (await wait(retryInterval),
                        res = await this.getTransactionStatus(txHash),
                        successStates.includes(res.tx_status))
                            onchain = !0;
                        else if (errorStates.includes(res.tx_status)) {
                            const message = res.tx_failure_reason ? `${res.tx_status}: ${res.tx_failure_reason.code}\n${res.tx_failure_reason.error_message}` : res.tx_status
                              , error = new Error(message);
                            throw error.response = res,
                            error
                        }
                    return await this.getTransactionReceipt(txHash)
                }
                async getTransactionStatus(txHash) {
                    const txHashHex = toHex(toBN(txHash));
                    return this.fetchEndpoint("get_transaction_status", {
                        transactionHash: txHashHex
                    })
                }
                async getContractAddresses() {
                    return this.fetchEndpoint("get_contract_addresses")
                }
                async getTransactionTrace(txHash) {
                    const txHashHex = toHex(toBN(txHash));
                    return this.fetchEndpoint("get_transaction_trace", {
                        transactionHash: txHashHex
                    })
                }
                async estimateMessageFee({from_address, to_address, entry_point_selector, payload}, blockIdentifier=this.blockIdentifier) {
                    const validCallL1Handler = {
                        from_address: getDecimalString(from_address),
                        to_address: getHexString(to_address),
                        entry_point_selector: getSelector(entry_point_selector),
                        payload: getHexStringArray(payload)
                    };
                    return this.fetchEndpoint("estimate_message_fee", {
                        blockIdentifier
                    }, validCallL1Handler)
                }
                async getSimulateTransaction(invocation, invocationDetails, blockIdentifier=this.blockIdentifier) {
                    return this.fetchEndpoint("simulate_transaction", {
                        blockIdentifier
                    }, {
                        type: "INVOKE_FUNCTION",
                        contract_address: invocation.contractAddress,
                        calldata: invocation.calldata ?? [],
                        signature: bigNumberishArrayToDecimalStringArray(invocation.signature || []),
                        version: toHex(toBN((null == invocationDetails ? void 0 : invocationDetails.version) || 1)),
                        nonce: toHex(toBN(invocationDetails.nonce))
                    }).then(this.responseParser.parseFeeSimulateTransactionResponse)
                }
                async getStateUpdate(blockIdentifier=this.blockIdentifier) {
                    const args = new Block(blockIdentifier).sequencerIdentifier;
                    return this.fetchEndpoint("get_state_update", {
                        ...args
                    }).then(this.responseParser.parseGetStateUpdateResponse)
                }
                async getBlockTraces(blockIdentifier=this.blockIdentifier) {
                    const args = new Block(blockIdentifier).sequencerIdentifier;
                    return this.fetchEndpoint("get_block_traces", {
                        ...args
                    })
                }
                async getStarkName(address, StarknetIdContract) {
                    return getStarkName(this, address, StarknetIdContract)
                }
                async getAddressFromStarkName(name, StarknetIdContract) {
                    return getAddressFromStarkName(this, name, StarknetIdContract)
                }
            }
              , Provider = class {
                constructor(providerOrOptions) {
                    this.provider = providerOrOptions instanceof Provider ? providerOrOptions.provider : providerOrOptions instanceof RpcProvider || providerOrOptions instanceof SequencerProvider ? providerOrOptions : providerOrOptions && "rpc"in providerOrOptions ? new RpcProvider(providerOrOptions.rpc) : providerOrOptions && "sequencer"in providerOrOptions ? new SequencerProvider(providerOrOptions.sequencer) : new SequencerProvider
                }
                get chainId() {
                    return this.provider.chainId
                }
                async getChainId() {
                    return this.provider.getChainId()
                }
                async getBlock(blockIdentifier) {
                    return this.provider.getBlock(blockIdentifier)
                }
                async getClassAt(contractAddress, blockIdentifier) {
                    return this.provider.getClassAt(contractAddress, blockIdentifier)
                }
                async getClassHashAt(contractAddress, blockIdentifier) {
                    return this.provider.getClassHashAt(contractAddress, blockIdentifier)
                }
                getClassByHash(classHash) {
                    return this.provider.getClassByHash(classHash)
                }
                async getEstimateFee(invocationWithTxType, invocationDetails, blockIdentifier) {
                    return this.provider.getEstimateFee(invocationWithTxType, invocationDetails, blockIdentifier)
                }
                async getInvokeEstimateFee(invocationWithTxType, invocationDetails, blockIdentifier) {
                    return this.provider.getInvokeEstimateFee(invocationWithTxType, invocationDetails, blockIdentifier)
                }
                async getEstimateFeeBulk(invocations, blockIdentifier) {
                    return this.provider.getEstimateFeeBulk(invocations, blockIdentifier)
                }
                async getNonceForAddress(contractAddress, blockIdentifier) {
                    return this.provider.getNonceForAddress(contractAddress, blockIdentifier)
                }
                async getStorageAt(contractAddress, key, blockIdentifier) {
                    return this.provider.getStorageAt(contractAddress, key, blockIdentifier)
                }
                async getTransaction(txHash) {
                    return this.provider.getTransaction(txHash)
                }
                async getTransactionReceipt(txHash) {
                    return this.provider.getTransactionReceipt(txHash)
                }
                async callContract(request, blockIdentifier) {
                    return this.provider.callContract(request, blockIdentifier)
                }
                async invokeFunction(functionInvocation, details) {
                    return this.provider.invokeFunction(functionInvocation, details)
                }
                async deployAccountContract(payload, details) {
                    return this.provider.deployAccountContract(payload, details)
                }
                async declareContract(transaction, details) {
                    return this.provider.declareContract(transaction, details)
                }
                async getDeclareEstimateFee(transaction, details, blockIdentifier) {
                    return this.provider.getDeclareEstimateFee(transaction, details, blockIdentifier)
                }
                getDeployAccountEstimateFee(transaction, details, blockIdentifier) {
                    return this.provider.getDeployAccountEstimateFee(transaction, details, blockIdentifier)
                }
                async getCode(contractAddress, blockIdentifier) {
                    return this.provider.getCode(contractAddress, blockIdentifier)
                }
                async waitForTransaction(txHash, retryInterval, successStates) {
                    return this.provider.waitForTransaction(txHash, retryInterval, successStates)
                }
                async getSimulateTransaction(invocation, invocationDetails, blockIdentifier) {
                    return this.provider.getSimulateTransaction(invocation, invocationDetails, blockIdentifier)
                }
                async getStateUpdate(blockIdentifier) {
                    return this.provider.getStateUpdate(blockIdentifier)
                }
                async getStarkName(address, StarknetIdContract) {
                    return getStarkName(this, address, StarknetIdContract)
                }
                async getAddressFromStarkName(name, StarknetIdContract) {
                    return getAddressFromStarkName(this, name, StarknetIdContract)
                }
            }
              , ProviderInterface = class {
            }
              , defaultProvider = new Provider
              , import_bn5 = __toESM(__webpack_require__(63742))
              , import_minimalistic_assert4 = __toESM(__webpack_require__(79746))
              , CheckCallData = class {
                constructor(abi) {
                    this.abi = abi,
                    this.structs = abi.filter((abiEntry=>"struct" === abiEntry.type)).reduce(((acc,abiEntry)=>({
                        ...acc,
                        [abiEntry.name]: abiEntry
                    })), {})
                }
                compileCalldata(args, inputs) {
                    const argsIterator = args[Symbol.iterator]();
                    return inputs.reduce(((acc,input)=>{
                        if (/_len$/.test(input.name))
                            return acc;
                        const parsedData = this.parseCalldataField(argsIterator, input);
                        return Array.isArray(parsedData) ? acc.push(...parsedData) : acc.push(parsedData),
                        acc
                    }
                    ), [])
                }
                validateMethodAndArgs(type, method, args=[]) {
                    if ("DEPLOY" !== type) {
                        const invocableFunctionNames = this.abi.filter((abi=>{
                            if ("function" !== abi.type)
                                return !1;
                            const isView = "view" === abi.stateMutability;
                            return "INVOKE" === type ? !isView : isView
                        }
                        )).map((abi=>abi.name));
                        (0,
                        import_minimalistic_assert4.default)(invocableFunctionNames.includes(method), ("INVOKE" === type ? "invocable" : "viewable") + " method not found in abi")
                    }
                    const methodAbi = this.abi.find((abi=>"DEPLOY" === type ? abi.name === method && abi.type === method : abi.name === method && "function" === abi.type));
                    let argPosition = 0;
                    methodAbi.inputs.forEach((input=>{
                        if (!/_len$/.test(input.name))
                            if ("felt" === input.type)
                                (0,
                                import_minimalistic_assert4.default)("string" == typeof args[argPosition] || "number" == typeof args[argPosition] || args[argPosition]instanceof import_bn5.default, `arg ${input.name} should be a felt (string, number, BigNumber)`),
                                argPosition += 1;
                            else if (input.type in this.structs && "object" == typeof args[argPosition]) {
                                if (Array.isArray(args[argPosition])) {
                                    const structMembersLength = this.calculateStructMembers(input.type);
                                    (0,
                                    import_minimalistic_assert4.default)(args[argPosition].length === structMembersLength, `arg should be of length ${structMembersLength}`)
                                } else
                                    this.structs[input.type].members.forEach((({name})=>{
                                        (0,
                                        import_minimalistic_assert4.default)(Object.keys(args[argPosition]).includes(name), `arg should have a property ${name}`)
                                    }
                                    ));
                                argPosition += 1
                            } else if ((0,
                            import_minimalistic_assert4.default)(Array.isArray(args[argPosition]), `arg ${input.name} should be an Array`),
                            "felt*" === input.type)
                                args[argPosition].forEach((felt=>{
                                    (0,
                                    import_minimalistic_assert4.default)("string" == typeof felt || "number" == typeof felt || felt instanceof import_bn5.default, `arg ${input.name} should be an array of string, number or BigNumber`)
                                }
                                )),
                                argPosition += 1;
                            else if (/\(felt/.test(input.type)) {
                                const tupleLength = input.type.split(",").length;
                                (0,
                                import_minimalistic_assert4.default)(args[argPosition].length === tupleLength, `arg ${input.name} should have ${tupleLength} elements in tuple`),
                                args[argPosition].forEach((felt=>{
                                    (0,
                                    import_minimalistic_assert4.default)("string" == typeof felt || "number" == typeof felt || felt instanceof import_bn5.default, `arg ${input.name} should be an array of string, number or BigNumber`)
                                }
                                )),
                                argPosition += 1
                            } else {
                                const arrayType = input.type.replace("*", "");
                                args[argPosition].forEach((struct=>{
                                    this.structs[arrayType].members.forEach((({name})=>{
                                        if (Array.isArray(struct)) {
                                            const structMembersLength = this.calculateStructMembers(arrayType);
                                            (0,
                                            import_minimalistic_assert4.default)(struct.length === structMembersLength, `arg should be of length ${structMembersLength}`)
                                        } else
                                            (0,
                                            import_minimalistic_assert4.default)(Object.keys(struct).includes(name), `arg ${input.name} should be an array of ${arrayType}`)
                                    }
                                    ))
                                }
                                )),
                                argPosition += 1
                            }
                    }
                    ))
                }
                parseCalldataField(argsIterator, input) {
                    const {name, type} = input
                      , {value} = argsIterator.next()
                      , parsedCalldata = [];
                    switch (!0) {
                    case /\*/.test(type):
                        if (Array.isArray(value))
                            return parsedCalldata.push(toFelt(value.length)),
                            value.reduce(((acc,el)=>(/felt/.test(type) ? acc.push(toFelt(el)) : acc.push(...this.parseCalldataValue(el, type.replace("*", ""))),
                            acc)), parsedCalldata);
                        throw Error(`Expected ${name} to be array`);
                    case type in this.structs:
                        return this.parseCalldataValue(value, type);
                    case /\(felt/.test(type):
                        if (Array.isArray(value))
                            return value.map((el=>toFelt(el)));
                        throw Error(`Expected ${name} to be array`);
                    default:
                        return toFelt(value)
                    }
                }
                parseCalldataValue(element, type) {
                    if (void 0 === element)
                        throw Error("Missing element in calldata");
                    if (Array.isArray(element)) {
                        const structMemberNum = this.calculateStructMembers(type);
                        if (element.length !== structMemberNum)
                            throw Error("Missing element in calldata");
                        return element.map((el=>toFelt(el)))
                    }
                    return this.structs[type] && this.structs[type].members.length ? this.structs[type].members.reduce(((acc,member)=>{
                        const parsedData = this.parseCalldataValue(element[member.name], member.type);
                        return "string" == typeof parsedData ? acc.push(parsedData) : acc.push(...parsedData),
                        acc
                    }
                    ), []) : toFelt(element)
                }
                calculateStructMembers(struct) {
                    return this.structs[struct].members.reduce(((acc,member)=>"felt" === member.type ? acc + 1 : acc + this.calculateStructMembers(member.type)), 0)
                }
            }
            ;
            function parseFelt(candidate) {
                try {
                    return toBN(candidate)
                } catch (e) {
                    throw Error("Could not parse felt")
                }
            }
            function buildCall(contract, functionAbi) {
                return async function(...args) {
                    let blockIdentifier = null;
                    return args.forEach((arg=>{
                        arg.blockIdentifier && (blockIdentifier = arg.blockIdentifier)
                    }
                    )),
                    contract.call(functionAbi.name, args, {
                        blockIdentifier
                    })
                }
            }
            function buildDefault(contract, functionAbi) {
                return "view" === functionAbi.stateMutability ? buildCall(contract, functionAbi) : function(contract, functionAbi) {
                    return async function(...args) {
                        const {inputs} = functionAbi
                          , options = {};
                        return inputs.reduce(((acc,input)=>/_len$/.test(input.name) ? acc : acc + 1), 0) + 1 === args.length && "object" == typeof args[args.length - 1] && Object.assign(options, args.pop()),
                        contract.invoke(functionAbi.name, args, options)
                    }
                }(contract, functionAbi)
            }
            function buildEstimate(contract, functionAbi) {
                return function(...args) {
                    return contract.estimate(functionAbi.name, args)
                }
            }
            var Contract = class {
                constructor(abi, address, providerOrAccount=defaultProvider) {
                    this.address = address && address.toLowerCase(),
                    this.providerOrAccount = providerOrAccount,
                    this.abi = abi,
                    this.structs = abi.filter((abiEntry=>"struct" === abiEntry.type)).reduce(((acc,abiEntry)=>({
                        ...acc,
                        [abiEntry.name]: abiEntry
                    })), {}),
                    this.checkCalldata = new CheckCallData(abi),
                    Object.defineProperty(this, "functions", {
                        enumerable: !0,
                        value: {},
                        writable: !1
                    }),
                    Object.defineProperty(this, "callStatic", {
                        enumerable: !0,
                        value: {},
                        writable: !1
                    }),
                    Object.defineProperty(this, "populateTransaction", {
                        enumerable: !0,
                        value: {},
                        writable: !1
                    }),
                    Object.defineProperty(this, "estimateFee", {
                        enumerable: !0,
                        value: {},
                        writable: !1
                    }),
                    this.abi.forEach((abiElement=>{
                        if ("function" !== abiElement.type)
                            return;
                        const signature = abiElement.name;
                        var contract, functionAbi;
                        this[signature] || Object.defineProperty(this, signature, {
                            enumerable: !0,
                            value: buildDefault(this, abiElement),
                            writable: !1
                        }),
                        this.functions[signature] || Object.defineProperty(this.functions, signature, {
                            enumerable: !0,
                            value: buildDefault(this, abiElement),
                            writable: !1
                        }),
                        this.callStatic[signature] || Object.defineProperty(this.callStatic, signature, {
                            enumerable: !0,
                            value: buildCall(this, abiElement),
                            writable: !1
                        }),
                        this.populateTransaction[signature] || Object.defineProperty(this.populateTransaction, signature, {
                            enumerable: !0,
                            value: (contract = this,
                            functionAbi = abiElement,
                            function(...args) {
                                return contract.populate(functionAbi.name, args)
                            }
                            ),
                            writable: !1
                        }),
                        this.estimateFee[signature] || Object.defineProperty(this.estimateFee, signature, {
                            enumerable: !0,
                            value: buildEstimate(this, abiElement),
                            writable: !1
                        })
                    }
                    ))
                }
                attach(address) {
                    this.address = address
                }
                connect(providerOrAccount) {
                    this.providerOrAccount = providerOrAccount
                }
                async deployed() {
                    return this.deployTransactionHash && (await this.providerOrAccount.waitForTransaction(this.deployTransactionHash),
                    this.deployTransactionHash = void 0),
                    this
                }
                async call(method, args=[], options={}) {
                    const blockIdentifier = (null == options ? void 0 : options.blockIdentifier) || void 0;
                    (0,
                    import_minimalistic_assert5.default)(null !== this.address, "contract is not connected to an address"),
                    this.checkCalldata.validateMethodAndArgs("CALL", method, args);
                    const {inputs} = this.abi.find((abi=>abi.name === method))
                      , calldata = this.checkCalldata.compileCalldata(args, inputs);
                    return this.providerOrAccount.callContract({
                        contractAddress: this.address,
                        calldata,
                        entrypoint: method
                    }, blockIdentifier).then((x=>this.parseResponse(method, x.result)))
                }
                invoke(method, args=[], options={}) {
                    (0,
                    import_minimalistic_assert5.default)(null !== this.address, "contract is not connected to an address"),
                    this.checkCalldata.validateMethodAndArgs("INVOKE", method, args);
                    const {inputs} = this.abi.find((abi=>abi.name === method))
                      , inputsLength = inputs.reduce(((acc,input)=>/_len$/.test(input.name) ? acc : acc + 1), 0);
                    if (args.length !== inputsLength)
                        throw Error(`Invalid number of arguments, expected ${inputsLength} arguments, but got ${args.length}`);
                    const calldata = this.checkCalldata.compileCalldata(args, inputs)
                      , invocation = {
                        contractAddress: this.address,
                        calldata,
                        entrypoint: method
                    };
                    if ("execute"in this.providerOrAccount)
                        return this.providerOrAccount.execute(invocation, void 0, {
                            maxFee: options.maxFee,
                            nonce: options.nonce
                        });
                    if (!options.nonce)
                        throw new Error("Nonce is required when invoking a function without an account");
                    return this.providerOrAccount.invokeFunction({
                        ...invocation,
                        signature: options.signature || []
                    }, {
                        nonce: options.nonce
                    })
                }
                async estimate(method, args=[]) {
                    (0,
                    import_minimalistic_assert5.default)(null !== this.address, "contract is not connected to an address"),
                    this.checkCalldata.validateMethodAndArgs("INVOKE", method, args);
                    const invocation = this.populateTransaction[method](...args);
                    if ("estimateInvokeFee"in this.providerOrAccount)
                        return this.providerOrAccount.estimateInvokeFee(invocation);
                    throw Error("Contract must be connected to the account contract to estimate")
                }
                populate(method, args=[]) {
                    const {inputs} = this.abi.find((abi=>abi.name === method));
                    return {
                        contractAddress: this.address,
                        entrypoint: method,
                        calldata: this.checkCalldata.compileCalldata(args, inputs)
                    }
                }
                parseResponseStruct(responseIterator, type) {
                    return type in this.structs && this.structs[type] ? this.structs[type].members.reduce(((acc,el)=>(acc[el.name] = this.parseResponseStruct(responseIterator, el.type),
                    acc)), {}) : parseFelt(responseIterator.next().value)
                }
                parseResponseField(responseIterator, output, parsedResult) {
                    const {name, type} = output
                      , parsedDataArr = [];
                    switch (!0) {
                    case /_len$/.test(name):
                        return parseFelt(responseIterator.next().value).toNumber();
                    case /\(felt/.test(type):
                        return type.split(",").reduce((acc=>(acc.push(parseFelt(responseIterator.next().value)),
                        acc)), []);
                    case /\*/.test(type):
                        if (parsedResult && parsedResult[`${name}_len`]) {
                            const arrLen = parsedResult[`${name}_len`];
                            for (; parsedDataArr.length < arrLen; )
                                parsedDataArr.push(this.parseResponseStruct(responseIterator, output.type.replace("*", "")))
                        }
                        return parsedDataArr;
                    case type in this.structs:
                        return this.parseResponseStruct(responseIterator, type);
                    default:
                        return parseFelt(responseIterator.next().value)
                    }
                }
                parseResponse(method, response) {
                    const {outputs} = this.abi.find((abi=>abi.name === method))
                      , responseIterator = response.flat()[Symbol.iterator]()
                      , resultObject = outputs.flat().reduce(((acc,output)=>(acc[output.name] = this.parseResponseField(responseIterator, output, acc),
                    acc[output.name] && acc[`${output.name}_len`] && delete acc[`${output.name}_len`],
                    acc)), {});
                    return Object.entries(resultObject).reduce(((acc,[key,value])=>(acc.push(value),
                    acc[key] = value,
                    acc)), [])
                }
            }
              , ContractInterface = class {
            }
              , import_minimalistic_assert6 = __toESM(__webpack_require__(79746))
              , ContractFactory = class {
                constructor(compiledContract, classHash, account, abi=compiledContract.abi) {
                    this.abi = abi,
                    this.compiledContract = compiledContract,
                    this.account = account,
                    this.classHash = classHash,
                    this.checkCalldata = new CheckCallData(abi)
                }
                async deploy(args=[], addressSalt) {
                    this.checkCalldata.validateMethodAndArgs("DEPLOY", "constructor", args);
                    const {inputs} = this.abi.find((abi=>"constructor" === abi.type))
                      , constructorCalldata = this.checkCalldata.compileCalldata(args, inputs)
                      , {deploy: {contract_address, transaction_hash}} = await this.account.declareDeploy({
                        contract: this.compiledContract,
                        classHash: this.classHash,
                        constructorCalldata,
                        salt: addressSalt
                    });
                    (0,
                    import_minimalistic_assert6.default)(Boolean(contract_address), "Deployment of the contract failed");
                    const contractInstance = new Contract(this.compiledContract.abi,contract_address,this.account);
                    return contractInstance.deployTransactionHash = transaction_hash,
                    contractInstance
                }
                connect(account) {
                    return this.account = account,
                    this
                }
                attach(address) {
                    return new Contract(this.abi,address,this.account)
                }
            }
              , SignerInterface = class {
            }
              , transaction_exports = {};
            __export(transaction_exports, {
                fromCallsToExecuteCalldata: ()=>fromCallsToExecuteCalldata,
                fromCallsToExecuteCalldataWithNonce: ()=>fromCallsToExecuteCalldataWithNonce,
                transformCallsToMulticallArrays: ()=>transformCallsToMulticallArrays
            });
            var transformCallsToMulticallArrays = calls=>{
                const callArray = []
                  , calldata = [];
                return calls.forEach((call=>{
                    const data = call.calldata || [];
                    callArray.push({
                        to: toBN(call.contractAddress).toString(10),
                        selector: toBN(getSelectorFromName(call.entrypoint)).toString(10),
                        data_offset: calldata.length.toString(),
                        data_len: data.length.toString()
                    }),
                    calldata.push(...data)
                }
                )),
                {
                    callArray,
                    calldata: bigNumberishArrayToDecimalStringArray(calldata)
                }
            }
              , fromCallsToExecuteCalldata = calls=>{
                const {callArray, calldata} = transformCallsToMulticallArrays(calls);
                return [callArray.length.toString(), ...callArray.map((({to, selector, data_offset, data_len})=>[to, selector, data_offset, data_len])).flat(), calldata.length.toString(), ...calldata]
            }
              , fromCallsToExecuteCalldataWithNonce = (calls,nonce)=>[...fromCallsToExecuteCalldata(calls), toBN(nonce).toString()]
              , typedData_exports = {};
            __export(typedData_exports, {
                encodeData: ()=>encodeData,
                encodeType: ()=>encodeType,
                encodeValue: ()=>encodeValue,
                getDependencies: ()=>getDependencies,
                getMessageHash: ()=>getMessageHash,
                getStructHash: ()=>getStructHash,
                getTypeHash: ()=>getTypeHash,
                isMerkleTreeType: ()=>isMerkleTreeType,
                prepareSelector: ()=>prepareSelector
            });
            var merkle_exports = {};
            __export(merkle_exports, {
                MerkleTree: ()=>MerkleTree,
                proofMerklePath: ()=>proofMerklePath
            });
            var MerkleTree = class {
                constructor(leafHashes) {
                    this.branches = [],
                    this.leaves = leafHashes,
                    this.root = this.build(leafHashes)
                }
                build(leaves) {
                    if (1 === leaves.length)
                        return leaves[0];
                    leaves.length !== this.leaves.length && this.branches.push(leaves);
                    const newLeaves = [];
                    for (let i = 0; i < leaves.length; i += 2)
                        i + 1 === leaves.length ? newLeaves.push(MerkleTree.hash(leaves[i], "0x0")) : newLeaves.push(MerkleTree.hash(leaves[i], leaves[i + 1]));
                    return this.build(newLeaves)
                }
                static hash(a, b) {
                    const [aSorted,bSorted] = [toBN(a), toBN(b)].sort(((x,y)=>x.gte(y) ? 1 : -1));
                    return pedersen([aSorted, bSorted])
                }
                getProof(leaf, branch=this.leaves, hashPath=[]) {
                    const index = branch.indexOf(leaf);
                    if (-1 === index)
                        throw new Error("leaf not found");
                    if (1 === branch.length)
                        return hashPath;
                    const isLeft = index % 2 == 0
                      , neededBranch = (isLeft ? branch[index + 1] : branch[index - 1]) ?? "0x0"
                      , newHashPath = [...hashPath, neededBranch]
                      , currentBranchLevelIndex = this.leaves.length === branch.length ? -1 : this.branches.findIndex((b=>b.length === branch.length))
                      , nextBranch = this.branches[currentBranchLevelIndex + 1] ?? [this.root];
                    return this.getProof(MerkleTree.hash(isLeft ? leaf : neededBranch, isLeft ? neededBranch : leaf), nextBranch, newHashPath)
                }
            }
            ;
            function proofMerklePath(root, leaf, path) {
                if (0 === path.length)
                    return root === leaf;
                const [next,...rest] = path;
                return proofMerklePath(root, MerkleTree.hash(leaf, next), rest)
            }
            var shortString_exports = {};
            function isASCII(str) {
                return /^[\x00-\x7F]*$/.test(str)
            }
            function isShortString(str) {
                return str.length <= 31
            }
            function isDecimalString(decim) {
                return /^[0-9]*$/i.test(decim)
            }
            function encodeShortString(str) {
                if (!isASCII(str))
                    throw new Error(`${str} is not an ASCII string`);
                if (!isShortString(str))
                    throw new Error(`${str} is too long`);
                return addHexPrefix(str.replace(/./g, (char=>char.charCodeAt(0).toString(16))))
            }
            function decodeShortString(str) {
                if (!isASCII(str))
                    throw new Error(`${str} is not an ASCII string`);
                if (isHex(str))
                    return removeHexPrefix(str).replace(/.{2}/g, (hex=>String.fromCharCode(parseInt(hex, 16))));
                if (isDecimalString(str))
                    return decodeShortString("0X".concat(BigInt(str).toString(16)));
                throw new Error(`${str} is not Hex or decimal`)
            }
            __export(shortString_exports, {
                decodeShortString: ()=>decodeShortString,
                encodeShortString: ()=>encodeShortString,
                isASCII: ()=>isASCII,
                isDecimalString: ()=>isDecimalString,
                isShortString: ()=>isShortString
            });
            function getHex(value) {
                try {
                    return toHex(toBN(value))
                } catch (e) {
                    if ("string" == typeof value)
                        return toHex(toBN(encodeShortString(value)));
                    throw new Error(`Invalid BigNumberish: ${value}`)
                }
            }
            function prepareSelector(selector) {
                return isHex(selector) ? selector : getSelectorFromName(selector)
            }
            function isMerkleTreeType(type) {
                return "merkletree" === type.type
            }
            var getDependencies = (types,type,dependencies=[])=>("*" === type[type.length - 1] && (type = type.slice(0, -1)),
            dependencies.includes(type) ? dependencies : types[type] ? [type, ...types[type].reduce(((previous,t)=>[...previous, ...getDependencies(types, t.type, previous).filter((dependency=>!previous.includes(dependency)))]), [])] : dependencies);
            var encodeType = (types,type)=>{
                const [primary,...dependencies] = getDependencies(types, type);
                return (primary ? [primary, ...dependencies.sort()] : []).map((dependency=>`${dependency}(${types[dependency].map((t=>`${t.name}:${t.type}`))})`)).join("")
            }
              , getTypeHash = (types,type)=>getSelectorFromName(encodeType(types, type))
              , encodeValue = (types,type,data,ctx={})=>{
                if (types[type])
                    return [type, getStructHash(types, type, data)];
                if (Object.keys(types).map((x=>`${x}*`)).includes(type)) {
                    const structHashes = data.map((struct=>getStructHash(types, type.slice(0, -1), struct)));
                    return [type, computeHashOnElements(structHashes)]
                }
                if ("merkletree" === type) {
                    const merkleTreeType = function(types, ctx) {
                        if (ctx.parent && ctx.key) {
                            const merkleType = types[ctx.parent].find((t=>t.name === ctx.key));
                            if (!isMerkleTreeType(merkleType))
                                throw new Error(`${ctx.key} is not a merkle tree`);
                            if (merkleType.contains.endsWith("*"))
                                throw new Error(`Merkle tree contain property must not be an array but was given ${ctx.key}`);
                            return merkleType.contains
                        }
                        return "raw"
                    }(types, ctx)
                      , structHashes = data.map((struct=>encodeValue(types, merkleTreeType, struct)[1]))
                      , {root} = new MerkleTree(structHashes);
                    return ["felt", root]
                }
                return "felt*" === type ? ["felt*", computeHashOnElements(data)] : "selector" === type ? ["felt", prepareSelector(data)] : [type, getHex(data)]
            }
              , encodeData = (types,type,data)=>{
                const [returnTypes,values] = types[type].reduce((([ts,vs],field)=>{
                    if (void 0 === data[field.name] || null === data[field.name])
                        throw new Error(`Cannot encode data: missing data for '${field.name}'`);
                    const value = data[field.name]
                      , [t,encodedValue] = encodeValue(types, field.type, value, {
                        parent: type,
                        key: field.name
                    });
                    return [[...ts, t], [...vs, encodedValue]]
                }
                ), [["felt"], [getTypeHash(types, type)]]);
                return [returnTypes, values]
            }
              , getStructHash = (types,type,data)=>computeHashOnElements(encodeData(types, type, data)[1])
              , getMessageHash = (typedData,account)=>{
                if (!(data=>{
                    const typedData = data;
                    return Boolean(typedData.types && typedData.primaryType && typedData.message)
                }
                )(typedData))
                    throw new Error("Typed data does not match JSON schema");
                return computeHashOnElements([encodeShortString("StarkNet Message"), getStructHash(typedData.types, "StarkNetDomain", typedData.domain), account, getStructHash(typedData.types, typedData.primaryType, typedData.message)])
            }
              , Signer = class {
                constructor(keyPair=genKeyPair()) {
                    this.keyPair = keyPair
                }
                async getPubKey() {
                    return getStarkKey(this.keyPair)
                }
                async signMessage(typedData, accountAddress) {
                    const msgHash = getMessageHash(typedData, accountAddress);
                    return sign(this.keyPair, msgHash)
                }
                async signTransaction(transactions, transactionsDetail, abis) {
                    if (abis && abis.length !== transactions.length)
                        throw new Error("ABI must be provided for each transaction or no transaction");
                    const calldata = fromCallsToExecuteCalldata(transactions)
                      , msgHash = calculateTransactionHash(transactionsDetail.walletAddress, transactionsDetail.version, calldata, transactionsDetail.maxFee, transactionsDetail.chainId, transactionsDetail.nonce);
                    return sign(this.keyPair, msgHash)
                }
                async signDeployAccountTransaction({classHash, contractAddress, constructorCalldata, addressSalt, maxFee, version, chainId, nonce}) {
                    const msgHash = calculateDeployAccountTransactionHash(contractAddress, classHash, constructorCalldata, addressSalt, version, maxFee, chainId, nonce);
                    return sign(this.keyPair, msgHash)
                }
                async signDeclareTransaction({classHash, senderAddress, chainId, maxFee, version, nonce}) {
                    const msgHash = calculateDeclareTransactionHash(classHash, senderAddress, version, maxFee, chainId, nonce);
                    return sign(this.keyPair, msgHash)
                }
            }
            ;
            var Account = class extends Provider {
                constructor(providerOrOptions, address, keyPairOrSigner) {
                    super(providerOrOptions),
                    this.address = address.toLowerCase(),
                    this.signer = "getPubKey"in keyPairOrSigner ? keyPairOrSigner : new Signer(keyPairOrSigner)
                }
                async getNonce(blockIdentifier) {
                    return super.getNonceForAddress(this.address, blockIdentifier)
                }
                async estimateFee(calls, estimateFeeDetails) {
                    return this.estimateInvokeFee(calls, estimateFeeDetails)
                }
                async estimateInvokeFee(calls, {nonce: providedNonce, blockIdentifier}={}) {
                    const transactions = Array.isArray(calls) ? calls : [calls]
                      , nonce = toBN(providedNonce ?? await this.getNonce())
                      , version = toBN(feeTransactionVersion)
                      , chainId = await this.getChainId()
                      , signerDetails = {
                        walletAddress: this.address,
                        nonce,
                        maxFee: ZERO,
                        version,
                        chainId
                    }
                      , invocation = await this.buildInvocation(transactions, signerDetails)
                      , response = await super.getInvokeEstimateFee({
                        ...invocation
                    }, {
                        version,
                        nonce
                    }, blockIdentifier)
                      , suggestedMaxFee = estimatedFeeToMaxFee(response.overall_fee);
                    return {
                        ...response,
                        suggestedMaxFee
                    }
                }
                async estimateDeclareFee({classHash, contract}, {blockIdentifier, nonce: providedNonce}={}) {
                    const nonce = toBN(providedNonce ?? await this.getNonce())
                      , version = toBN(feeTransactionVersion)
                      , chainId = await this.getChainId()
                      , payload = await this.buildDeclarePayload({
                        classHash,
                        contract
                    }, {
                        nonce,
                        chainId,
                        version,
                        walletAddress: this.address,
                        maxFee: ZERO
                    })
                      , response = await super.getDeclareEstimateFee({
                        ...payload
                    }, {
                        version,
                        nonce
                    }, blockIdentifier)
                      , suggestedMaxFee = estimatedFeeToMaxFee(response.overall_fee);
                    return {
                        ...response,
                        suggestedMaxFee
                    }
                }
                async estimateAccountDeployFee({classHash, addressSalt=0, constructorCalldata=[], contractAddress: providedContractAddress}, {blockIdentifier}={}) {
                    const version = toBN(feeTransactionVersion)
                      , chainId = await this.getChainId()
                      , payload = await this.buildAccountDeployPayload({
                        classHash,
                        addressSalt,
                        constructorCalldata,
                        contractAddress: providedContractAddress
                    }, {
                        nonce: "0x0",
                        chainId,
                        version,
                        walletAddress: this.address,
                        maxFee: ZERO
                    })
                      , response = await super.getDeployAccountEstimateFee({
                        ...payload
                    }, {
                        version,
                        nonce: "0x0"
                    }, blockIdentifier)
                      , suggestedMaxFee = estimatedFeeToMaxFee(response.overall_fee);
                    return {
                        ...response,
                        suggestedMaxFee
                    }
                }
                async estimateDeployFee(payload, transactionsDetail) {
                    const calls = this.buildUDCContractPayload(payload);
                    return this.estimateInvokeFee(calls, transactionsDetail)
                }
                async estimateFeeBulk(transactions, {nonce: providedNonce, blockIdentifier}={}) {
                    const nonce = toBN(providedNonce ?? await this.getNonce())
                      , version = toBN(feeTransactionVersion)
                      , chainId = await this.getChainId()
                      , params = await Promise.all([].concat(transactions).map((async(transaction,index)=>{
                        const signerDetails = {
                            walletAddress: this.address,
                            nonce: toBN(Number(nonce) + index),
                            maxFee: ZERO,
                            version,
                            chainId
                        }
                          , txPayload = transaction.payload;
                        let res;
                        if ("object" == typeof transaction && "INVOKE_FUNCTION" === transaction.type) {
                            res = {
                                type: "INVOKE_FUNCTION",
                                ...await this.buildInvocation(Array.isArray(txPayload) ? txPayload : [txPayload], signerDetails),
                                version,
                                nonce: toBN(Number(nonce) + index),
                                blockIdentifier
                            }
                        } else if ("object" == typeof transaction && "DECLARE" === transaction.type) {
                            res = {
                                type: "DECLARE",
                                ...await this.buildDeclarePayload(txPayload, signerDetails),
                                version,
                                nonce: toBN(Number(nonce) + index),
                                blockIdentifier
                            }
                        } else if ("object" == typeof transaction && "DEPLOY_ACCOUNT" === transaction.type) {
                            res = {
                                type: "DEPLOY_ACCOUNT",
                                ...await this.buildAccountDeployPayload(txPayload, signerDetails),
                                version,
                                nonce,
                                blockIdentifier
                            }
                        } else if ("object" == typeof transaction && "DEPLOY" === transaction.type) {
                            const calls = this.buildUDCContractPayload(txPayload);
                            res = {
                                type: "INVOKE_FUNCTION",
                                ...await this.buildInvocation(calls, signerDetails),
                                version,
                                nonce: toBN(Number(nonce) + index),
                                blockIdentifier
                            }
                        }
                        return res
                    }
                    )))
                      , response = await super.getEstimateFeeBulk(params, blockIdentifier);
                    return [].concat(response).map((elem=>{
                        const suggestedMaxFee = estimatedFeeToMaxFee(elem.overall_fee);
                        return {
                            ...elem,
                            suggestedMaxFee
                        }
                    }
                    ))
                }
                async buildInvocation(call, signerDetails) {
                    const calldata = fromCallsToExecuteCalldata(call)
                      , signature = await this.signer.signTransaction(call, signerDetails);
                    return {
                        contractAddress: this.address,
                        calldata,
                        signature
                    }
                }
                async execute(calls, abis=undefined, transactionsDetail={}) {
                    const transactions = Array.isArray(calls) ? calls : [calls]
                      , nonce = toBN(transactionsDetail.nonce ?? await this.getNonce())
                      , maxFee = transactionsDetail.maxFee ?? await this.getSuggestedMaxFee({
                        type: "INVOKE",
                        payload: calls
                    }, transactionsDetail)
                      , version = toBN(transactionVersion)
                      , chainId = await this.getChainId()
                      , signerDetails = {
                        walletAddress: this.address,
                        nonce,
                        maxFee,
                        version,
                        chainId
                    }
                      , signature = await this.signer.signTransaction(transactions, signerDetails, abis)
                      , calldata = fromCallsToExecuteCalldata(transactions);
                    return this.invokeFunction({
                        contractAddress: this.address,
                        calldata,
                        signature
                    }, {
                        nonce,
                        maxFee,
                        version
                    })
                }
                async declare({classHash, contract}, transactionsDetail={}) {
                    const nonce = toBN(transactionsDetail.nonce ?? await this.getNonce())
                      , maxFee = transactionsDetail.maxFee ?? await this.getSuggestedMaxFee({
                        type: "DECLARE",
                        payload: {
                            classHash,
                            contract
                        }
                    }, transactionsDetail)
                      , version = toBN(transactionVersion)
                      , chainId = await this.getChainId()
                      , signature = await this.signer.signDeclareTransaction({
                        classHash,
                        senderAddress: this.address,
                        chainId,
                        maxFee,
                        version,
                        nonce
                    })
                      , contractDefinition = parseContract(contract);
                    return this.declareContract({
                        contractDefinition,
                        senderAddress: this.address,
                        signature
                    }, {
                        nonce,
                        maxFee,
                        version
                    })
                }
                async deploy(payload, details) {
                    const params = [].concat(payload).map((it=>{
                        const {classHash, salt, unique=!0, constructorCalldata=[]} = it
                          , compiledConstructorCallData = compileCalldata(constructorCalldata)
                          , deploySalt = salt ?? randomAddress();
                        return {
                            call: {
                                contractAddress: UDC.ADDRESS,
                                entrypoint: UDC.ENTRYPOINT,
                                calldata: [classHash, deploySalt, toCairoBool(unique), compiledConstructorCallData.length, ...compiledConstructorCallData]
                            },
                            address: calculateContractAddressFromHash(unique ? pedersen([this.address, deploySalt]) : deploySalt, classHash, compiledConstructorCallData, unique ? UDC.ADDRESS : 0)
                        }
                    }
                    ))
                      , calls = params.map((it=>it.call))
                      , addresses = params.map((it=>it.address));
                    return {
                        ...await this.execute(calls, void 0, details),
                        contract_address: addresses
                    }
                }
                async deployContract(payload, details) {
                    const deployTx = await this.deploy(payload, details);
                    return function(txReceipt) {
                        if (!txReceipt.events)
                            throw new Error("UDC emited event is empty");
                        const event = txReceipt.events.find((it=>cleanHex(it.from_address) === cleanHex(UDC.ADDRESS))) || {
                            data: []
                        };
                        return {
                            transaction_hash: txReceipt.transaction_hash,
                            contract_address: event.data[0],
                            address: event.data[0],
                            deployer: event.data[1],
                            unique: event.data[2],
                            classHash: event.data[3],
                            calldata_len: event.data[4],
                            calldata: event.data.slice(5, 5 + parseInt(event.data[4], 16)),
                            salt: event.data[event.data.length - 1]
                        }
                    }(await this.waitForTransaction(deployTx.transaction_hash, void 0, ["ACCEPTED_ON_L2"]))
                }
                async declareDeploy(payload, details) {
                    const {classHash, contract, constructorCalldata, salt, unique} = payload
                      , {transaction_hash} = await this.declare({
                        contract,
                        classHash
                    }, details);
                    return {
                        declare: {
                            ...await this.waitForTransaction(transaction_hash, void 0, ["ACCEPTED_ON_L2"]),
                            class_hash: classHash
                        },
                        deploy: await this.deployContract({
                            classHash,
                            salt,
                            unique,
                            constructorCalldata
                        }, details)
                    }
                }
                async deployAccount({classHash, constructorCalldata=[], addressSalt=0, contractAddress: providedContractAddress}, transactionsDetail={}) {
                    const version = toBN(transactionVersion)
                      , chainId = await this.getChainId()
                      , contractAddress = providedContractAddress ?? calculateContractAddressFromHash(addressSalt, classHash, constructorCalldata, 0)
                      , maxFee = transactionsDetail.maxFee ?? await this.getSuggestedMaxFee({
                        type: "DEPLOY_ACCOUNT",
                        payload: {
                            classHash,
                            constructorCalldata,
                            addressSalt,
                            contractAddress
                        }
                    }, transactionsDetail)
                      , signature = await this.signer.signDeployAccountTransaction({
                        classHash,
                        constructorCalldata,
                        contractAddress,
                        addressSalt,
                        chainId,
                        maxFee,
                        version,
                        nonce: "0x0"
                    });
                    return this.deployAccountContract({
                        classHash,
                        addressSalt,
                        constructorCalldata,
                        signature
                    }, {
                        nonce: "0x0",
                        maxFee,
                        version
                    })
                }
                async signMessage(typedData) {
                    return this.signer.signMessage(typedData, this.address)
                }
                async hashMessage(typedData) {
                    return getMessageHash(typedData, this.address)
                }
                async verifyMessageHash(hash, signature) {
                    try {
                        return await this.callContract({
                            contractAddress: this.address,
                            entrypoint: "isValidSignature",
                            calldata: compileCalldata({
                                hash: toBN(hash).toString(),
                                signature: signature.map((x=>toBN(x).toString()))
                            })
                        }),
                        !0
                    } catch {
                        return !1
                    }
                }
                async verifyMessage(typedData, signature) {
                    const hash = await this.hashMessage(typedData);
                    return this.verifyMessageHash(hash, signature)
                }
                async getSuggestedMaxFee({type, payload}, details) {
                    let feeEstimate;
                    switch (type) {
                    case "INVOKE":
                        feeEstimate = await this.estimateInvokeFee(payload, details);
                        break;
                    case "DECLARE":
                        feeEstimate = await this.estimateDeclareFee(payload, details);
                        break;
                    case "DEPLOY_ACCOUNT":
                        feeEstimate = await this.estimateAccountDeployFee(payload, details);
                        break;
                    case "DEPLOY":
                        feeEstimate = await this.estimateDeployFee(payload, details);
                        break;
                    default:
                        feeEstimate = {
                            suggestedMaxFee: ZERO,
                            overall_fee: ZERO
                        }
                    }
                    return feeEstimate.suggestedMaxFee.toString()
                }
                async buildDeclarePayload({classHash, contract}, {nonce, chainId, version, walletAddress, maxFee}) {
                    const contractDefinition = parseContract(contract);
                    return {
                        senderAddress: walletAddress,
                        signature: await this.signer.signDeclareTransaction({
                            classHash,
                            senderAddress: walletAddress,
                            chainId,
                            maxFee,
                            version,
                            nonce
                        }),
                        contractDefinition
                    }
                }
                async buildAccountDeployPayload({classHash, addressSalt=0, constructorCalldata=[], contractAddress: providedContractAddress}, {nonce, chainId, version, maxFee}) {
                    const contractAddress = providedContractAddress ?? calculateContractAddressFromHash(addressSalt, classHash, constructorCalldata, 0);
                    return {
                        classHash,
                        addressSalt,
                        constructorCalldata,
                        signature: await this.signer.signDeployAccountTransaction({
                            classHash,
                            contractAddress,
                            chainId,
                            maxFee,
                            version,
                            nonce,
                            addressSalt,
                            constructorCalldata
                        })
                    }
                }
                buildUDCContractPayload(payload) {
                    return [].concat(payload).map((it=>{
                        const {classHash, salt="0", unique=!0, constructorCalldata=[]} = it
                          , compiledConstructorCallData = compileCalldata(constructorCalldata);
                        return {
                            contractAddress: UDC.ADDRESS,
                            entrypoint: UDC.ENTRYPOINT,
                            calldata: [classHash, salt, toCairoBool(unique), compiledConstructorCallData.length, ...compiledConstructorCallData]
                        }
                    }
                    ))
                }
                async simulateTransaction(calls, {nonce: providedNonce, blockIdentifier}={}) {
                    const transactions = Array.isArray(calls) ? calls : [calls]
                      , nonce = toBN(providedNonce ?? await this.getNonce())
                      , version = toBN(feeTransactionVersion)
                      , chainId = await this.getChainId()
                      , signerDetails = {
                        walletAddress: this.address,
                        nonce,
                        maxFee: ZERO,
                        version,
                        chainId
                    }
                      , invocation = await this.buildInvocation(transactions, signerDetails)
                      , response = await super.getSimulateTransaction(invocation, {
                        version,
                        nonce
                    }, blockIdentifier)
                      , suggestedMaxFee = estimatedFeeToMaxFee(response.fee_estimation.overall_fee);
                    return {
                        ...response,
                        fee_estimation: {
                            ...response.fee_estimation,
                            suggestedMaxFee
                        }
                    }
                }
                async getStarkName(address=this.address, StarknetIdContract) {
                    return super.getStarkName(address, StarknetIdContract)
                }
            }
              , AccountInterface = class extends ProviderInterface {
            }
              , uint256_exports = {};
            function uint256ToBN(uint256) {
                return toBN(uint256.high).shln(128).add(toBN(uint256.low))
            }
            __export(uint256_exports, {
                UINT_128_MAX: ()=>UINT_128_MAX,
                UINT_256_MAX: ()=>UINT_256_MAX,
                bnToUint256: ()=>bnToUint256,
                isUint256: ()=>isUint256,
                uint256ToBN: ()=>uint256ToBN
            });
            var UINT_128_MAX = toBN(1).shln(128).sub(toBN(1))
              , UINT_256_MAX = toBN(1).shln(256).sub(toBN(1));
            function isUint256(bn) {
                return toBN(bn).lte(UINT_256_MAX)
            }
            function bnToUint256(bignumber) {
                const bn = toBN(bignumber);
                if (!isUint256(bn))
                    throw new Error("Number is too large");
                return {
                    low: addHexPrefix(bn.maskn(128).toString(16)),
                    high: addHexPrefix(bn.shrn(128).toString(16))
                }
            }
            var import_bytes = __webpack_require__(93286);
            function addAddressPadding(address) {
                return addHexPrefix(removeHexPrefix(toHex(toBN(address))).padStart(64, "0"))
            }
            function validateAndParseAddress(address) {
                assertInRange(address, ZERO, MASK_251, "Starknet Address");
                const result = addAddressPadding(address);
                if (!result.match(/^(0x)?[0-9a-fA-F]{64}$/))
                    throw new Error("Invalid Address Format");
                return result
            }
            function getChecksumAddress(address) {
                const chars = removeHexPrefix(validateAndParseAddress(address)).toLowerCase().split("")
                  , hashed = (0,
                import_bytes.arrayify)(keccakBn(address), {
                    hexPad: "left"
                });
                for (let i = 0; i < chars.length; i += 2)
                    hashed[i >> 1] >> 4 >= 8 && (chars[i] = chars[i].toUpperCase()),
                    (15 & hashed[i >> 1]) >= 8 && (chars[i + 1] = chars[i + 1].toUpperCase());
                return addHexPrefix(chars.join(""))
            }
            function validateChecksumAddress(address) {
                return getChecksumAddress(address) === address
            }
        }
        ,
        63742: function(module, __unused_webpack_exports, __webpack_require__) {
            !function(module, exports) {
                "use strict";
                function assert(val, msg) {
                    if (!val)
                        throw new Error(msg || "Assertion failed")
                }
                function inherits(ctor, superCtor) {
                    ctor.super_ = superCtor;
                    var TempCtor = function() {};
                    TempCtor.prototype = superCtor.prototype,
                    ctor.prototype = new TempCtor,
                    ctor.prototype.constructor = ctor
                }
                function BN(number, base, endian) {
                    if (BN.isBN(number))
                        return number;
                    this.negative = 0,
                    this.words = null,
                    this.length = 0,
                    this.red = null,
                    null !== number && ("le" !== base && "be" !== base || (endian = base,
                    base = 10),
                    this._init(number || 0, base || 10, endian || "be"))
                }
                var Buffer;
                "object" == typeof module ? module.exports = BN : exports.BN = BN,
                BN.BN = BN,
                BN.wordSize = 26;
                try {
                    Buffer = "undefined" != typeof window && void 0 !== window.Buffer ? window.Buffer : __webpack_require__(99339).Buffer
                } catch (e) {}
                function parseHex4Bits(string, index) {
                    var c = string.charCodeAt(index);
                    return c >= 48 && c <= 57 ? c - 48 : c >= 65 && c <= 70 ? c - 55 : c >= 97 && c <= 102 ? c - 87 : void assert(!1, "Invalid character in " + string)
                }
                function parseHexByte(string, lowerBound, index) {
                    var r = parseHex4Bits(string, index);
                    return index - 1 >= lowerBound && (r |= parseHex4Bits(string, index - 1) << 4),
                    r
                }
                function parseBase(str, start, end, mul) {
                    for (var r = 0, b = 0, len = Math.min(str.length, end), i = start; i < len; i++) {
                        var c = str.charCodeAt(i) - 48;
                        r *= mul,
                        b = c >= 49 ? c - 49 + 10 : c >= 17 ? c - 17 + 10 : c,
                        assert(c >= 0 && b < mul, "Invalid character"),
                        r += b
                    }
                    return r
                }
                function move(dest, src) {
                    dest.words = src.words,
                    dest.length = src.length,
                    dest.negative = src.negative,
                    dest.red = src.red
                }
                if (BN.isBN = function(num) {
                    return num instanceof BN || null !== num && "object" == typeof num && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words)
                }
                ,
                BN.max = function(left, right) {
                    return left.cmp(right) > 0 ? left : right
                }
                ,
                BN.min = function(left, right) {
                    return left.cmp(right) < 0 ? left : right
                }
                ,
                BN.prototype._init = function(number, base, endian) {
                    if ("number" == typeof number)
                        return this._initNumber(number, base, endian);
                    if ("object" == typeof number)
                        return this._initArray(number, base, endian);
                    "hex" === base && (base = 16),
                    assert(base === (0 | base) && base >= 2 && base <= 36);
                    var start = 0;
                    "-" === (number = number.toString().replace(/\s+/g, ""))[0] && (start++,
                    this.negative = 1),
                    start < number.length && (16 === base ? this._parseHex(number, start, endian) : (this._parseBase(number, base, start),
                    "le" === endian && this._initArray(this.toArray(), base, endian)))
                }
                ,
                BN.prototype._initNumber = function(number, base, endian) {
                    number < 0 && (this.negative = 1,
                    number = -number),
                    number < 67108864 ? (this.words = [67108863 & number],
                    this.length = 1) : number < 4503599627370496 ? (this.words = [67108863 & number, number / 67108864 & 67108863],
                    this.length = 2) : (assert(number < 9007199254740992),
                    this.words = [67108863 & number, number / 67108864 & 67108863, 1],
                    this.length = 3),
                    "le" === endian && this._initArray(this.toArray(), base, endian)
                }
                ,
                BN.prototype._initArray = function(number, base, endian) {
                    if (assert("number" == typeof number.length),
                    number.length <= 0)
                        return this.words = [0],
                        this.length = 1,
                        this;
                    this.length = Math.ceil(number.length / 3),
                    this.words = new Array(this.length);
                    for (var i = 0; i < this.length; i++)
                        this.words[i] = 0;
                    var j, w, off = 0;
                    if ("be" === endian)
                        for (i = number.length - 1,
                        j = 0; i >= 0; i -= 3)
                            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16,
                            this.words[j] |= w << off & 67108863,
                            this.words[j + 1] = w >>> 26 - off & 67108863,
                            (off += 24) >= 26 && (off -= 26,
                            j++);
                    else if ("le" === endian)
                        for (i = 0,
                        j = 0; i < number.length; i += 3)
                            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16,
                            this.words[j] |= w << off & 67108863,
                            this.words[j + 1] = w >>> 26 - off & 67108863,
                            (off += 24) >= 26 && (off -= 26,
                            j++);
                    return this._strip()
                }
                ,
                BN.prototype._parseHex = function(number, start, endian) {
                    this.length = Math.ceil((number.length - start) / 6),
                    this.words = new Array(this.length);
                    for (var i = 0; i < this.length; i++)
                        this.words[i] = 0;
                    var w, off = 0, j = 0;
                    if ("be" === endian)
                        for (i = number.length - 1; i >= start; i -= 2)
                            w = parseHexByte(number, start, i) << off,
                            this.words[j] |= 67108863 & w,
                            off >= 18 ? (off -= 18,
                            j += 1,
                            this.words[j] |= w >>> 26) : off += 8;
                    else
                        for (i = (number.length - start) % 2 == 0 ? start + 1 : start; i < number.length; i += 2)
                            w = parseHexByte(number, start, i) << off,
                            this.words[j] |= 67108863 & w,
                            off >= 18 ? (off -= 18,
                            j += 1,
                            this.words[j] |= w >>> 26) : off += 8;
                    this._strip()
                }
                ,
                BN.prototype._parseBase = function(number, base, start) {
                    this.words = [0],
                    this.length = 1;
                    for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base)
                        limbLen++;
                    limbLen--,
                    limbPow = limbPow / base | 0;
                    for (var total = number.length - start, mod = total % limbLen, end = Math.min(total, total - mod) + start, word = 0, i = start; i < end; i += limbLen)
                        word = parseBase(number, i, i + limbLen, base),
                        this.imuln(limbPow),
                        this.words[0] + word < 67108864 ? this.words[0] += word : this._iaddn(word);
                    if (0 !== mod) {
                        var pow = 1;
                        for (word = parseBase(number, i, number.length, base),
                        i = 0; i < mod; i++)
                            pow *= base;
                        this.imuln(pow),
                        this.words[0] + word < 67108864 ? this.words[0] += word : this._iaddn(word)
                    }
                    this._strip()
                }
                ,
                BN.prototype.copy = function(dest) {
                    dest.words = new Array(this.length);
                    for (var i = 0; i < this.length; i++)
                        dest.words[i] = this.words[i];
                    dest.length = this.length,
                    dest.negative = this.negative,
                    dest.red = this.red
                }
                ,
                BN.prototype._move = function(dest) {
                    move(dest, this)
                }
                ,
                BN.prototype.clone = function() {
                    var r = new BN(null);
                    return this.copy(r),
                    r
                }
                ,
                BN.prototype._expand = function(size) {
                    for (; this.length < size; )
                        this.words[this.length++] = 0;
                    return this
                }
                ,
                BN.prototype._strip = function() {
                    for (; this.length > 1 && 0 === this.words[this.length - 1]; )
                        this.length--;
                    return this._normSign()
                }
                ,
                BN.prototype._normSign = function() {
                    return 1 === this.length && 0 === this.words[0] && (this.negative = 0),
                    this
                }
                ,
                "undefined" != typeof Symbol && "function" == typeof Symbol.for)
                    try {
                        BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect
                    } catch (e) {
                        BN.prototype.inspect = inspect
                    }
                else
                    BN.prototype.inspect = inspect;
                function inspect() {
                    return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
                }
                var zeros = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"]
                  , groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
                  , groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
                BN.prototype.toString = function(base, padding) {
                    var out;
                    if (padding = 0 | padding || 1,
                    16 === (base = base || 10) || "hex" === base) {
                        out = "";
                        for (var off = 0, carry = 0, i = 0; i < this.length; i++) {
                            var w = this.words[i]
                              , word = (16777215 & (w << off | carry)).toString(16);
                            carry = w >>> 24 - off & 16777215,
                            (off += 2) >= 26 && (off -= 26,
                            i--),
                            out = 0 !== carry || i !== this.length - 1 ? zeros[6 - word.length] + word + out : word + out
                        }
                        for (0 !== carry && (out = carry.toString(16) + out); out.length % padding != 0; )
                            out = "0" + out;
                        return 0 !== this.negative && (out = "-" + out),
                        out
                    }
                    if (base === (0 | base) && base >= 2 && base <= 36) {
                        var groupSize = groupSizes[base]
                          , groupBase = groupBases[base];
                        out = "";
                        var c = this.clone();
                        for (c.negative = 0; !c.isZero(); ) {
                            var r = c.modrn(groupBase).toString(base);
                            out = (c = c.idivn(groupBase)).isZero() ? r + out : zeros[groupSize - r.length] + r + out
                        }
                        for (this.isZero() && (out = "0" + out); out.length % padding != 0; )
                            out = "0" + out;
                        return 0 !== this.negative && (out = "-" + out),
                        out
                    }
                    assert(!1, "Base should be between 2 and 36")
                }
                ,
                BN.prototype.toNumber = function() {
                    var ret = this.words[0];
                    return 2 === this.length ? ret += 67108864 * this.words[1] : 3 === this.length && 1 === this.words[2] ? ret += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && assert(!1, "Number can only safely store up to 53 bits"),
                    0 !== this.negative ? -ret : ret
                }
                ,
                BN.prototype.toJSON = function() {
                    return this.toString(16, 2)
                }
                ,
                Buffer && (BN.prototype.toBuffer = function(endian, length) {
                    return this.toArrayLike(Buffer, endian, length)
                }
                ),
                BN.prototype.toArray = function(endian, length) {
                    return this.toArrayLike(Array, endian, length)
                }
                ;
                function smallMulTo(self, num, out) {
                    out.negative = num.negative ^ self.negative;
                    var len = self.length + num.length | 0;
                    out.length = len,
                    len = len - 1 | 0;
                    var a = 0 | self.words[0]
                      , b = 0 | num.words[0]
                      , r = a * b
                      , lo = 67108863 & r
                      , carry = r / 67108864 | 0;
                    out.words[0] = lo;
                    for (var k = 1; k < len; k++) {
                        for (var ncarry = carry >>> 26, rword = 67108863 & carry, maxJ = Math.min(k, num.length - 1), j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
                            var i = k - j | 0;
                            ncarry += (r = (a = 0 | self.words[i]) * (b = 0 | num.words[j]) + rword) / 67108864 | 0,
                            rword = 67108863 & r
                        }
                        out.words[k] = 0 | rword,
                        carry = 0 | ncarry
                    }
                    return 0 !== carry ? out.words[k] = 0 | carry : out.length--,
                    out._strip()
                }
                BN.prototype.toArrayLike = function(ArrayType, endian, length) {
                    this._strip();
                    var byteLength = this.byteLength()
                      , reqLength = length || Math.max(1, byteLength);
                    assert(byteLength <= reqLength, "byte array longer than desired length"),
                    assert(reqLength > 0, "Requested array length <= 0");
                    var res = function(ArrayType, size) {
                        return ArrayType.allocUnsafe ? ArrayType.allocUnsafe(size) : new ArrayType(size)
                    }(ArrayType, reqLength);
                    return this["_toArrayLike" + ("le" === endian ? "LE" : "BE")](res, byteLength),
                    res
                }
                ,
                BN.prototype._toArrayLikeLE = function(res, byteLength) {
                    for (var position = 0, carry = 0, i = 0, shift = 0; i < this.length; i++) {
                        var word = this.words[i] << shift | carry;
                        res[position++] = 255 & word,
                        position < res.length && (res[position++] = word >> 8 & 255),
                        position < res.length && (res[position++] = word >> 16 & 255),
                        6 === shift ? (position < res.length && (res[position++] = word >> 24 & 255),
                        carry = 0,
                        shift = 0) : (carry = word >>> 24,
                        shift += 2)
                    }
                    if (position < res.length)
                        for (res[position++] = carry; position < res.length; )
                            res[position++] = 0
                }
                ,
                BN.prototype._toArrayLikeBE = function(res, byteLength) {
                    for (var position = res.length - 1, carry = 0, i = 0, shift = 0; i < this.length; i++) {
                        var word = this.words[i] << shift | carry;
                        res[position--] = 255 & word,
                        position >= 0 && (res[position--] = word >> 8 & 255),
                        position >= 0 && (res[position--] = word >> 16 & 255),
                        6 === shift ? (position >= 0 && (res[position--] = word >> 24 & 255),
                        carry = 0,
                        shift = 0) : (carry = word >>> 24,
                        shift += 2)
                    }
                    if (position >= 0)
                        for (res[position--] = carry; position >= 0; )
                            res[position--] = 0
                }
                ,
                Math.clz32 ? BN.prototype._countBits = function(w) {
                    return 32 - Math.clz32(w)
                }
                : BN.prototype._countBits = function(w) {
                    var t = w
                      , r = 0;
                    return t >= 4096 && (r += 13,
                    t >>>= 13),
                    t >= 64 && (r += 7,
                    t >>>= 7),
                    t >= 8 && (r += 4,
                    t >>>= 4),
                    t >= 2 && (r += 2,
                    t >>>= 2),
                    r + t
                }
                ,
                BN.prototype._zeroBits = function(w) {
                    if (0 === w)
                        return 26;
                    var t = w
                      , r = 0;
                    return 0 == (8191 & t) && (r += 13,
                    t >>>= 13),
                    0 == (127 & t) && (r += 7,
                    t >>>= 7),
                    0 == (15 & t) && (r += 4,
                    t >>>= 4),
                    0 == (3 & t) && (r += 2,
                    t >>>= 2),
                    0 == (1 & t) && r++,
                    r
                }
                ,
                BN.prototype.bitLength = function() {
                    var w = this.words[this.length - 1]
                      , hi = this._countBits(w);
                    return 26 * (this.length - 1) + hi
                }
                ,
                BN.prototype.zeroBits = function() {
                    if (this.isZero())
                        return 0;
                    for (var r = 0, i = 0; i < this.length; i++) {
                        var b = this._zeroBits(this.words[i]);
                        if (r += b,
                        26 !== b)
                            break
                    }
                    return r
                }
                ,
                BN.prototype.byteLength = function() {
                    return Math.ceil(this.bitLength() / 8)
                }
                ,
                BN.prototype.toTwos = function(width) {
                    return 0 !== this.negative ? this.abs().inotn(width).iaddn(1) : this.clone()
                }
                ,
                BN.prototype.fromTwos = function(width) {
                    return this.testn(width - 1) ? this.notn(width).iaddn(1).ineg() : this.clone()
                }
                ,
                BN.prototype.isNeg = function() {
                    return 0 !== this.negative
                }
                ,
                BN.prototype.neg = function() {
                    return this.clone().ineg()
                }
                ,
                BN.prototype.ineg = function() {
                    return this.isZero() || (this.negative ^= 1),
                    this
                }
                ,
                BN.prototype.iuor = function(num) {
                    for (; this.length < num.length; )
                        this.words[this.length++] = 0;
                    for (var i = 0; i < num.length; i++)
                        this.words[i] = this.words[i] | num.words[i];
                    return this._strip()
                }
                ,
                BN.prototype.ior = function(num) {
                    return assert(0 == (this.negative | num.negative)),
                    this.iuor(num)
                }
                ,
                BN.prototype.or = function(num) {
                    return this.length > num.length ? this.clone().ior(num) : num.clone().ior(this)
                }
                ,
                BN.prototype.uor = function(num) {
                    return this.length > num.length ? this.clone().iuor(num) : num.clone().iuor(this)
                }
                ,
                BN.prototype.iuand = function(num) {
                    var b;
                    b = this.length > num.length ? num : this;
                    for (var i = 0; i < b.length; i++)
                        this.words[i] = this.words[i] & num.words[i];
                    return this.length = b.length,
                    this._strip()
                }
                ,
                BN.prototype.iand = function(num) {
                    return assert(0 == (this.negative | num.negative)),
                    this.iuand(num)
                }
                ,
                BN.prototype.and = function(num) {
                    return this.length > num.length ? this.clone().iand(num) : num.clone().iand(this)
                }
                ,
                BN.prototype.uand = function(num) {
                    return this.length > num.length ? this.clone().iuand(num) : num.clone().iuand(this)
                }
                ,
                BN.prototype.iuxor = function(num) {
                    var a, b;
                    this.length > num.length ? (a = this,
                    b = num) : (a = num,
                    b = this);
                    for (var i = 0; i < b.length; i++)
                        this.words[i] = a.words[i] ^ b.words[i];
                    if (this !== a)
                        for (; i < a.length; i++)
                            this.words[i] = a.words[i];
                    return this.length = a.length,
                    this._strip()
                }
                ,
                BN.prototype.ixor = function(num) {
                    return assert(0 == (this.negative | num.negative)),
                    this.iuxor(num)
                }
                ,
                BN.prototype.xor = function(num) {
                    return this.length > num.length ? this.clone().ixor(num) : num.clone().ixor(this)
                }
                ,
                BN.prototype.uxor = function(num) {
                    return this.length > num.length ? this.clone().iuxor(num) : num.clone().iuxor(this)
                }
                ,
                BN.prototype.inotn = function(width) {
                    assert("number" == typeof width && width >= 0);
                    var bytesNeeded = 0 | Math.ceil(width / 26)
                      , bitsLeft = width % 26;
                    this._expand(bytesNeeded),
                    bitsLeft > 0 && bytesNeeded--;
                    for (var i = 0; i < bytesNeeded; i++)
                        this.words[i] = 67108863 & ~this.words[i];
                    return bitsLeft > 0 && (this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft),
                    this._strip()
                }
                ,
                BN.prototype.notn = function(width) {
                    return this.clone().inotn(width)
                }
                ,
                BN.prototype.setn = function(bit, val) {
                    assert("number" == typeof bit && bit >= 0);
                    var off = bit / 26 | 0
                      , wbit = bit % 26;
                    return this._expand(off + 1),
                    this.words[off] = val ? this.words[off] | 1 << wbit : this.words[off] & ~(1 << wbit),
                    this._strip()
                }
                ,
                BN.prototype.iadd = function(num) {
                    var r, a, b;
                    if (0 !== this.negative && 0 === num.negative)
                        return this.negative = 0,
                        r = this.isub(num),
                        this.negative ^= 1,
                        this._normSign();
                    if (0 === this.negative && 0 !== num.negative)
                        return num.negative = 0,
                        r = this.isub(num),
                        num.negative = 1,
                        r._normSign();
                    this.length > num.length ? (a = this,
                    b = num) : (a = num,
                    b = this);
                    for (var carry = 0, i = 0; i < b.length; i++)
                        r = (0 | a.words[i]) + (0 | b.words[i]) + carry,
                        this.words[i] = 67108863 & r,
                        carry = r >>> 26;
                    for (; 0 !== carry && i < a.length; i++)
                        r = (0 | a.words[i]) + carry,
                        this.words[i] = 67108863 & r,
                        carry = r >>> 26;
                    if (this.length = a.length,
                    0 !== carry)
                        this.words[this.length] = carry,
                        this.length++;
                    else if (a !== this)
                        for (; i < a.length; i++)
                            this.words[i] = a.words[i];
                    return this
                }
                ,
                BN.prototype.add = function(num) {
                    var res;
                    return 0 !== num.negative && 0 === this.negative ? (num.negative = 0,
                    res = this.sub(num),
                    num.negative ^= 1,
                    res) : 0 === num.negative && 0 !== this.negative ? (this.negative = 0,
                    res = num.sub(this),
                    this.negative = 1,
                    res) : this.length > num.length ? this.clone().iadd(num) : num.clone().iadd(this)
                }
                ,
                BN.prototype.isub = function(num) {
                    if (0 !== num.negative) {
                        num.negative = 0;
                        var r = this.iadd(num);
                        return num.negative = 1,
                        r._normSign()
                    }
                    if (0 !== this.negative)
                        return this.negative = 0,
                        this.iadd(num),
                        this.negative = 1,
                        this._normSign();
                    var a, b, cmp = this.cmp(num);
                    if (0 === cmp)
                        return this.negative = 0,
                        this.length = 1,
                        this.words[0] = 0,
                        this;
                    cmp > 0 ? (a = this,
                    b = num) : (a = num,
                    b = this);
                    for (var carry = 0, i = 0; i < b.length; i++)
                        carry = (r = (0 | a.words[i]) - (0 | b.words[i]) + carry) >> 26,
                        this.words[i] = 67108863 & r;
                    for (; 0 !== carry && i < a.length; i++)
                        carry = (r = (0 | a.words[i]) + carry) >> 26,
                        this.words[i] = 67108863 & r;
                    if (0 === carry && i < a.length && a !== this)
                        for (; i < a.length; i++)
                            this.words[i] = a.words[i];
                    return this.length = Math.max(this.length, i),
                    a !== this && (this.negative = 1),
                    this._strip()
                }
                ,
                BN.prototype.sub = function(num) {
                    return this.clone().isub(num)
                }
                ;
                var comb10MulTo = function(self, num, out) {
                    var lo, mid, hi, a = self.words, b = num.words, o = out.words, c = 0, a0 = 0 | a[0], al0 = 8191 & a0, ah0 = a0 >>> 13, a1 = 0 | a[1], al1 = 8191 & a1, ah1 = a1 >>> 13, a2 = 0 | a[2], al2 = 8191 & a2, ah2 = a2 >>> 13, a3 = 0 | a[3], al3 = 8191 & a3, ah3 = a3 >>> 13, a4 = 0 | a[4], al4 = 8191 & a4, ah4 = a4 >>> 13, a5 = 0 | a[5], al5 = 8191 & a5, ah5 = a5 >>> 13, a6 = 0 | a[6], al6 = 8191 & a6, ah6 = a6 >>> 13, a7 = 0 | a[7], al7 = 8191 & a7, ah7 = a7 >>> 13, a8 = 0 | a[8], al8 = 8191 & a8, ah8 = a8 >>> 13, a9 = 0 | a[9], al9 = 8191 & a9, ah9 = a9 >>> 13, b0 = 0 | b[0], bl0 = 8191 & b0, bh0 = b0 >>> 13, b1 = 0 | b[1], bl1 = 8191 & b1, bh1 = b1 >>> 13, b2 = 0 | b[2], bl2 = 8191 & b2, bh2 = b2 >>> 13, b3 = 0 | b[3], bl3 = 8191 & b3, bh3 = b3 >>> 13, b4 = 0 | b[4], bl4 = 8191 & b4, bh4 = b4 >>> 13, b5 = 0 | b[5], bl5 = 8191 & b5, bh5 = b5 >>> 13, b6 = 0 | b[6], bl6 = 8191 & b6, bh6 = b6 >>> 13, b7 = 0 | b[7], bl7 = 8191 & b7, bh7 = b7 >>> 13, b8 = 0 | b[8], bl8 = 8191 & b8, bh8 = b8 >>> 13, b9 = 0 | b[9], bl9 = 8191 & b9, bh9 = b9 >>> 13;
                    out.negative = self.negative ^ num.negative,
                    out.length = 19;
                    var w0 = (c + (lo = Math.imul(al0, bl0)) | 0) + ((8191 & (mid = (mid = Math.imul(al0, bh0)) + Math.imul(ah0, bl0) | 0)) << 13) | 0;
                    c = ((hi = Math.imul(ah0, bh0)) + (mid >>> 13) | 0) + (w0 >>> 26) | 0,
                    w0 &= 67108863,
                    lo = Math.imul(al1, bl0),
                    mid = (mid = Math.imul(al1, bh0)) + Math.imul(ah1, bl0) | 0,
                    hi = Math.imul(ah1, bh0);
                    var w1 = (c + (lo = lo + Math.imul(al0, bl1) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al0, bh1) | 0) + Math.imul(ah0, bl1) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah0, bh1) | 0) + (mid >>> 13) | 0) + (w1 >>> 26) | 0,
                    w1 &= 67108863,
                    lo = Math.imul(al2, bl0),
                    mid = (mid = Math.imul(al2, bh0)) + Math.imul(ah2, bl0) | 0,
                    hi = Math.imul(ah2, bh0),
                    lo = lo + Math.imul(al1, bl1) | 0,
                    mid = (mid = mid + Math.imul(al1, bh1) | 0) + Math.imul(ah1, bl1) | 0,
                    hi = hi + Math.imul(ah1, bh1) | 0;
                    var w2 = (c + (lo = lo + Math.imul(al0, bl2) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al0, bh2) | 0) + Math.imul(ah0, bl2) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah0, bh2) | 0) + (mid >>> 13) | 0) + (w2 >>> 26) | 0,
                    w2 &= 67108863,
                    lo = Math.imul(al3, bl0),
                    mid = (mid = Math.imul(al3, bh0)) + Math.imul(ah3, bl0) | 0,
                    hi = Math.imul(ah3, bh0),
                    lo = lo + Math.imul(al2, bl1) | 0,
                    mid = (mid = mid + Math.imul(al2, bh1) | 0) + Math.imul(ah2, bl1) | 0,
                    hi = hi + Math.imul(ah2, bh1) | 0,
                    lo = lo + Math.imul(al1, bl2) | 0,
                    mid = (mid = mid + Math.imul(al1, bh2) | 0) + Math.imul(ah1, bl2) | 0,
                    hi = hi + Math.imul(ah1, bh2) | 0;
                    var w3 = (c + (lo = lo + Math.imul(al0, bl3) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al0, bh3) | 0) + Math.imul(ah0, bl3) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah0, bh3) | 0) + (mid >>> 13) | 0) + (w3 >>> 26) | 0,
                    w3 &= 67108863,
                    lo = Math.imul(al4, bl0),
                    mid = (mid = Math.imul(al4, bh0)) + Math.imul(ah4, bl0) | 0,
                    hi = Math.imul(ah4, bh0),
                    lo = lo + Math.imul(al3, bl1) | 0,
                    mid = (mid = mid + Math.imul(al3, bh1) | 0) + Math.imul(ah3, bl1) | 0,
                    hi = hi + Math.imul(ah3, bh1) | 0,
                    lo = lo + Math.imul(al2, bl2) | 0,
                    mid = (mid = mid + Math.imul(al2, bh2) | 0) + Math.imul(ah2, bl2) | 0,
                    hi = hi + Math.imul(ah2, bh2) | 0,
                    lo = lo + Math.imul(al1, bl3) | 0,
                    mid = (mid = mid + Math.imul(al1, bh3) | 0) + Math.imul(ah1, bl3) | 0,
                    hi = hi + Math.imul(ah1, bh3) | 0;
                    var w4 = (c + (lo = lo + Math.imul(al0, bl4) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al0, bh4) | 0) + Math.imul(ah0, bl4) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah0, bh4) | 0) + (mid >>> 13) | 0) + (w4 >>> 26) | 0,
                    w4 &= 67108863,
                    lo = Math.imul(al5, bl0),
                    mid = (mid = Math.imul(al5, bh0)) + Math.imul(ah5, bl0) | 0,
                    hi = Math.imul(ah5, bh0),
                    lo = lo + Math.imul(al4, bl1) | 0,
                    mid = (mid = mid + Math.imul(al4, bh1) | 0) + Math.imul(ah4, bl1) | 0,
                    hi = hi + Math.imul(ah4, bh1) | 0,
                    lo = lo + Math.imul(al3, bl2) | 0,
                    mid = (mid = mid + Math.imul(al3, bh2) | 0) + Math.imul(ah3, bl2) | 0,
                    hi = hi + Math.imul(ah3, bh2) | 0,
                    lo = lo + Math.imul(al2, bl3) | 0,
                    mid = (mid = mid + Math.imul(al2, bh3) | 0) + Math.imul(ah2, bl3) | 0,
                    hi = hi + Math.imul(ah2, bh3) | 0,
                    lo = lo + Math.imul(al1, bl4) | 0,
                    mid = (mid = mid + Math.imul(al1, bh4) | 0) + Math.imul(ah1, bl4) | 0,
                    hi = hi + Math.imul(ah1, bh4) | 0;
                    var w5 = (c + (lo = lo + Math.imul(al0, bl5) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al0, bh5) | 0) + Math.imul(ah0, bl5) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah0, bh5) | 0) + (mid >>> 13) | 0) + (w5 >>> 26) | 0,
                    w5 &= 67108863,
                    lo = Math.imul(al6, bl0),
                    mid = (mid = Math.imul(al6, bh0)) + Math.imul(ah6, bl0) | 0,
                    hi = Math.imul(ah6, bh0),
                    lo = lo + Math.imul(al5, bl1) | 0,
                    mid = (mid = mid + Math.imul(al5, bh1) | 0) + Math.imul(ah5, bl1) | 0,
                    hi = hi + Math.imul(ah5, bh1) | 0,
                    lo = lo + Math.imul(al4, bl2) | 0,
                    mid = (mid = mid + Math.imul(al4, bh2) | 0) + Math.imul(ah4, bl2) | 0,
                    hi = hi + Math.imul(ah4, bh2) | 0,
                    lo = lo + Math.imul(al3, bl3) | 0,
                    mid = (mid = mid + Math.imul(al3, bh3) | 0) + Math.imul(ah3, bl3) | 0,
                    hi = hi + Math.imul(ah3, bh3) | 0,
                    lo = lo + Math.imul(al2, bl4) | 0,
                    mid = (mid = mid + Math.imul(al2, bh4) | 0) + Math.imul(ah2, bl4) | 0,
                    hi = hi + Math.imul(ah2, bh4) | 0,
                    lo = lo + Math.imul(al1, bl5) | 0,
                    mid = (mid = mid + Math.imul(al1, bh5) | 0) + Math.imul(ah1, bl5) | 0,
                    hi = hi + Math.imul(ah1, bh5) | 0;
                    var w6 = (c + (lo = lo + Math.imul(al0, bl6) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al0, bh6) | 0) + Math.imul(ah0, bl6) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah0, bh6) | 0) + (mid >>> 13) | 0) + (w6 >>> 26) | 0,
                    w6 &= 67108863,
                    lo = Math.imul(al7, bl0),
                    mid = (mid = Math.imul(al7, bh0)) + Math.imul(ah7, bl0) | 0,
                    hi = Math.imul(ah7, bh0),
                    lo = lo + Math.imul(al6, bl1) | 0,
                    mid = (mid = mid + Math.imul(al6, bh1) | 0) + Math.imul(ah6, bl1) | 0,
                    hi = hi + Math.imul(ah6, bh1) | 0,
                    lo = lo + Math.imul(al5, bl2) | 0,
                    mid = (mid = mid + Math.imul(al5, bh2) | 0) + Math.imul(ah5, bl2) | 0,
                    hi = hi + Math.imul(ah5, bh2) | 0,
                    lo = lo + Math.imul(al4, bl3) | 0,
                    mid = (mid = mid + Math.imul(al4, bh3) | 0) + Math.imul(ah4, bl3) | 0,
                    hi = hi + Math.imul(ah4, bh3) | 0,
                    lo = lo + Math.imul(al3, bl4) | 0,
                    mid = (mid = mid + Math.imul(al3, bh4) | 0) + Math.imul(ah3, bl4) | 0,
                    hi = hi + Math.imul(ah3, bh4) | 0,
                    lo = lo + Math.imul(al2, bl5) | 0,
                    mid = (mid = mid + Math.imul(al2, bh5) | 0) + Math.imul(ah2, bl5) | 0,
                    hi = hi + Math.imul(ah2, bh5) | 0,
                    lo = lo + Math.imul(al1, bl6) | 0,
                    mid = (mid = mid + Math.imul(al1, bh6) | 0) + Math.imul(ah1, bl6) | 0,
                    hi = hi + Math.imul(ah1, bh6) | 0;
                    var w7 = (c + (lo = lo + Math.imul(al0, bl7) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al0, bh7) | 0) + Math.imul(ah0, bl7) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah0, bh7) | 0) + (mid >>> 13) | 0) + (w7 >>> 26) | 0,
                    w7 &= 67108863,
                    lo = Math.imul(al8, bl0),
                    mid = (mid = Math.imul(al8, bh0)) + Math.imul(ah8, bl0) | 0,
                    hi = Math.imul(ah8, bh0),
                    lo = lo + Math.imul(al7, bl1) | 0,
                    mid = (mid = mid + Math.imul(al7, bh1) | 0) + Math.imul(ah7, bl1) | 0,
                    hi = hi + Math.imul(ah7, bh1) | 0,
                    lo = lo + Math.imul(al6, bl2) | 0,
                    mid = (mid = mid + Math.imul(al6, bh2) | 0) + Math.imul(ah6, bl2) | 0,
                    hi = hi + Math.imul(ah6, bh2) | 0,
                    lo = lo + Math.imul(al5, bl3) | 0,
                    mid = (mid = mid + Math.imul(al5, bh3) | 0) + Math.imul(ah5, bl3) | 0,
                    hi = hi + Math.imul(ah5, bh3) | 0,
                    lo = lo + Math.imul(al4, bl4) | 0,
                    mid = (mid = mid + Math.imul(al4, bh4) | 0) + Math.imul(ah4, bl4) | 0,
                    hi = hi + Math.imul(ah4, bh4) | 0,
                    lo = lo + Math.imul(al3, bl5) | 0,
                    mid = (mid = mid + Math.imul(al3, bh5) | 0) + Math.imul(ah3, bl5) | 0,
                    hi = hi + Math.imul(ah3, bh5) | 0,
                    lo = lo + Math.imul(al2, bl6) | 0,
                    mid = (mid = mid + Math.imul(al2, bh6) | 0) + Math.imul(ah2, bl6) | 0,
                    hi = hi + Math.imul(ah2, bh6) | 0,
                    lo = lo + Math.imul(al1, bl7) | 0,
                    mid = (mid = mid + Math.imul(al1, bh7) | 0) + Math.imul(ah1, bl7) | 0,
                    hi = hi + Math.imul(ah1, bh7) | 0;
                    var w8 = (c + (lo = lo + Math.imul(al0, bl8) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al0, bh8) | 0) + Math.imul(ah0, bl8) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah0, bh8) | 0) + (mid >>> 13) | 0) + (w8 >>> 26) | 0,
                    w8 &= 67108863,
                    lo = Math.imul(al9, bl0),
                    mid = (mid = Math.imul(al9, bh0)) + Math.imul(ah9, bl0) | 0,
                    hi = Math.imul(ah9, bh0),
                    lo = lo + Math.imul(al8, bl1) | 0,
                    mid = (mid = mid + Math.imul(al8, bh1) | 0) + Math.imul(ah8, bl1) | 0,
                    hi = hi + Math.imul(ah8, bh1) | 0,
                    lo = lo + Math.imul(al7, bl2) | 0,
                    mid = (mid = mid + Math.imul(al7, bh2) | 0) + Math.imul(ah7, bl2) | 0,
                    hi = hi + Math.imul(ah7, bh2) | 0,
                    lo = lo + Math.imul(al6, bl3) | 0,
                    mid = (mid = mid + Math.imul(al6, bh3) | 0) + Math.imul(ah6, bl3) | 0,
                    hi = hi + Math.imul(ah6, bh3) | 0,
                    lo = lo + Math.imul(al5, bl4) | 0,
                    mid = (mid = mid + Math.imul(al5, bh4) | 0) + Math.imul(ah5, bl4) | 0,
                    hi = hi + Math.imul(ah5, bh4) | 0,
                    lo = lo + Math.imul(al4, bl5) | 0,
                    mid = (mid = mid + Math.imul(al4, bh5) | 0) + Math.imul(ah4, bl5) | 0,
                    hi = hi + Math.imul(ah4, bh5) | 0,
                    lo = lo + Math.imul(al3, bl6) | 0,
                    mid = (mid = mid + Math.imul(al3, bh6) | 0) + Math.imul(ah3, bl6) | 0,
                    hi = hi + Math.imul(ah3, bh6) | 0,
                    lo = lo + Math.imul(al2, bl7) | 0,
                    mid = (mid = mid + Math.imul(al2, bh7) | 0) + Math.imul(ah2, bl7) | 0,
                    hi = hi + Math.imul(ah2, bh7) | 0,
                    lo = lo + Math.imul(al1, bl8) | 0,
                    mid = (mid = mid + Math.imul(al1, bh8) | 0) + Math.imul(ah1, bl8) | 0,
                    hi = hi + Math.imul(ah1, bh8) | 0;
                    var w9 = (c + (lo = lo + Math.imul(al0, bl9) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al0, bh9) | 0) + Math.imul(ah0, bl9) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah0, bh9) | 0) + (mid >>> 13) | 0) + (w9 >>> 26) | 0,
                    w9 &= 67108863,
                    lo = Math.imul(al9, bl1),
                    mid = (mid = Math.imul(al9, bh1)) + Math.imul(ah9, bl1) | 0,
                    hi = Math.imul(ah9, bh1),
                    lo = lo + Math.imul(al8, bl2) | 0,
                    mid = (mid = mid + Math.imul(al8, bh2) | 0) + Math.imul(ah8, bl2) | 0,
                    hi = hi + Math.imul(ah8, bh2) | 0,
                    lo = lo + Math.imul(al7, bl3) | 0,
                    mid = (mid = mid + Math.imul(al7, bh3) | 0) + Math.imul(ah7, bl3) | 0,
                    hi = hi + Math.imul(ah7, bh3) | 0,
                    lo = lo + Math.imul(al6, bl4) | 0,
                    mid = (mid = mid + Math.imul(al6, bh4) | 0) + Math.imul(ah6, bl4) | 0,
                    hi = hi + Math.imul(ah6, bh4) | 0,
                    lo = lo + Math.imul(al5, bl5) | 0,
                    mid = (mid = mid + Math.imul(al5, bh5) | 0) + Math.imul(ah5, bl5) | 0,
                    hi = hi + Math.imul(ah5, bh5) | 0,
                    lo = lo + Math.imul(al4, bl6) | 0,
                    mid = (mid = mid + Math.imul(al4, bh6) | 0) + Math.imul(ah4, bl6) | 0,
                    hi = hi + Math.imul(ah4, bh6) | 0,
                    lo = lo + Math.imul(al3, bl7) | 0,
                    mid = (mid = mid + Math.imul(al3, bh7) | 0) + Math.imul(ah3, bl7) | 0,
                    hi = hi + Math.imul(ah3, bh7) | 0,
                    lo = lo + Math.imul(al2, bl8) | 0,
                    mid = (mid = mid + Math.imul(al2, bh8) | 0) + Math.imul(ah2, bl8) | 0,
                    hi = hi + Math.imul(ah2, bh8) | 0;
                    var w10 = (c + (lo = lo + Math.imul(al1, bl9) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al1, bh9) | 0) + Math.imul(ah1, bl9) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah1, bh9) | 0) + (mid >>> 13) | 0) + (w10 >>> 26) | 0,
                    w10 &= 67108863,
                    lo = Math.imul(al9, bl2),
                    mid = (mid = Math.imul(al9, bh2)) + Math.imul(ah9, bl2) | 0,
                    hi = Math.imul(ah9, bh2),
                    lo = lo + Math.imul(al8, bl3) | 0,
                    mid = (mid = mid + Math.imul(al8, bh3) | 0) + Math.imul(ah8, bl3) | 0,
                    hi = hi + Math.imul(ah8, bh3) | 0,
                    lo = lo + Math.imul(al7, bl4) | 0,
                    mid = (mid = mid + Math.imul(al7, bh4) | 0) + Math.imul(ah7, bl4) | 0,
                    hi = hi + Math.imul(ah7, bh4) | 0,
                    lo = lo + Math.imul(al6, bl5) | 0,
                    mid = (mid = mid + Math.imul(al6, bh5) | 0) + Math.imul(ah6, bl5) | 0,
                    hi = hi + Math.imul(ah6, bh5) | 0,
                    lo = lo + Math.imul(al5, bl6) | 0,
                    mid = (mid = mid + Math.imul(al5, bh6) | 0) + Math.imul(ah5, bl6) | 0,
                    hi = hi + Math.imul(ah5, bh6) | 0,
                    lo = lo + Math.imul(al4, bl7) | 0,
                    mid = (mid = mid + Math.imul(al4, bh7) | 0) + Math.imul(ah4, bl7) | 0,
                    hi = hi + Math.imul(ah4, bh7) | 0,
                    lo = lo + Math.imul(al3, bl8) | 0,
                    mid = (mid = mid + Math.imul(al3, bh8) | 0) + Math.imul(ah3, bl8) | 0,
                    hi = hi + Math.imul(ah3, bh8) | 0;
                    var w11 = (c + (lo = lo + Math.imul(al2, bl9) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al2, bh9) | 0) + Math.imul(ah2, bl9) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah2, bh9) | 0) + (mid >>> 13) | 0) + (w11 >>> 26) | 0,
                    w11 &= 67108863,
                    lo = Math.imul(al9, bl3),
                    mid = (mid = Math.imul(al9, bh3)) + Math.imul(ah9, bl3) | 0,
                    hi = Math.imul(ah9, bh3),
                    lo = lo + Math.imul(al8, bl4) | 0,
                    mid = (mid = mid + Math.imul(al8, bh4) | 0) + Math.imul(ah8, bl4) | 0,
                    hi = hi + Math.imul(ah8, bh4) | 0,
                    lo = lo + Math.imul(al7, bl5) | 0,
                    mid = (mid = mid + Math.imul(al7, bh5) | 0) + Math.imul(ah7, bl5) | 0,
                    hi = hi + Math.imul(ah7, bh5) | 0,
                    lo = lo + Math.imul(al6, bl6) | 0,
                    mid = (mid = mid + Math.imul(al6, bh6) | 0) + Math.imul(ah6, bl6) | 0,
                    hi = hi + Math.imul(ah6, bh6) | 0,
                    lo = lo + Math.imul(al5, bl7) | 0,
                    mid = (mid = mid + Math.imul(al5, bh7) | 0) + Math.imul(ah5, bl7) | 0,
                    hi = hi + Math.imul(ah5, bh7) | 0,
                    lo = lo + Math.imul(al4, bl8) | 0,
                    mid = (mid = mid + Math.imul(al4, bh8) | 0) + Math.imul(ah4, bl8) | 0,
                    hi = hi + Math.imul(ah4, bh8) | 0;
                    var w12 = (c + (lo = lo + Math.imul(al3, bl9) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al3, bh9) | 0) + Math.imul(ah3, bl9) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah3, bh9) | 0) + (mid >>> 13) | 0) + (w12 >>> 26) | 0,
                    w12 &= 67108863,
                    lo = Math.imul(al9, bl4),
                    mid = (mid = Math.imul(al9, bh4)) + Math.imul(ah9, bl4) | 0,
                    hi = Math.imul(ah9, bh4),
                    lo = lo + Math.imul(al8, bl5) | 0,
                    mid = (mid = mid + Math.imul(al8, bh5) | 0) + Math.imul(ah8, bl5) | 0,
                    hi = hi + Math.imul(ah8, bh5) | 0,
                    lo = lo + Math.imul(al7, bl6) | 0,
                    mid = (mid = mid + Math.imul(al7, bh6) | 0) + Math.imul(ah7, bl6) | 0,
                    hi = hi + Math.imul(ah7, bh6) | 0,
                    lo = lo + Math.imul(al6, bl7) | 0,
                    mid = (mid = mid + Math.imul(al6, bh7) | 0) + Math.imul(ah6, bl7) | 0,
                    hi = hi + Math.imul(ah6, bh7) | 0,
                    lo = lo + Math.imul(al5, bl8) | 0,
                    mid = (mid = mid + Math.imul(al5, bh8) | 0) + Math.imul(ah5, bl8) | 0,
                    hi = hi + Math.imul(ah5, bh8) | 0;
                    var w13 = (c + (lo = lo + Math.imul(al4, bl9) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al4, bh9) | 0) + Math.imul(ah4, bl9) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah4, bh9) | 0) + (mid >>> 13) | 0) + (w13 >>> 26) | 0,
                    w13 &= 67108863,
                    lo = Math.imul(al9, bl5),
                    mid = (mid = Math.imul(al9, bh5)) + Math.imul(ah9, bl5) | 0,
                    hi = Math.imul(ah9, bh5),
                    lo = lo + Math.imul(al8, bl6) | 0,
                    mid = (mid = mid + Math.imul(al8, bh6) | 0) + Math.imul(ah8, bl6) | 0,
                    hi = hi + Math.imul(ah8, bh6) | 0,
                    lo = lo + Math.imul(al7, bl7) | 0,
                    mid = (mid = mid + Math.imul(al7, bh7) | 0) + Math.imul(ah7, bl7) | 0,
                    hi = hi + Math.imul(ah7, bh7) | 0,
                    lo = lo + Math.imul(al6, bl8) | 0,
                    mid = (mid = mid + Math.imul(al6, bh8) | 0) + Math.imul(ah6, bl8) | 0,
                    hi = hi + Math.imul(ah6, bh8) | 0;
                    var w14 = (c + (lo = lo + Math.imul(al5, bl9) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al5, bh9) | 0) + Math.imul(ah5, bl9) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah5, bh9) | 0) + (mid >>> 13) | 0) + (w14 >>> 26) | 0,
                    w14 &= 67108863,
                    lo = Math.imul(al9, bl6),
                    mid = (mid = Math.imul(al9, bh6)) + Math.imul(ah9, bl6) | 0,
                    hi = Math.imul(ah9, bh6),
                    lo = lo + Math.imul(al8, bl7) | 0,
                    mid = (mid = mid + Math.imul(al8, bh7) | 0) + Math.imul(ah8, bl7) | 0,
                    hi = hi + Math.imul(ah8, bh7) | 0,
                    lo = lo + Math.imul(al7, bl8) | 0,
                    mid = (mid = mid + Math.imul(al7, bh8) | 0) + Math.imul(ah7, bl8) | 0,
                    hi = hi + Math.imul(ah7, bh8) | 0;
                    var w15 = (c + (lo = lo + Math.imul(al6, bl9) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al6, bh9) | 0) + Math.imul(ah6, bl9) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah6, bh9) | 0) + (mid >>> 13) | 0) + (w15 >>> 26) | 0,
                    w15 &= 67108863,
                    lo = Math.imul(al9, bl7),
                    mid = (mid = Math.imul(al9, bh7)) + Math.imul(ah9, bl7) | 0,
                    hi = Math.imul(ah9, bh7),
                    lo = lo + Math.imul(al8, bl8) | 0,
                    mid = (mid = mid + Math.imul(al8, bh8) | 0) + Math.imul(ah8, bl8) | 0,
                    hi = hi + Math.imul(ah8, bh8) | 0;
                    var w16 = (c + (lo = lo + Math.imul(al7, bl9) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al7, bh9) | 0) + Math.imul(ah7, bl9) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah7, bh9) | 0) + (mid >>> 13) | 0) + (w16 >>> 26) | 0,
                    w16 &= 67108863,
                    lo = Math.imul(al9, bl8),
                    mid = (mid = Math.imul(al9, bh8)) + Math.imul(ah9, bl8) | 0,
                    hi = Math.imul(ah9, bh8);
                    var w17 = (c + (lo = lo + Math.imul(al8, bl9) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al8, bh9) | 0) + Math.imul(ah8, bl9) | 0)) << 13) | 0;
                    c = ((hi = hi + Math.imul(ah8, bh9) | 0) + (mid >>> 13) | 0) + (w17 >>> 26) | 0,
                    w17 &= 67108863;
                    var w18 = (c + (lo = Math.imul(al9, bl9)) | 0) + ((8191 & (mid = (mid = Math.imul(al9, bh9)) + Math.imul(ah9, bl9) | 0)) << 13) | 0;
                    return c = ((hi = Math.imul(ah9, bh9)) + (mid >>> 13) | 0) + (w18 >>> 26) | 0,
                    w18 &= 67108863,
                    o[0] = w0,
                    o[1] = w1,
                    o[2] = w2,
                    o[3] = w3,
                    o[4] = w4,
                    o[5] = w5,
                    o[6] = w6,
                    o[7] = w7,
                    o[8] = w8,
                    o[9] = w9,
                    o[10] = w10,
                    o[11] = w11,
                    o[12] = w12,
                    o[13] = w13,
                    o[14] = w14,
                    o[15] = w15,
                    o[16] = w16,
                    o[17] = w17,
                    o[18] = w18,
                    0 !== c && (o[19] = c,
                    out.length++),
                    out
                };
                function bigMulTo(self, num, out) {
                    out.negative = num.negative ^ self.negative,
                    out.length = self.length + num.length;
                    for (var carry = 0, hncarry = 0, k = 0; k < out.length - 1; k++) {
                        var ncarry = hncarry;
                        hncarry = 0;
                        for (var rword = 67108863 & carry, maxJ = Math.min(k, num.length - 1), j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
                            var i = k - j
                              , r = (0 | self.words[i]) * (0 | num.words[j])
                              , lo = 67108863 & r;
                            rword = 67108863 & (lo = lo + rword | 0),
                            hncarry += (ncarry = (ncarry = ncarry + (r / 67108864 | 0) | 0) + (lo >>> 26) | 0) >>> 26,
                            ncarry &= 67108863
                        }
                        out.words[k] = rword,
                        carry = ncarry,
                        ncarry = hncarry
                    }
                    return 0 !== carry ? out.words[k] = carry : out.length--,
                    out._strip()
                }
                function jumboMulTo(self, num, out) {
                    return bigMulTo(self, num, out)
                }
                function FFTM(x, y) {
                    this.x = x,
                    this.y = y
                }
                Math.imul || (comb10MulTo = smallMulTo),
                BN.prototype.mulTo = function(num, out) {
                    var len = this.length + num.length;
                    return 10 === this.length && 10 === num.length ? comb10MulTo(this, num, out) : len < 63 ? smallMulTo(this, num, out) : len < 1024 ? bigMulTo(this, num, out) : jumboMulTo(this, num, out)
                }
                ,
                FFTM.prototype.makeRBT = function(N) {
                    for (var t = new Array(N), l = BN.prototype._countBits(N) - 1, i = 0; i < N; i++)
                        t[i] = this.revBin(i, l, N);
                    return t
                }
                ,
                FFTM.prototype.revBin = function(x, l, N) {
                    if (0 === x || x === N - 1)
                        return x;
                    for (var rb = 0, i = 0; i < l; i++)
                        rb |= (1 & x) << l - i - 1,
                        x >>= 1;
                    return rb
                }
                ,
                FFTM.prototype.permute = function(rbt, rws, iws, rtws, itws, N) {
                    for (var i = 0; i < N; i++)
                        rtws[i] = rws[rbt[i]],
                        itws[i] = iws[rbt[i]]
                }
                ,
                FFTM.prototype.transform = function(rws, iws, rtws, itws, N, rbt) {
                    this.permute(rbt, rws, iws, rtws, itws, N);
                    for (var s = 1; s < N; s <<= 1)
                        for (var l = s << 1, rtwdf = Math.cos(2 * Math.PI / l), itwdf = Math.sin(2 * Math.PI / l), p = 0; p < N; p += l)
                            for (var rtwdf_ = rtwdf, itwdf_ = itwdf, j = 0; j < s; j++) {
                                var re = rtws[p + j]
                                  , ie = itws[p + j]
                                  , ro = rtws[p + j + s]
                                  , io = itws[p + j + s]
                                  , rx = rtwdf_ * ro - itwdf_ * io;
                                io = rtwdf_ * io + itwdf_ * ro,
                                ro = rx,
                                rtws[p + j] = re + ro,
                                itws[p + j] = ie + io,
                                rtws[p + j + s] = re - ro,
                                itws[p + j + s] = ie - io,
                                j !== l && (rx = rtwdf * rtwdf_ - itwdf * itwdf_,
                                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_,
                                rtwdf_ = rx)
                            }
                }
                ,
                FFTM.prototype.guessLen13b = function(n, m) {
                    var N = 1 | Math.max(m, n)
                      , odd = 1 & N
                      , i = 0;
                    for (N = N / 2 | 0; N; N >>>= 1)
                        i++;
                    return 1 << i + 1 + odd
                }
                ,
                FFTM.prototype.conjugate = function(rws, iws, N) {
                    if (!(N <= 1))
                        for (var i = 0; i < N / 2; i++) {
                            var t = rws[i];
                            rws[i] = rws[N - i - 1],
                            rws[N - i - 1] = t,
                            t = iws[i],
                            iws[i] = -iws[N - i - 1],
                            iws[N - i - 1] = -t
                        }
                }
                ,
                FFTM.prototype.normalize13b = function(ws, N) {
                    for (var carry = 0, i = 0; i < N / 2; i++) {
                        var w = 8192 * Math.round(ws[2 * i + 1] / N) + Math.round(ws[2 * i] / N) + carry;
                        ws[i] = 67108863 & w,
                        carry = w < 67108864 ? 0 : w / 67108864 | 0
                    }
                    return ws
                }
                ,
                FFTM.prototype.convert13b = function(ws, len, rws, N) {
                    for (var carry = 0, i = 0; i < len; i++)
                        carry += 0 | ws[i],
                        rws[2 * i] = 8191 & carry,
                        carry >>>= 13,
                        rws[2 * i + 1] = 8191 & carry,
                        carry >>>= 13;
                    for (i = 2 * len; i < N; ++i)
                        rws[i] = 0;
                    assert(0 === carry),
                    assert(0 == (-8192 & carry))
                }
                ,
                FFTM.prototype.stub = function(N) {
                    for (var ph = new Array(N), i = 0; i < N; i++)
                        ph[i] = 0;
                    return ph
                }
                ,
                FFTM.prototype.mulp = function(x, y, out) {
                    var N = 2 * this.guessLen13b(x.length, y.length)
                      , rbt = this.makeRBT(N)
                      , _ = this.stub(N)
                      , rws = new Array(N)
                      , rwst = new Array(N)
                      , iwst = new Array(N)
                      , nrws = new Array(N)
                      , nrwst = new Array(N)
                      , niwst = new Array(N)
                      , rmws = out.words;
                    rmws.length = N,
                    this.convert13b(x.words, x.length, rws, N),
                    this.convert13b(y.words, y.length, nrws, N),
                    this.transform(rws, _, rwst, iwst, N, rbt),
                    this.transform(nrws, _, nrwst, niwst, N, rbt);
                    for (var i = 0; i < N; i++) {
                        var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
                        iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i],
                        rwst[i] = rx
                    }
                    return this.conjugate(rwst, iwst, N),
                    this.transform(rwst, iwst, rmws, _, N, rbt),
                    this.conjugate(rmws, _, N),
                    this.normalize13b(rmws, N),
                    out.negative = x.negative ^ y.negative,
                    out.length = x.length + y.length,
                    out._strip()
                }
                ,
                BN.prototype.mul = function(num) {
                    var out = new BN(null);
                    return out.words = new Array(this.length + num.length),
                    this.mulTo(num, out)
                }
                ,
                BN.prototype.mulf = function(num) {
                    var out = new BN(null);
                    return out.words = new Array(this.length + num.length),
                    jumboMulTo(this, num, out)
                }
                ,
                BN.prototype.imul = function(num) {
                    return this.clone().mulTo(num, this)
                }
                ,
                BN.prototype.imuln = function(num) {
                    var isNegNum = num < 0;
                    isNegNum && (num = -num),
                    assert("number" == typeof num),
                    assert(num < 67108864);
                    for (var carry = 0, i = 0; i < this.length; i++) {
                        var w = (0 | this.words[i]) * num
                          , lo = (67108863 & w) + (67108863 & carry);
                        carry >>= 26,
                        carry += w / 67108864 | 0,
                        carry += lo >>> 26,
                        this.words[i] = 67108863 & lo
                    }
                    return 0 !== carry && (this.words[i] = carry,
                    this.length++),
                    isNegNum ? this.ineg() : this
                }
                ,
                BN.prototype.muln = function(num) {
                    return this.clone().imuln(num)
                }
                ,
                BN.prototype.sqr = function() {
                    return this.mul(this)
                }
                ,
                BN.prototype.isqr = function() {
                    return this.imul(this.clone())
                }
                ,
                BN.prototype.pow = function(num) {
                    var w = function(num) {
                        for (var w = new Array(num.bitLength()), bit = 0; bit < w.length; bit++) {
                            var off = bit / 26 | 0
                              , wbit = bit % 26;
                            w[bit] = num.words[off] >>> wbit & 1
                        }
                        return w
                    }(num);
                    if (0 === w.length)
                        return new BN(1);
                    for (var res = this, i = 0; i < w.length && 0 === w[i]; i++,
                    res = res.sqr())
                        ;
                    if (++i < w.length)
                        for (var q = res.sqr(); i < w.length; i++,
                        q = q.sqr())
                            0 !== w[i] && (res = res.mul(q));
                    return res
                }
                ,
                BN.prototype.iushln = function(bits) {
                    assert("number" == typeof bits && bits >= 0);
                    var i, r = bits % 26, s = (bits - r) / 26, carryMask = 67108863 >>> 26 - r << 26 - r;
                    if (0 !== r) {
                        var carry = 0;
                        for (i = 0; i < this.length; i++) {
                            var newCarry = this.words[i] & carryMask
                              , c = (0 | this.words[i]) - newCarry << r;
                            this.words[i] = c | carry,
                            carry = newCarry >>> 26 - r
                        }
                        carry && (this.words[i] = carry,
                        this.length++)
                    }
                    if (0 !== s) {
                        for (i = this.length - 1; i >= 0; i--)
                            this.words[i + s] = this.words[i];
                        for (i = 0; i < s; i++)
                            this.words[i] = 0;
                        this.length += s
                    }
                    return this._strip()
                }
                ,
                BN.prototype.ishln = function(bits) {
                    return assert(0 === this.negative),
                    this.iushln(bits)
                }
                ,
                BN.prototype.iushrn = function(bits, hint, extended) {
                    var h;
                    assert("number" == typeof bits && bits >= 0),
                    h = hint ? (hint - hint % 26) / 26 : 0;
                    var r = bits % 26
                      , s = Math.min((bits - r) / 26, this.length)
                      , mask = 67108863 ^ 67108863 >>> r << r
                      , maskedWords = extended;
                    if (h -= s,
                    h = Math.max(0, h),
                    maskedWords) {
                        for (var i = 0; i < s; i++)
                            maskedWords.words[i] = this.words[i];
                        maskedWords.length = s
                    }
                    if (0 === s)
                        ;
                    else if (this.length > s)
                        for (this.length -= s,
                        i = 0; i < this.length; i++)
                            this.words[i] = this.words[i + s];
                    else
                        this.words[0] = 0,
                        this.length = 1;
                    var carry = 0;
                    for (i = this.length - 1; i >= 0 && (0 !== carry || i >= h); i--) {
                        var word = 0 | this.words[i];
                        this.words[i] = carry << 26 - r | word >>> r,
                        carry = word & mask
                    }
                    return maskedWords && 0 !== carry && (maskedWords.words[maskedWords.length++] = carry),
                    0 === this.length && (this.words[0] = 0,
                    this.length = 1),
                    this._strip()
                }
                ,
                BN.prototype.ishrn = function(bits, hint, extended) {
                    return assert(0 === this.negative),
                    this.iushrn(bits, hint, extended)
                }
                ,
                BN.prototype.shln = function(bits) {
                    return this.clone().ishln(bits)
                }
                ,
                BN.prototype.ushln = function(bits) {
                    return this.clone().iushln(bits)
                }
                ,
                BN.prototype.shrn = function(bits) {
                    return this.clone().ishrn(bits)
                }
                ,
                BN.prototype.ushrn = function(bits) {
                    return this.clone().iushrn(bits)
                }
                ,
                BN.prototype.testn = function(bit) {
                    assert("number" == typeof bit && bit >= 0);
                    var r = bit % 26
                      , s = (bit - r) / 26
                      , q = 1 << r;
                    return !(this.length <= s) && !!(this.words[s] & q)
                }
                ,
                BN.prototype.imaskn = function(bits) {
                    assert("number" == typeof bits && bits >= 0);
                    var r = bits % 26
                      , s = (bits - r) / 26;
                    if (assert(0 === this.negative, "imaskn works only with positive numbers"),
                    this.length <= s)
                        return this;
                    if (0 !== r && s++,
                    this.length = Math.min(s, this.length),
                    0 !== r) {
                        var mask = 67108863 ^ 67108863 >>> r << r;
                        this.words[this.length - 1] &= mask
                    }
                    return this._strip()
                }
                ,
                BN.prototype.maskn = function(bits) {
                    return this.clone().imaskn(bits)
                }
                ,
                BN.prototype.iaddn = function(num) {
                    return assert("number" == typeof num),
                    assert(num < 67108864),
                    num < 0 ? this.isubn(-num) : 0 !== this.negative ? 1 === this.length && (0 | this.words[0]) <= num ? (this.words[0] = num - (0 | this.words[0]),
                    this.negative = 0,
                    this) : (this.negative = 0,
                    this.isubn(num),
                    this.negative = 1,
                    this) : this._iaddn(num)
                }
                ,
                BN.prototype._iaddn = function(num) {
                    this.words[0] += num;
                    for (var i = 0; i < this.length && this.words[i] >= 67108864; i++)
                        this.words[i] -= 67108864,
                        i === this.length - 1 ? this.words[i + 1] = 1 : this.words[i + 1]++;
                    return this.length = Math.max(this.length, i + 1),
                    this
                }
                ,
                BN.prototype.isubn = function(num) {
                    if (assert("number" == typeof num),
                    assert(num < 67108864),
                    num < 0)
                        return this.iaddn(-num);
                    if (0 !== this.negative)
                        return this.negative = 0,
                        this.iaddn(num),
                        this.negative = 1,
                        this;
                    if (this.words[0] -= num,
                    1 === this.length && this.words[0] < 0)
                        this.words[0] = -this.words[0],
                        this.negative = 1;
                    else
                        for (var i = 0; i < this.length && this.words[i] < 0; i++)
                            this.words[i] += 67108864,
                            this.words[i + 1] -= 1;
                    return this._strip()
                }
                ,
                BN.prototype.addn = function(num) {
                    return this.clone().iaddn(num)
                }
                ,
                BN.prototype.subn = function(num) {
                    return this.clone().isubn(num)
                }
                ,
                BN.prototype.iabs = function() {
                    return this.negative = 0,
                    this
                }
                ,
                BN.prototype.abs = function() {
                    return this.clone().iabs()
                }
                ,
                BN.prototype._ishlnsubmul = function(num, mul, shift) {
                    var i, w, len = num.length + shift;
                    this._expand(len);
                    var carry = 0;
                    for (i = 0; i < num.length; i++) {
                        w = (0 | this.words[i + shift]) + carry;
                        var right = (0 | num.words[i]) * mul;
                        carry = ((w -= 67108863 & right) >> 26) - (right / 67108864 | 0),
                        this.words[i + shift] = 67108863 & w
                    }
                    for (; i < this.length - shift; i++)
                        carry = (w = (0 | this.words[i + shift]) + carry) >> 26,
                        this.words[i + shift] = 67108863 & w;
                    if (0 === carry)
                        return this._strip();
                    for (assert(-1 === carry),
                    carry = 0,
                    i = 0; i < this.length; i++)
                        carry = (w = -(0 | this.words[i]) + carry) >> 26,
                        this.words[i] = 67108863 & w;
                    return this.negative = 1,
                    this._strip()
                }
                ,
                BN.prototype._wordDiv = function(num, mode) {
                    var shift = (this.length,
                    num.length)
                      , a = this.clone()
                      , b = num
                      , bhi = 0 | b.words[b.length - 1];
                    0 !== (shift = 26 - this._countBits(bhi)) && (b = b.ushln(shift),
                    a.iushln(shift),
                    bhi = 0 | b.words[b.length - 1]);
                    var q, m = a.length - b.length;
                    if ("mod" !== mode) {
                        (q = new BN(null)).length = m + 1,
                        q.words = new Array(q.length);
                        for (var i = 0; i < q.length; i++)
                            q.words[i] = 0
                    }
                    var diff = a.clone()._ishlnsubmul(b, 1, m);
                    0 === diff.negative && (a = diff,
                    q && (q.words[m] = 1));
                    for (var j = m - 1; j >= 0; j--) {
                        var qj = 67108864 * (0 | a.words[b.length + j]) + (0 | a.words[b.length + j - 1]);
                        for (qj = Math.min(qj / bhi | 0, 67108863),
                        a._ishlnsubmul(b, qj, j); 0 !== a.negative; )
                            qj--,
                            a.negative = 0,
                            a._ishlnsubmul(b, 1, j),
                            a.isZero() || (a.negative ^= 1);
                        q && (q.words[j] = qj)
                    }
                    return q && q._strip(),
                    a._strip(),
                    "div" !== mode && 0 !== shift && a.iushrn(shift),
                    {
                        div: q || null,
                        mod: a
                    }
                }
                ,
                BN.prototype.divmod = function(num, mode, positive) {
                    return assert(!num.isZero()),
                    this.isZero() ? {
                        div: new BN(0),
                        mod: new BN(0)
                    } : 0 !== this.negative && 0 === num.negative ? (res = this.neg().divmod(num, mode),
                    "mod" !== mode && (div = res.div.neg()),
                    "div" !== mode && (mod = res.mod.neg(),
                    positive && 0 !== mod.negative && mod.iadd(num)),
                    {
                        div,
                        mod
                    }) : 0 === this.negative && 0 !== num.negative ? (res = this.divmod(num.neg(), mode),
                    "mod" !== mode && (div = res.div.neg()),
                    {
                        div,
                        mod: res.mod
                    }) : 0 != (this.negative & num.negative) ? (res = this.neg().divmod(num.neg(), mode),
                    "div" !== mode && (mod = res.mod.neg(),
                    positive && 0 !== mod.negative && mod.isub(num)),
                    {
                        div: res.div,
                        mod
                    }) : num.length > this.length || this.cmp(num) < 0 ? {
                        div: new BN(0),
                        mod: this
                    } : 1 === num.length ? "div" === mode ? {
                        div: this.divn(num.words[0]),
                        mod: null
                    } : "mod" === mode ? {
                        div: null,
                        mod: new BN(this.modrn(num.words[0]))
                    } : {
                        div: this.divn(num.words[0]),
                        mod: new BN(this.modrn(num.words[0]))
                    } : this._wordDiv(num, mode);
                    var div, mod, res
                }
                ,
                BN.prototype.div = function(num) {
                    return this.divmod(num, "div", !1).div
                }
                ,
                BN.prototype.mod = function(num) {
                    return this.divmod(num, "mod", !1).mod
                }
                ,
                BN.prototype.umod = function(num) {
                    return this.divmod(num, "mod", !0).mod
                }
                ,
                BN.prototype.divRound = function(num) {
                    var dm = this.divmod(num);
                    if (dm.mod.isZero())
                        return dm.div;
                    var mod = 0 !== dm.div.negative ? dm.mod.isub(num) : dm.mod
                      , half = num.ushrn(1)
                      , r2 = num.andln(1)
                      , cmp = mod.cmp(half);
                    return cmp < 0 || 1 === r2 && 0 === cmp ? dm.div : 0 !== dm.div.negative ? dm.div.isubn(1) : dm.div.iaddn(1)
                }
                ,
                BN.prototype.modrn = function(num) {
                    var isNegNum = num < 0;
                    isNegNum && (num = -num),
                    assert(num <= 67108863);
                    for (var p = (1 << 26) % num, acc = 0, i = this.length - 1; i >= 0; i--)
                        acc = (p * acc + (0 | this.words[i])) % num;
                    return isNegNum ? -acc : acc
                }
                ,
                BN.prototype.modn = function(num) {
                    return this.modrn(num)
                }
                ,
                BN.prototype.idivn = function(num) {
                    var isNegNum = num < 0;
                    isNegNum && (num = -num),
                    assert(num <= 67108863);
                    for (var carry = 0, i = this.length - 1; i >= 0; i--) {
                        var w = (0 | this.words[i]) + 67108864 * carry;
                        this.words[i] = w / num | 0,
                        carry = w % num
                    }
                    return this._strip(),
                    isNegNum ? this.ineg() : this
                }
                ,
                BN.prototype.divn = function(num) {
                    return this.clone().idivn(num)
                }
                ,
                BN.prototype.egcd = function(p) {
                    assert(0 === p.negative),
                    assert(!p.isZero());
                    var x = this
                      , y = p.clone();
                    x = 0 !== x.negative ? x.umod(p) : x.clone();
                    for (var A = new BN(1), B = new BN(0), C = new BN(0), D = new BN(1), g = 0; x.isEven() && y.isEven(); )
                        x.iushrn(1),
                        y.iushrn(1),
                        ++g;
                    for (var yp = y.clone(), xp = x.clone(); !x.isZero(); ) {
                        for (var i = 0, im = 1; 0 == (x.words[0] & im) && i < 26; ++i,
                        im <<= 1)
                            ;
                        if (i > 0)
                            for (x.iushrn(i); i-- > 0; )
                                (A.isOdd() || B.isOdd()) && (A.iadd(yp),
                                B.isub(xp)),
                                A.iushrn(1),
                                B.iushrn(1);
                        for (var j = 0, jm = 1; 0 == (y.words[0] & jm) && j < 26; ++j,
                        jm <<= 1)
                            ;
                        if (j > 0)
                            for (y.iushrn(j); j-- > 0; )
                                (C.isOdd() || D.isOdd()) && (C.iadd(yp),
                                D.isub(xp)),
                                C.iushrn(1),
                                D.iushrn(1);
                        x.cmp(y) >= 0 ? (x.isub(y),
                        A.isub(C),
                        B.isub(D)) : (y.isub(x),
                        C.isub(A),
                        D.isub(B))
                    }
                    return {
                        a: C,
                        b: D,
                        gcd: y.iushln(g)
                    }
                }
                ,
                BN.prototype._invmp = function(p) {
                    assert(0 === p.negative),
                    assert(!p.isZero());
                    var a = this
                      , b = p.clone();
                    a = 0 !== a.negative ? a.umod(p) : a.clone();
                    for (var res, x1 = new BN(1), x2 = new BN(0), delta = b.clone(); a.cmpn(1) > 0 && b.cmpn(1) > 0; ) {
                        for (var i = 0, im = 1; 0 == (a.words[0] & im) && i < 26; ++i,
                        im <<= 1)
                            ;
                        if (i > 0)
                            for (a.iushrn(i); i-- > 0; )
                                x1.isOdd() && x1.iadd(delta),
                                x1.iushrn(1);
                        for (var j = 0, jm = 1; 0 == (b.words[0] & jm) && j < 26; ++j,
                        jm <<= 1)
                            ;
                        if (j > 0)
                            for (b.iushrn(j); j-- > 0; )
                                x2.isOdd() && x2.iadd(delta),
                                x2.iushrn(1);
                        a.cmp(b) >= 0 ? (a.isub(b),
                        x1.isub(x2)) : (b.isub(a),
                        x2.isub(x1))
                    }
                    return (res = 0 === a.cmpn(1) ? x1 : x2).cmpn(0) < 0 && res.iadd(p),
                    res
                }
                ,
                BN.prototype.gcd = function(num) {
                    if (this.isZero())
                        return num.abs();
                    if (num.isZero())
                        return this.abs();
                    var a = this.clone()
                      , b = num.clone();
                    a.negative = 0,
                    b.negative = 0;
                    for (var shift = 0; a.isEven() && b.isEven(); shift++)
                        a.iushrn(1),
                        b.iushrn(1);
                    for (; ; ) {
                        for (; a.isEven(); )
                            a.iushrn(1);
                        for (; b.isEven(); )
                            b.iushrn(1);
                        var r = a.cmp(b);
                        if (r < 0) {
                            var t = a;
                            a = b,
                            b = t
                        } else if (0 === r || 0 === b.cmpn(1))
                            break;
                        a.isub(b)
                    }
                    return b.iushln(shift)
                }
                ,
                BN.prototype.invm = function(num) {
                    return this.egcd(num).a.umod(num)
                }
                ,
                BN.prototype.isEven = function() {
                    return 0 == (1 & this.words[0])
                }
                ,
                BN.prototype.isOdd = function() {
                    return 1 == (1 & this.words[0])
                }
                ,
                BN.prototype.andln = function(num) {
                    return this.words[0] & num
                }
                ,
                BN.prototype.bincn = function(bit) {
                    assert("number" == typeof bit);
                    var r = bit % 26
                      , s = (bit - r) / 26
                      , q = 1 << r;
                    if (this.length <= s)
                        return this._expand(s + 1),
                        this.words[s] |= q,
                        this;
                    for (var carry = q, i = s; 0 !== carry && i < this.length; i++) {
                        var w = 0 | this.words[i];
                        carry = (w += carry) >>> 26,
                        w &= 67108863,
                        this.words[i] = w
                    }
                    return 0 !== carry && (this.words[i] = carry,
                    this.length++),
                    this
                }
                ,
                BN.prototype.isZero = function() {
                    return 1 === this.length && 0 === this.words[0]
                }
                ,
                BN.prototype.cmpn = function(num) {
                    var res, negative = num < 0;
                    if (0 !== this.negative && !negative)
                        return -1;
                    if (0 === this.negative && negative)
                        return 1;
                    if (this._strip(),
                    this.length > 1)
                        res = 1;
                    else {
                        negative && (num = -num),
                        assert(num <= 67108863, "Number is too big");
                        var w = 0 | this.words[0];
                        res = w === num ? 0 : w < num ? -1 : 1
                    }
                    return 0 !== this.negative ? 0 | -res : res
                }
                ,
                BN.prototype.cmp = function(num) {
                    if (0 !== this.negative && 0 === num.negative)
                        return -1;
                    if (0 === this.negative && 0 !== num.negative)
                        return 1;
                    var res = this.ucmp(num);
                    return 0 !== this.negative ? 0 | -res : res
                }
                ,
                BN.prototype.ucmp = function(num) {
                    if (this.length > num.length)
                        return 1;
                    if (this.length < num.length)
                        return -1;
                    for (var res = 0, i = this.length - 1; i >= 0; i--) {
                        var a = 0 | this.words[i]
                          , b = 0 | num.words[i];
                        if (a !== b) {
                            a < b ? res = -1 : a > b && (res = 1);
                            break
                        }
                    }
                    return res
                }
                ,
                BN.prototype.gtn = function(num) {
                    return 1 === this.cmpn(num)
                }
                ,
                BN.prototype.gt = function(num) {
                    return 1 === this.cmp(num)
                }
                ,
                BN.prototype.gten = function(num) {
                    return this.cmpn(num) >= 0
                }
                ,
                BN.prototype.gte = function(num) {
                    return this.cmp(num) >= 0
                }
                ,
                BN.prototype.ltn = function(num) {
                    return -1 === this.cmpn(num)
                }
                ,
                BN.prototype.lt = function(num) {
                    return -1 === this.cmp(num)
                }
                ,
                BN.prototype.lten = function(num) {
                    return this.cmpn(num) <= 0
                }
                ,
                BN.prototype.lte = function(num) {
                    return this.cmp(num) <= 0
                }
                ,
                BN.prototype.eqn = function(num) {
                    return 0 === this.cmpn(num)
                }
                ,
                BN.prototype.eq = function(num) {
                    return 0 === this.cmp(num)
                }
                ,
                BN.red = function(num) {
                    return new Red(num)
                }
                ,
                BN.prototype.toRed = function(ctx) {
                    return assert(!this.red, "Already a number in reduction context"),
                    assert(0 === this.negative, "red works only with positives"),
                    ctx.convertTo(this)._forceRed(ctx)
                }
                ,
                BN.prototype.fromRed = function() {
                    return assert(this.red, "fromRed works only with numbers in reduction context"),
                    this.red.convertFrom(this)
                }
                ,
                BN.prototype._forceRed = function(ctx) {
                    return this.red = ctx,
                    this
                }
                ,
                BN.prototype.forceRed = function(ctx) {
                    return assert(!this.red, "Already a number in reduction context"),
                    this._forceRed(ctx)
                }
                ,
                BN.prototype.redAdd = function(num) {
                    return assert(this.red, "redAdd works only with red numbers"),
                    this.red.add(this, num)
                }
                ,
                BN.prototype.redIAdd = function(num) {
                    return assert(this.red, "redIAdd works only with red numbers"),
                    this.red.iadd(this, num)
                }
                ,
                BN.prototype.redSub = function(num) {
                    return assert(this.red, "redSub works only with red numbers"),
                    this.red.sub(this, num)
                }
                ,
                BN.prototype.redISub = function(num) {
                    return assert(this.red, "redISub works only with red numbers"),
                    this.red.isub(this, num)
                }
                ,
                BN.prototype.redShl = function(num) {
                    return assert(this.red, "redShl works only with red numbers"),
                    this.red.shl(this, num)
                }
                ,
                BN.prototype.redMul = function(num) {
                    return assert(this.red, "redMul works only with red numbers"),
                    this.red._verify2(this, num),
                    this.red.mul(this, num)
                }
                ,
                BN.prototype.redIMul = function(num) {
                    return assert(this.red, "redMul works only with red numbers"),
                    this.red._verify2(this, num),
                    this.red.imul(this, num)
                }
                ,
                BN.prototype.redSqr = function() {
                    return assert(this.red, "redSqr works only with red numbers"),
                    this.red._verify1(this),
                    this.red.sqr(this)
                }
                ,
                BN.prototype.redISqr = function() {
                    return assert(this.red, "redISqr works only with red numbers"),
                    this.red._verify1(this),
                    this.red.isqr(this)
                }
                ,
                BN.prototype.redSqrt = function() {
                    return assert(this.red, "redSqrt works only with red numbers"),
                    this.red._verify1(this),
                    this.red.sqrt(this)
                }
                ,
                BN.prototype.redInvm = function() {
                    return assert(this.red, "redInvm works only with red numbers"),
                    this.red._verify1(this),
                    this.red.invm(this)
                }
                ,
                BN.prototype.redNeg = function() {
                    return assert(this.red, "redNeg works only with red numbers"),
                    this.red._verify1(this),
                    this.red.neg(this)
                }
                ,
                BN.prototype.redPow = function(num) {
                    return assert(this.red && !num.red, "redPow(normalNum)"),
                    this.red._verify1(this),
                    this.red.pow(this, num)
                }
                ;
                var primes = {
                    k256: null,
                    p224: null,
                    p192: null,
                    p25519: null
                };
                function MPrime(name, p) {
                    this.name = name,
                    this.p = new BN(p,16),
                    this.n = this.p.bitLength(),
                    this.k = new BN(1).iushln(this.n).isub(this.p),
                    this.tmp = this._tmp()
                }
                function K256() {
                    MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
                }
                function P224() {
                    MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
                }
                function P192() {
                    MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
                }
                function P25519() {
                    MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
                }
                function Red(m) {
                    if ("string" == typeof m) {
                        var prime = BN._prime(m);
                        this.m = prime.p,
                        this.prime = prime
                    } else
                        assert(m.gtn(1), "modulus must be greater than 1"),
                        this.m = m,
                        this.prime = null
                }
                function Mont(m) {
                    Red.call(this, m),
                    this.shift = this.m.bitLength(),
                    this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26),
                    this.r = new BN(1).iushln(this.shift),
                    this.r2 = this.imod(this.r.sqr()),
                    this.rinv = this.r._invmp(this.m),
                    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m),
                    this.minv = this.minv.umod(this.r),
                    this.minv = this.r.sub(this.minv)
                }
                MPrime.prototype._tmp = function() {
                    var tmp = new BN(null);
                    return tmp.words = new Array(Math.ceil(this.n / 13)),
                    tmp
                }
                ,
                MPrime.prototype.ireduce = function(num) {
                    var rlen, r = num;
                    do {
                        this.split(r, this.tmp),
                        rlen = (r = (r = this.imulK(r)).iadd(this.tmp)).bitLength()
                    } while (rlen > this.n);
                    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
                    return 0 === cmp ? (r.words[0] = 0,
                    r.length = 1) : cmp > 0 ? r.isub(this.p) : void 0 !== r.strip ? r.strip() : r._strip(),
                    r
                }
                ,
                MPrime.prototype.split = function(input, out) {
                    input.iushrn(this.n, 0, out)
                }
                ,
                MPrime.prototype.imulK = function(num) {
                    return num.imul(this.k)
                }
                ,
                inherits(K256, MPrime),
                K256.prototype.split = function(input, output) {
                    for (var outLen = Math.min(input.length, 9), i = 0; i < outLen; i++)
                        output.words[i] = input.words[i];
                    if (output.length = outLen,
                    input.length <= 9)
                        return input.words[0] = 0,
                        void (input.length = 1);
                    var prev = input.words[9];
                    for (output.words[output.length++] = 4194303 & prev,
                    i = 10; i < input.length; i++) {
                        var next = 0 | input.words[i];
                        input.words[i - 10] = (4194303 & next) << 4 | prev >>> 22,
                        prev = next
                    }
                    prev >>>= 22,
                    input.words[i - 10] = prev,
                    0 === prev && input.length > 10 ? input.length -= 10 : input.length -= 9
                }
                ,
                K256.prototype.imulK = function(num) {
                    num.words[num.length] = 0,
                    num.words[num.length + 1] = 0,
                    num.length += 2;
                    for (var lo = 0, i = 0; i < num.length; i++) {
                        var w = 0 | num.words[i];
                        lo += 977 * w,
                        num.words[i] = 67108863 & lo,
                        lo = 64 * w + (lo / 67108864 | 0)
                    }
                    return 0 === num.words[num.length - 1] && (num.length--,
                    0 === num.words[num.length - 1] && num.length--),
                    num
                }
                ,
                inherits(P224, MPrime),
                inherits(P192, MPrime),
                inherits(P25519, MPrime),
                P25519.prototype.imulK = function(num) {
                    for (var carry = 0, i = 0; i < num.length; i++) {
                        var hi = 19 * (0 | num.words[i]) + carry
                          , lo = 67108863 & hi;
                        hi >>>= 26,
                        num.words[i] = lo,
                        carry = hi
                    }
                    return 0 !== carry && (num.words[num.length++] = carry),
                    num
                }
                ,
                BN._prime = function(name) {
                    if (primes[name])
                        return primes[name];
                    var prime;
                    if ("k256" === name)
                        prime = new K256;
                    else if ("p224" === name)
                        prime = new P224;
                    else if ("p192" === name)
                        prime = new P192;
                    else {
                        if ("p25519" !== name)
                            throw new Error("Unknown prime " + name);
                        prime = new P25519
                    }
                    return primes[name] = prime,
                    prime
                }
                ,
                Red.prototype._verify1 = function(a) {
                    assert(0 === a.negative, "red works only with positives"),
                    assert(a.red, "red works only with red numbers")
                }
                ,
                Red.prototype._verify2 = function(a, b) {
                    assert(0 == (a.negative | b.negative), "red works only with positives"),
                    assert(a.red && a.red === b.red, "red works only with red numbers")
                }
                ,
                Red.prototype.imod = function(a) {
                    return this.prime ? this.prime.ireduce(a)._forceRed(this) : (move(a, a.umod(this.m)._forceRed(this)),
                    a)
                }
                ,
                Red.prototype.neg = function(a) {
                    return a.isZero() ? a.clone() : this.m.sub(a)._forceRed(this)
                }
                ,
                Red.prototype.add = function(a, b) {
                    this._verify2(a, b);
                    var res = a.add(b);
                    return res.cmp(this.m) >= 0 && res.isub(this.m),
                    res._forceRed(this)
                }
                ,
                Red.prototype.iadd = function(a, b) {
                    this._verify2(a, b);
                    var res = a.iadd(b);
                    return res.cmp(this.m) >= 0 && res.isub(this.m),
                    res
                }
                ,
                Red.prototype.sub = function(a, b) {
                    this._verify2(a, b);
                    var res = a.sub(b);
                    return res.cmpn(0) < 0 && res.iadd(this.m),
                    res._forceRed(this)
                }
                ,
                Red.prototype.isub = function(a, b) {
                    this._verify2(a, b);
                    var res = a.isub(b);
                    return res.cmpn(0) < 0 && res.iadd(this.m),
                    res
                }
                ,
                Red.prototype.shl = function(a, num) {
                    return this._verify1(a),
                    this.imod(a.ushln(num))
                }
                ,
                Red.prototype.imul = function(a, b) {
                    return this._verify2(a, b),
                    this.imod(a.imul(b))
                }
                ,
                Red.prototype.mul = function(a, b) {
                    return this._verify2(a, b),
                    this.imod(a.mul(b))
                }
                ,
                Red.prototype.isqr = function(a) {
                    return this.imul(a, a.clone())
                }
                ,
                Red.prototype.sqr = function(a) {
                    return this.mul(a, a)
                }
                ,
                Red.prototype.sqrt = function(a) {
                    if (a.isZero())
                        return a.clone();
                    var mod3 = this.m.andln(3);
                    if (assert(mod3 % 2 == 1),
                    3 === mod3) {
                        var pow = this.m.add(new BN(1)).iushrn(2);
                        return this.pow(a, pow)
                    }
                    for (var q = this.m.subn(1), s = 0; !q.isZero() && 0 === q.andln(1); )
                        s++,
                        q.iushrn(1);
                    assert(!q.isZero());
                    var one = new BN(1).toRed(this)
                      , nOne = one.redNeg()
                      , lpow = this.m.subn(1).iushrn(1)
                      , z = this.m.bitLength();
                    for (z = new BN(2 * z * z).toRed(this); 0 !== this.pow(z, lpow).cmp(nOne); )
                        z.redIAdd(nOne);
                    for (var c = this.pow(z, q), r = this.pow(a, q.addn(1).iushrn(1)), t = this.pow(a, q), m = s; 0 !== t.cmp(one); ) {
                        for (var tmp = t, i = 0; 0 !== tmp.cmp(one); i++)
                            tmp = tmp.redSqr();
                        assert(i < m);
                        var b = this.pow(c, new BN(1).iushln(m - i - 1));
                        r = r.redMul(b),
                        c = b.redSqr(),
                        t = t.redMul(c),
                        m = i
                    }
                    return r
                }
                ,
                Red.prototype.invm = function(a) {
                    var inv = a._invmp(this.m);
                    return 0 !== inv.negative ? (inv.negative = 0,
                    this.imod(inv).redNeg()) : this.imod(inv)
                }
                ,
                Red.prototype.pow = function(a, num) {
                    if (num.isZero())
                        return new BN(1).toRed(this);
                    if (0 === num.cmpn(1))
                        return a.clone();
                    var wnd = new Array(16);
                    wnd[0] = new BN(1).toRed(this),
                    wnd[1] = a;
                    for (var i = 2; i < wnd.length; i++)
                        wnd[i] = this.mul(wnd[i - 1], a);
                    var res = wnd[0]
                      , current = 0
                      , currentLen = 0
                      , start = num.bitLength() % 26;
                    for (0 === start && (start = 26),
                    i = num.length - 1; i >= 0; i--) {
                        for (var word = num.words[i], j = start - 1; j >= 0; j--) {
                            var bit = word >> j & 1;
                            res !== wnd[0] && (res = this.sqr(res)),
                            0 !== bit || 0 !== current ? (current <<= 1,
                            current |= bit,
                            (4 === ++currentLen || 0 === i && 0 === j) && (res = this.mul(res, wnd[current]),
                            currentLen = 0,
                            current = 0)) : currentLen = 0
                        }
                        start = 26
                    }
                    return res
                }
                ,
                Red.prototype.convertTo = function(num) {
                    var r = num.umod(this.m);
                    return r === num ? r.clone() : r
                }
                ,
                Red.prototype.convertFrom = function(num) {
                    var res = num.clone();
                    return res.red = null,
                    res
                }
                ,
                BN.mont = function(num) {
                    return new Mont(num)
                }
                ,
                inherits(Mont, Red),
                Mont.prototype.convertTo = function(num) {
                    return this.imod(num.ushln(this.shift))
                }
                ,
                Mont.prototype.convertFrom = function(num) {
                    var r = this.imod(num.mul(this.rinv));
                    return r.red = null,
                    r
                }
                ,
                Mont.prototype.imul = function(a, b) {
                    if (a.isZero() || b.isZero())
                        return a.words[0] = 0,
                        a.length = 1,
                        a;
                    var t = a.imul(b)
                      , c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
                      , u = t.isub(c).iushrn(this.shift)
                      , res = u;
                    return u.cmp(this.m) >= 0 ? res = u.isub(this.m) : u.cmpn(0) < 0 && (res = u.iadd(this.m)),
                    res._forceRed(this)
                }
                ,
                Mont.prototype.mul = function(a, b) {
                    if (a.isZero() || b.isZero())
                        return new BN(0)._forceRed(this);
                    var t = a.mul(b)
                      , c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
                      , u = t.isub(c).iushrn(this.shift)
                      , res = u;
                    return u.cmp(this.m) >= 0 ? res = u.isub(this.m) : u.cmpn(0) < 0 && (res = u.iadd(this.m)),
                    res._forceRed(this)
                }
                ,
                Mont.prototype.invm = function(a) {
                    return this.imod(a._invmp(this.m).mul(this.r2))._forceRed(this)
                }
            }(module = __webpack_require__.nmd(module), this)
        },
        96456: (module,__unused_webpack_exports,__webpack_require__)=>{
            "use strict";
            const {Deflate, deflate, deflateRaw, gzip} = __webpack_require__(21409)
              , {Inflate, inflate, inflateRaw, ungzip} = __webpack_require__(4197)
              , constants = __webpack_require__(89605);
            module.exports.Deflate = Deflate,
            module.exports.deflate = deflate,
            module.exports.deflateRaw = deflateRaw,
            module.exports.gzip = gzip,
            module.exports.Inflate = Inflate,
            module.exports.inflate = inflate,
            module.exports.inflateRaw = inflateRaw,
            module.exports.ungzip = ungzip,
            module.exports.constants = constants
        }
        ,
        21409: (module,__unused_webpack_exports,__webpack_require__)=>{
            "use strict";
            const zlib_deflate = __webpack_require__(952)
              , utils = __webpack_require__(14113)
              , strings = __webpack_require__(63733)
              , msg = __webpack_require__(41171)
              , ZStream = __webpack_require__(63875)
              , toString = Object.prototype.toString
              , {Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH, Z_OK, Z_STREAM_END, Z_DEFAULT_COMPRESSION, Z_DEFAULT_STRATEGY, Z_DEFLATED} = __webpack_require__(89605);
            function Deflate(options) {
                this.options = utils.assign({
                    level: Z_DEFAULT_COMPRESSION,
                    method: Z_DEFLATED,
                    chunkSize: 16384,
                    windowBits: 15,
                    memLevel: 8,
                    strategy: Z_DEFAULT_STRATEGY
                }, options || {});
                let opt = this.options;
                opt.raw && opt.windowBits > 0 ? opt.windowBits = -opt.windowBits : opt.gzip && opt.windowBits > 0 && opt.windowBits < 16 && (opt.windowBits += 16),
                this.err = 0,
                this.msg = "",
                this.ended = !1,
                this.chunks = [],
                this.strm = new ZStream,
                this.strm.avail_out = 0;
                let status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
                if (status !== Z_OK)
                    throw new Error(msg[status]);
                if (opt.header && zlib_deflate.deflateSetHeader(this.strm, opt.header),
                opt.dictionary) {
                    let dict;
                    if (dict = "string" == typeof opt.dictionary ? strings.string2buf(opt.dictionary) : "[object ArrayBuffer]" === toString.call(opt.dictionary) ? new Uint8Array(opt.dictionary) : opt.dictionary,
                    status = zlib_deflate.deflateSetDictionary(this.strm, dict),
                    status !== Z_OK)
                        throw new Error(msg[status]);
                    this._dict_set = !0
                }
            }
            function deflate(input, options) {
                const deflator = new Deflate(options);
                if (deflator.push(input, !0),
                deflator.err)
                    throw deflator.msg || msg[deflator.err];
                return deflator.result
            }
            Deflate.prototype.push = function(data, flush_mode) {
                const strm = this.strm
                  , chunkSize = this.options.chunkSize;
                let status, _flush_mode;
                if (this.ended)
                    return !1;
                for (_flush_mode = flush_mode === ~~flush_mode ? flush_mode : !0 === flush_mode ? Z_FINISH : Z_NO_FLUSH,
                "string" == typeof data ? strm.input = strings.string2buf(data) : "[object ArrayBuffer]" === toString.call(data) ? strm.input = new Uint8Array(data) : strm.input = data,
                strm.next_in = 0,
                strm.avail_in = strm.input.length; ; )
                    if (0 === strm.avail_out && (strm.output = new Uint8Array(chunkSize),
                    strm.next_out = 0,
                    strm.avail_out = chunkSize),
                    (_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6)
                        this.onData(strm.output.subarray(0, strm.next_out)),
                        strm.avail_out = 0;
                    else {
                        if (status = zlib_deflate.deflate(strm, _flush_mode),
                        status === Z_STREAM_END)
                            return strm.next_out > 0 && this.onData(strm.output.subarray(0, strm.next_out)),
                            status = zlib_deflate.deflateEnd(this.strm),
                            this.onEnd(status),
                            this.ended = !0,
                            status === Z_OK;
                        if (0 !== strm.avail_out) {
                            if (_flush_mode > 0 && strm.next_out > 0)
                                this.onData(strm.output.subarray(0, strm.next_out)),
                                strm.avail_out = 0;
                            else if (0 === strm.avail_in)
                                break
                        } else
                            this.onData(strm.output)
                    }
                return !0
            }
            ,
            Deflate.prototype.onData = function(chunk) {
                this.chunks.push(chunk)
            }
            ,
            Deflate.prototype.onEnd = function(status) {
                status === Z_OK && (this.result = utils.flattenChunks(this.chunks)),
                this.chunks = [],
                this.err = status,
                this.msg = this.strm.msg
            }
            ,
            module.exports.Deflate = Deflate,
            module.exports.deflate = deflate,
            module.exports.deflateRaw = function(input, options) {
                return (options = options || {}).raw = !0,
                deflate(input, options)
            }
            ,
            module.exports.gzip = function(input, options) {
                return (options = options || {}).gzip = !0,
                deflate(input, options)
            }
            ,
            module.exports.constants = __webpack_require__(89605)
        }
        ,
        4197: (module,__unused_webpack_exports,__webpack_require__)=>{
            "use strict";
            const zlib_inflate = __webpack_require__(36453)
              , utils = __webpack_require__(14113)
              , strings = __webpack_require__(63733)
              , msg = __webpack_require__(41171)
              , ZStream = __webpack_require__(63875)
              , GZheader = __webpack_require__(83734)
              , toString = Object.prototype.toString
              , {Z_NO_FLUSH, Z_FINISH, Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR} = __webpack_require__(89605);
            function Inflate(options) {
                this.options = utils.assign({
                    chunkSize: 65536,
                    windowBits: 15,
                    to: ""
                }, options || {});
                const opt = this.options;
                opt.raw && opt.windowBits >= 0 && opt.windowBits < 16 && (opt.windowBits = -opt.windowBits,
                0 === opt.windowBits && (opt.windowBits = -15)),
                !(opt.windowBits >= 0 && opt.windowBits < 16) || options && options.windowBits || (opt.windowBits += 32),
                opt.windowBits > 15 && opt.windowBits < 48 && 0 == (15 & opt.windowBits) && (opt.windowBits |= 15),
                this.err = 0,
                this.msg = "",
                this.ended = !1,
                this.chunks = [],
                this.strm = new ZStream,
                this.strm.avail_out = 0;
                let status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
                if (status !== Z_OK)
                    throw new Error(msg[status]);
                if (this.header = new GZheader,
                zlib_inflate.inflateGetHeader(this.strm, this.header),
                opt.dictionary && ("string" == typeof opt.dictionary ? opt.dictionary = strings.string2buf(opt.dictionary) : "[object ArrayBuffer]" === toString.call(opt.dictionary) && (opt.dictionary = new Uint8Array(opt.dictionary)),
                opt.raw && (status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary),
                status !== Z_OK)))
                    throw new Error(msg[status])
            }
            function inflate(input, options) {
                const inflator = new Inflate(options);
                if (inflator.push(input),
                inflator.err)
                    throw inflator.msg || msg[inflator.err];
                return inflator.result
            }
            Inflate.prototype.push = function(data, flush_mode) {
                const strm = this.strm
                  , chunkSize = this.options.chunkSize
                  , dictionary = this.options.dictionary;
                let status, _flush_mode, last_avail_out;
                if (this.ended)
                    return !1;
                for (_flush_mode = flush_mode === ~~flush_mode ? flush_mode : !0 === flush_mode ? Z_FINISH : Z_NO_FLUSH,
                "[object ArrayBuffer]" === toString.call(data) ? strm.input = new Uint8Array(data) : strm.input = data,
                strm.next_in = 0,
                strm.avail_in = strm.input.length; ; ) {
                    for (0 === strm.avail_out && (strm.output = new Uint8Array(chunkSize),
                    strm.next_out = 0,
                    strm.avail_out = chunkSize),
                    status = zlib_inflate.inflate(strm, _flush_mode),
                    status === Z_NEED_DICT && dictionary && (status = zlib_inflate.inflateSetDictionary(strm, dictionary),
                    status === Z_OK ? status = zlib_inflate.inflate(strm, _flush_mode) : status === Z_DATA_ERROR && (status = Z_NEED_DICT)); strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && 0 !== data[strm.next_in]; )
                        zlib_inflate.inflateReset(strm),
                        status = zlib_inflate.inflate(strm, _flush_mode);
                    switch (status) {
                    case Z_STREAM_ERROR:
                    case Z_DATA_ERROR:
                    case Z_NEED_DICT:
                    case Z_MEM_ERROR:
                        return this.onEnd(status),
                        this.ended = !0,
                        !1
                    }
                    if (last_avail_out = strm.avail_out,
                    strm.next_out && (0 === strm.avail_out || status === Z_STREAM_END))
                        if ("string" === this.options.to) {
                            let next_out_utf8 = strings.utf8border(strm.output, strm.next_out)
                              , tail = strm.next_out - next_out_utf8
                              , utf8str = strings.buf2string(strm.output, next_out_utf8);
                            strm.next_out = tail,
                            strm.avail_out = chunkSize - tail,
                            tail && strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0),
                            this.onData(utf8str)
                        } else
                            this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
                    if (status !== Z_OK || 0 !== last_avail_out) {
                        if (status === Z_STREAM_END)
                            return status = zlib_inflate.inflateEnd(this.strm),
                            this.onEnd(status),
                            this.ended = !0,
                            !0;
                        if (0 === strm.avail_in)
                            break
                    }
                }
                return !0
            }
            ,
            Inflate.prototype.onData = function(chunk) {
                this.chunks.push(chunk)
            }
            ,
            Inflate.prototype.onEnd = function(status) {
                status === Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = utils.flattenChunks(this.chunks)),
                this.chunks = [],
                this.err = status,
                this.msg = this.strm.msg
            }
            ,
            module.exports.Inflate = Inflate,
            module.exports.inflate = inflate,
            module.exports.inflateRaw = function(input, options) {
                return (options = options || {}).raw = !0,
                inflate(input, options)
            }
            ,
            module.exports.ungzip = inflate,
            module.exports.constants = __webpack_require__(89605)
        }
        ,
        14113: module=>{
            "use strict";
            const _has = (obj,key)=>Object.prototype.hasOwnProperty.call(obj, key);
            module.exports.assign = function(obj) {
                const sources = Array.prototype.slice.call(arguments, 1);
                for (; sources.length; ) {
                    const source = sources.shift();
                    if (source) {
                        if ("object" != typeof source)
                            throw new TypeError(source + "must be non-object");
                        for (const p in source)
                            _has(source, p) && (obj[p] = source[p])
                    }
                }
                return obj
            }
            ,
            module.exports.flattenChunks = chunks=>{
                let len = 0;
                for (let i = 0, l = chunks.length; i < l; i++)
                    len += chunks[i].length;
                const result = new Uint8Array(len);
                for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
                    let chunk = chunks[i];
                    result.set(chunk, pos),
                    pos += chunk.length
                }
                return result
            }
        }
        ,
        63733: module=>{
            "use strict";
            let STR_APPLY_UIA_OK = !0;
            try {
                String.fromCharCode.apply(null, new Uint8Array(1))
            } catch (__) {
                STR_APPLY_UIA_OK = !1
            }
            const _utf8len = new Uint8Array(256);
            for (let q = 0; q < 256; q++)
                _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
            _utf8len[254] = _utf8len[254] = 1,
            module.exports.string2buf = str=>{
                if ("function" == typeof TextEncoder && TextEncoder.prototype.encode)
                    return (new TextEncoder).encode(str);
                let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
                for (m_pos = 0; m_pos < str_len; m_pos++)
                    c = str.charCodeAt(m_pos),
                    55296 == (64512 & c) && m_pos + 1 < str_len && (c2 = str.charCodeAt(m_pos + 1),
                    56320 == (64512 & c2) && (c = 65536 + (c - 55296 << 10) + (c2 - 56320),
                    m_pos++)),
                    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
                for (buf = new Uint8Array(buf_len),
                i = 0,
                m_pos = 0; i < buf_len; m_pos++)
                    c = str.charCodeAt(m_pos),
                    55296 == (64512 & c) && m_pos + 1 < str_len && (c2 = str.charCodeAt(m_pos + 1),
                    56320 == (64512 & c2) && (c = 65536 + (c - 55296 << 10) + (c2 - 56320),
                    m_pos++)),
                    c < 128 ? buf[i++] = c : c < 2048 ? (buf[i++] = 192 | c >>> 6,
                    buf[i++] = 128 | 63 & c) : c < 65536 ? (buf[i++] = 224 | c >>> 12,
                    buf[i++] = 128 | c >>> 6 & 63,
                    buf[i++] = 128 | 63 & c) : (buf[i++] = 240 | c >>> 18,
                    buf[i++] = 128 | c >>> 12 & 63,
                    buf[i++] = 128 | c >>> 6 & 63,
                    buf[i++] = 128 | 63 & c);
                return buf
            }
            ;
            module.exports.buf2string = (buf,max)=>{
                const len = max || buf.length;
                if ("function" == typeof TextDecoder && TextDecoder.prototype.decode)
                    return (new TextDecoder).decode(buf.subarray(0, max));
                let i, out;
                const utf16buf = new Array(2 * len);
                for (out = 0,
                i = 0; i < len; ) {
                    let c = buf[i++];
                    if (c < 128) {
                        utf16buf[out++] = c;
                        continue
                    }
                    let c_len = _utf8len[c];
                    if (c_len > 4)
                        utf16buf[out++] = 65533,
                        i += c_len - 1;
                    else {
                        for (c &= 2 === c_len ? 31 : 3 === c_len ? 15 : 7; c_len > 1 && i < len; )
                            c = c << 6 | 63 & buf[i++],
                            c_len--;
                        c_len > 1 ? utf16buf[out++] = 65533 : c < 65536 ? utf16buf[out++] = c : (c -= 65536,
                        utf16buf[out++] = 55296 | c >> 10 & 1023,
                        utf16buf[out++] = 56320 | 1023 & c)
                    }
                }
                return ((buf,len)=>{
                    if (len < 65534 && buf.subarray && STR_APPLY_UIA_OK)
                        return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
                    let result = "";
                    for (let i = 0; i < len; i++)
                        result += String.fromCharCode(buf[i]);
                    return result
                }
                )(utf16buf, out)
            }
            ,
            module.exports.utf8border = (buf,max)=>{
                (max = max || buf.length) > buf.length && (max = buf.length);
                let pos = max - 1;
                for (; pos >= 0 && 128 == (192 & buf[pos]); )
                    pos--;
                return pos < 0 || 0 === pos ? max : pos + _utf8len[buf[pos]] > max ? pos : max
            }
        }
        ,
        71926: module=>{
            "use strict";
            module.exports = (adler,buf,len,pos)=>{
                let s1 = 65535 & adler | 0
                  , s2 = adler >>> 16 & 65535 | 0
                  , n = 0;
                for (; 0 !== len; ) {
                    n = len > 2e3 ? 2e3 : len,
                    len -= n;
                    do {
                        s1 = s1 + buf[pos++] | 0,
                        s2 = s2 + s1 | 0
                    } while (--n);
                    s1 %= 65521,
                    s2 %= 65521
                }
                return s1 | s2 << 16 | 0
            }
        }
        ,
        89605: module=>{
            "use strict";
            module.exports = {
                Z_NO_FLUSH: 0,
                Z_PARTIAL_FLUSH: 1,
                Z_SYNC_FLUSH: 2,
                Z_FULL_FLUSH: 3,
                Z_FINISH: 4,
                Z_BLOCK: 5,
                Z_TREES: 6,
                Z_OK: 0,
                Z_STREAM_END: 1,
                Z_NEED_DICT: 2,
                Z_ERRNO: -1,
                Z_STREAM_ERROR: -2,
                Z_DATA_ERROR: -3,
                Z_MEM_ERROR: -4,
                Z_BUF_ERROR: -5,
                Z_NO_COMPRESSION: 0,
                Z_BEST_SPEED: 1,
                Z_BEST_COMPRESSION: 9,
                Z_DEFAULT_COMPRESSION: -1,
                Z_FILTERED: 1,
                Z_HUFFMAN_ONLY: 2,
                Z_RLE: 3,
                Z_FIXED: 4,
                Z_DEFAULT_STRATEGY: 0,
                Z_BINARY: 0,
                Z_TEXT: 1,
                Z_UNKNOWN: 2,
                Z_DEFLATED: 8
            }
        }
        ,
        35122: module=>{
            "use strict";
            const crcTable = new Uint32Array((()=>{
                let c, table = [];
                for (var n = 0; n < 256; n++) {
                    c = n;
                    for (var k = 0; k < 8; k++)
                        c = 1 & c ? 3988292384 ^ c >>> 1 : c >>> 1;
                    table[n] = c
                }
                return table
            }
            )());
            module.exports = (crc,buf,len,pos)=>{
                const t = crcTable
                  , end = pos + len;
                crc ^= -1;
                for (let i = pos; i < end; i++)
                    crc = crc >>> 8 ^ t[255 & (crc ^ buf[i])];
                return -1 ^ crc
            }
        }
        ,
        952: (module,__unused_webpack_exports,__webpack_require__)=>{
            "use strict";
            const {_tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align} = __webpack_require__(17794)
              , adler32 = __webpack_require__(71926)
              , crc32 = __webpack_require__(35122)
              , msg = __webpack_require__(41171)
              , {Z_NO_FLUSH, Z_PARTIAL_FLUSH, Z_FULL_FLUSH, Z_FINISH, Z_BLOCK, Z_OK, Z_STREAM_END, Z_STREAM_ERROR, Z_DATA_ERROR, Z_BUF_ERROR, Z_DEFAULT_COMPRESSION, Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY, Z_UNKNOWN, Z_DEFLATED} = __webpack_require__(89605)
              , err = (strm,errorCode)=>(strm.msg = msg[errorCode],
            errorCode)
              , rank = f=>2 * f - (f > 4 ? 9 : 0)
              , zero = buf=>{
                let len = buf.length;
                for (; --len >= 0; )
                    buf[len] = 0
            }
              , slide_hash = s=>{
                let n, m, p, wsize = s.w_size;
                n = s.hash_size,
                p = n;
                do {
                    m = s.head[--p],
                    s.head[p] = m >= wsize ? m - wsize : 0
                } while (--n);
                n = wsize,
                p = n;
                do {
                    m = s.prev[--p],
                    s.prev[p] = m >= wsize ? m - wsize : 0
                } while (--n)
            }
            ;
            let HASH = (s,prev,data)=>(prev << s.hash_shift ^ data) & s.hash_mask;
            const flush_pending = strm=>{
                const s = strm.state;
                let len = s.pending;
                len > strm.avail_out && (len = strm.avail_out),
                0 !== len && (strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out),
                strm.next_out += len,
                s.pending_out += len,
                strm.total_out += len,
                strm.avail_out -= len,
                s.pending -= len,
                0 === s.pending && (s.pending_out = 0))
            }
              , flush_block_only = (s,last)=>{
                _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last),
                s.block_start = s.strstart,
                flush_pending(s.strm)
            }
              , put_byte = (s,b)=>{
                s.pending_buf[s.pending++] = b
            }
              , putShortMSB = (s,b)=>{
                s.pending_buf[s.pending++] = b >>> 8 & 255,
                s.pending_buf[s.pending++] = 255 & b
            }
              , read_buf = (strm,buf,start,size)=>{
                let len = strm.avail_in;
                return len > size && (len = size),
                0 === len ? 0 : (strm.avail_in -= len,
                buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start),
                1 === strm.state.wrap ? strm.adler = adler32(strm.adler, buf, len, start) : 2 === strm.state.wrap && (strm.adler = crc32(strm.adler, buf, len, start)),
                strm.next_in += len,
                strm.total_in += len,
                len)
            }
              , longest_match = (s,cur_match)=>{
                let match, len, chain_length = s.max_chain_length, scan = s.strstart, best_len = s.prev_length, nice_match = s.nice_match;
                const limit = s.strstart > s.w_size - 262 ? s.strstart - (s.w_size - 262) : 0
                  , _win = s.window
                  , wmask = s.w_mask
                  , prev = s.prev
                  , strend = s.strstart + 258;
                let scan_end1 = _win[scan + best_len - 1]
                  , scan_end = _win[scan + best_len];
                s.prev_length >= s.good_match && (chain_length >>= 2),
                nice_match > s.lookahead && (nice_match = s.lookahead);
                do {
                    if (match = cur_match,
                    _win[match + best_len] === scan_end && _win[match + best_len - 1] === scan_end1 && _win[match] === _win[scan] && _win[++match] === _win[scan + 1]) {
                        scan += 2,
                        match++;
                        do {} while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
                        if (len = 258 - (strend - scan),
                        scan = strend - 258,
                        len > best_len) {
                            if (s.match_start = cur_match,
                            best_len = len,
                            len >= nice_match)
                                break;
                            scan_end1 = _win[scan + best_len - 1],
                            scan_end = _win[scan + best_len]
                        }
                    }
                } while ((cur_match = prev[cur_match & wmask]) > limit && 0 != --chain_length);
                return best_len <= s.lookahead ? best_len : s.lookahead
            }
              , fill_window = s=>{
                const _w_size = s.w_size;
                let n, more, str;
                do {
                    if (more = s.window_size - s.lookahead - s.strstart,
                    s.strstart >= _w_size + (_w_size - 262) && (s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0),
                    s.match_start -= _w_size,
                    s.strstart -= _w_size,
                    s.block_start -= _w_size,
                    s.insert > s.strstart && (s.insert = s.strstart),
                    slide_hash(s),
                    more += _w_size),
                    0 === s.strm.avail_in)
                        break;
                    if (n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more),
                    s.lookahead += n,
                    s.lookahead + s.insert >= 3)
                        for (str = s.strstart - s.insert,
                        s.ins_h = s.window[str],
                        s.ins_h = HASH(s, s.ins_h, s.window[str + 1]); s.insert && (s.ins_h = HASH(s, s.ins_h, s.window[str + 3 - 1]),
                        s.prev[str & s.w_mask] = s.head[s.ins_h],
                        s.head[s.ins_h] = str,
                        str++,
                        s.insert--,
                        !(s.lookahead + s.insert < 3)); )
                            ;
                } while (s.lookahead < 262 && 0 !== s.strm.avail_in)
            }
              , deflate_stored = (s,flush)=>{
                let len, left, have, min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5, last = 0, used = s.strm.avail_in;
                do {
                    if (len = 65535,
                    have = s.bi_valid + 42 >> 3,
                    s.strm.avail_out < have)
                        break;
                    if (have = s.strm.avail_out - have,
                    left = s.strstart - s.block_start,
                    len > left + s.strm.avail_in && (len = left + s.strm.avail_in),
                    len > have && (len = have),
                    len < min_block && (0 === len && flush !== Z_FINISH || flush === Z_NO_FLUSH || len !== left + s.strm.avail_in))
                        break;
                    last = flush === Z_FINISH && len === left + s.strm.avail_in ? 1 : 0,
                    _tr_stored_block(s, 0, 0, last),
                    s.pending_buf[s.pending - 4] = len,
                    s.pending_buf[s.pending - 3] = len >> 8,
                    s.pending_buf[s.pending - 2] = ~len,
                    s.pending_buf[s.pending - 1] = ~len >> 8,
                    flush_pending(s.strm),
                    left && (left > len && (left = len),
                    s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out),
                    s.strm.next_out += left,
                    s.strm.avail_out -= left,
                    s.strm.total_out += left,
                    s.block_start += left,
                    len -= left),
                    len && (read_buf(s.strm, s.strm.output, s.strm.next_out, len),
                    s.strm.next_out += len,
                    s.strm.avail_out -= len,
                    s.strm.total_out += len)
                } while (0 === last);
                return used -= s.strm.avail_in,
                used && (used >= s.w_size ? (s.matches = 2,
                s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0),
                s.strstart = s.w_size,
                s.insert = s.strstart) : (s.window_size - s.strstart <= used && (s.strstart -= s.w_size,
                s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0),
                s.matches < 2 && s.matches++,
                s.insert > s.strstart && (s.insert = s.strstart)),
                s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart),
                s.strstart += used,
                s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used),
                s.block_start = s.strstart),
                s.high_water < s.strstart && (s.high_water = s.strstart),
                last ? 4 : flush !== Z_NO_FLUSH && flush !== Z_FINISH && 0 === s.strm.avail_in && s.strstart === s.block_start ? 2 : (have = s.window_size - s.strstart,
                s.strm.avail_in > have && s.block_start >= s.w_size && (s.block_start -= s.w_size,
                s.strstart -= s.w_size,
                s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0),
                s.matches < 2 && s.matches++,
                have += s.w_size,
                s.insert > s.strstart && (s.insert = s.strstart)),
                have > s.strm.avail_in && (have = s.strm.avail_in),
                have && (read_buf(s.strm, s.window, s.strstart, have),
                s.strstart += have,
                s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have),
                s.high_water < s.strstart && (s.high_water = s.strstart),
                have = s.bi_valid + 42 >> 3,
                have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have,
                min_block = have > s.w_size ? s.w_size : have,
                left = s.strstart - s.block_start,
                (left >= min_block || (left || flush === Z_FINISH) && flush !== Z_NO_FLUSH && 0 === s.strm.avail_in && left <= have) && (len = left > have ? have : left,
                last = flush === Z_FINISH && 0 === s.strm.avail_in && len === left ? 1 : 0,
                _tr_stored_block(s, s.block_start, len, last),
                s.block_start += len,
                flush_pending(s.strm)),
                last ? 3 : 1)
            }
              , deflate_fast = (s,flush)=>{
                let hash_head, bflush;
                for (; ; ) {
                    if (s.lookahead < 262) {
                        if (fill_window(s),
                        s.lookahead < 262 && flush === Z_NO_FLUSH)
                            return 1;
                        if (0 === s.lookahead)
                            break
                    }
                    if (hash_head = 0,
                    s.lookahead >= 3 && (s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 3 - 1]),
                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h],
                    s.head[s.ins_h] = s.strstart),
                    0 !== hash_head && s.strstart - hash_head <= s.w_size - 262 && (s.match_length = longest_match(s, hash_head)),
                    s.match_length >= 3)
                        if (bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - 3),
                        s.lookahead -= s.match_length,
                        s.match_length <= s.max_lazy_match && s.lookahead >= 3) {
                            s.match_length--;
                            do {
                                s.strstart++,
                                s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 3 - 1]),
                                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h],
                                s.head[s.ins_h] = s.strstart
                            } while (0 != --s.match_length);
                            s.strstart++
                        } else
                            s.strstart += s.match_length,
                            s.match_length = 0,
                            s.ins_h = s.window[s.strstart],
                            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
                    else
                        bflush = _tr_tally(s, 0, s.window[s.strstart]),
                        s.lookahead--,
                        s.strstart++;
                    if (bflush && (flush_block_only(s, !1),
                    0 === s.strm.avail_out))
                        return 1
                }
                return s.insert = s.strstart < 2 ? s.strstart : 2,
                flush === Z_FINISH ? (flush_block_only(s, !0),
                0 === s.strm.avail_out ? 3 : 4) : s.sym_next && (flush_block_only(s, !1),
                0 === s.strm.avail_out) ? 1 : 2
            }
              , deflate_slow = (s,flush)=>{
                let hash_head, bflush, max_insert;
                for (; ; ) {
                    if (s.lookahead < 262) {
                        if (fill_window(s),
                        s.lookahead < 262 && flush === Z_NO_FLUSH)
                            return 1;
                        if (0 === s.lookahead)
                            break
                    }
                    if (hash_head = 0,
                    s.lookahead >= 3 && (s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 3 - 1]),
                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h],
                    s.head[s.ins_h] = s.strstart),
                    s.prev_length = s.match_length,
                    s.prev_match = s.match_start,
                    s.match_length = 2,
                    0 !== hash_head && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - 262 && (s.match_length = longest_match(s, hash_head),
                    s.match_length <= 5 && (s.strategy === Z_FILTERED || 3 === s.match_length && s.strstart - s.match_start > 4096) && (s.match_length = 2)),
                    s.prev_length >= 3 && s.match_length <= s.prev_length) {
                        max_insert = s.strstart + s.lookahead - 3,
                        bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - 3),
                        s.lookahead -= s.prev_length - 1,
                        s.prev_length -= 2;
                        do {
                            ++s.strstart <= max_insert && (s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 3 - 1]),
                            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h],
                            s.head[s.ins_h] = s.strstart)
                        } while (0 != --s.prev_length);
                        if (s.match_available = 0,
                        s.match_length = 2,
                        s.strstart++,
                        bflush && (flush_block_only(s, !1),
                        0 === s.strm.avail_out))
                            return 1
                    } else if (s.match_available) {
                        if (bflush = _tr_tally(s, 0, s.window[s.strstart - 1]),
                        bflush && flush_block_only(s, !1),
                        s.strstart++,
                        s.lookahead--,
                        0 === s.strm.avail_out)
                            return 1
                    } else
                        s.match_available = 1,
                        s.strstart++,
                        s.lookahead--
                }
                return s.match_available && (bflush = _tr_tally(s, 0, s.window[s.strstart - 1]),
                s.match_available = 0),
                s.insert = s.strstart < 2 ? s.strstart : 2,
                flush === Z_FINISH ? (flush_block_only(s, !0),
                0 === s.strm.avail_out ? 3 : 4) : s.sym_next && (flush_block_only(s, !1),
                0 === s.strm.avail_out) ? 1 : 2
            }
            ;
            function Config(good_length, max_lazy, nice_length, max_chain, func) {
                this.good_length = good_length,
                this.max_lazy = max_lazy,
                this.nice_length = nice_length,
                this.max_chain = max_chain,
                this.func = func
            }
            const configuration_table = [new Config(0,0,0,0,deflate_stored), new Config(4,4,8,4,deflate_fast), new Config(4,5,16,8,deflate_fast), new Config(4,6,32,32,deflate_fast), new Config(4,4,16,16,deflate_slow), new Config(8,16,32,32,deflate_slow), new Config(8,16,128,128,deflate_slow), new Config(8,32,128,256,deflate_slow), new Config(32,128,258,1024,deflate_slow), new Config(32,258,258,4096,deflate_slow)];
            function DeflateState() {
                this.strm = null,
                this.status = 0,
                this.pending_buf = null,
                this.pending_buf_size = 0,
                this.pending_out = 0,
                this.pending = 0,
                this.wrap = 0,
                this.gzhead = null,
                this.gzindex = 0,
                this.method = Z_DEFLATED,
                this.last_flush = -1,
                this.w_size = 0,
                this.w_bits = 0,
                this.w_mask = 0,
                this.window = null,
                this.window_size = 0,
                this.prev = null,
                this.head = null,
                this.ins_h = 0,
                this.hash_size = 0,
                this.hash_bits = 0,
                this.hash_mask = 0,
                this.hash_shift = 0,
                this.block_start = 0,
                this.match_length = 0,
                this.prev_match = 0,
                this.match_available = 0,
                this.strstart = 0,
                this.match_start = 0,
                this.lookahead = 0,
                this.prev_length = 0,
                this.max_chain_length = 0,
                this.max_lazy_match = 0,
                this.level = 0,
                this.strategy = 0,
                this.good_match = 0,
                this.nice_match = 0,
                this.dyn_ltree = new Uint16Array(1146),
                this.dyn_dtree = new Uint16Array(122),
                this.bl_tree = new Uint16Array(78),
                zero(this.dyn_ltree),
                zero(this.dyn_dtree),
                zero(this.bl_tree),
                this.l_desc = null,
                this.d_desc = null,
                this.bl_desc = null,
                this.bl_count = new Uint16Array(16),
                this.heap = new Uint16Array(573),
                zero(this.heap),
                this.heap_len = 0,
                this.heap_max = 0,
                this.depth = new Uint16Array(573),
                zero(this.depth),
                this.sym_buf = 0,
                this.lit_bufsize = 0,
                this.sym_next = 0,
                this.sym_end = 0,
                this.opt_len = 0,
                this.static_len = 0,
                this.matches = 0,
                this.insert = 0,
                this.bi_buf = 0,
                this.bi_valid = 0
            }
            const deflateStateCheck = strm=>{
                if (!strm)
                    return 1;
                const s = strm.state;
                return !s || s.strm !== strm || 42 !== s.status && 57 !== s.status && 69 !== s.status && 73 !== s.status && 91 !== s.status && 103 !== s.status && 113 !== s.status && 666 !== s.status ? 1 : 0
            }
              , deflateResetKeep = strm=>{
                if (deflateStateCheck(strm))
                    return err(strm, Z_STREAM_ERROR);
                strm.total_in = strm.total_out = 0,
                strm.data_type = Z_UNKNOWN;
                const s = strm.state;
                return s.pending = 0,
                s.pending_out = 0,
                s.wrap < 0 && (s.wrap = -s.wrap),
                s.status = 2 === s.wrap ? 57 : s.wrap ? 42 : 113,
                strm.adler = 2 === s.wrap ? 0 : 1,
                s.last_flush = -2,
                _tr_init(s),
                Z_OK
            }
              , deflateReset = strm=>{
                const ret = deflateResetKeep(strm);
                var s;
                return ret === Z_OK && ((s = strm.state).window_size = 2 * s.w_size,
                zero(s.head),
                s.max_lazy_match = configuration_table[s.level].max_lazy,
                s.good_match = configuration_table[s.level].good_length,
                s.nice_match = configuration_table[s.level].nice_length,
                s.max_chain_length = configuration_table[s.level].max_chain,
                s.strstart = 0,
                s.block_start = 0,
                s.lookahead = 0,
                s.insert = 0,
                s.match_length = s.prev_length = 2,
                s.match_available = 0,
                s.ins_h = 0),
                ret
            }
              , deflateInit2 = (strm,level,method,windowBits,memLevel,strategy)=>{
                if (!strm)
                    return Z_STREAM_ERROR;
                let wrap = 1;
                if (level === Z_DEFAULT_COMPRESSION && (level = 6),
                windowBits < 0 ? (wrap = 0,
                windowBits = -windowBits) : windowBits > 15 && (wrap = 2,
                windowBits -= 16),
                memLevel < 1 || memLevel > 9 || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || 8 === windowBits && 1 !== wrap)
                    return err(strm, Z_STREAM_ERROR);
                8 === windowBits && (windowBits = 9);
                const s = new DeflateState;
                return strm.state = s,
                s.strm = strm,
                s.status = 42,
                s.wrap = wrap,
                s.gzhead = null,
                s.w_bits = windowBits,
                s.w_size = 1 << s.w_bits,
                s.w_mask = s.w_size - 1,
                s.hash_bits = memLevel + 7,
                s.hash_size = 1 << s.hash_bits,
                s.hash_mask = s.hash_size - 1,
                s.hash_shift = ~~((s.hash_bits + 3 - 1) / 3),
                s.window = new Uint8Array(2 * s.w_size),
                s.head = new Uint16Array(s.hash_size),
                s.prev = new Uint16Array(s.w_size),
                s.lit_bufsize = 1 << memLevel + 6,
                s.pending_buf_size = 4 * s.lit_bufsize,
                s.pending_buf = new Uint8Array(s.pending_buf_size),
                s.sym_buf = s.lit_bufsize,
                s.sym_end = 3 * (s.lit_bufsize - 1),
                s.level = level,
                s.strategy = strategy,
                s.method = method,
                deflateReset(strm)
            }
            ;
            module.exports.deflateInit = (strm,level)=>deflateInit2(strm, level, Z_DEFLATED, 15, 8, Z_DEFAULT_STRATEGY),
            module.exports.deflateInit2 = deflateInit2,
            module.exports.deflateReset = deflateReset,
            module.exports.deflateResetKeep = deflateResetKeep,
            module.exports.deflateSetHeader = (strm,head)=>deflateStateCheck(strm) || 2 !== strm.state.wrap ? Z_STREAM_ERROR : (strm.state.gzhead = head,
            Z_OK),
            module.exports.deflate = (strm,flush)=>{
                if (deflateStateCheck(strm) || flush > Z_BLOCK || flush < 0)
                    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
                const s = strm.state;
                if (!strm.output || 0 !== strm.avail_in && !strm.input || 666 === s.status && flush !== Z_FINISH)
                    return err(strm, 0 === strm.avail_out ? Z_BUF_ERROR : Z_STREAM_ERROR);
                const old_flush = s.last_flush;
                if (s.last_flush = flush,
                0 !== s.pending) {
                    if (flush_pending(strm),
                    0 === strm.avail_out)
                        return s.last_flush = -1,
                        Z_OK
                } else if (0 === strm.avail_in && rank(flush) <= rank(old_flush) && flush !== Z_FINISH)
                    return err(strm, Z_BUF_ERROR);
                if (666 === s.status && 0 !== strm.avail_in)
                    return err(strm, Z_BUF_ERROR);
                if (42 === s.status && 0 === s.wrap && (s.status = 113),
                42 === s.status) {
                    let header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8
                      , level_flags = -1;
                    if (level_flags = s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 0 : s.level < 6 ? 1 : 6 === s.level ? 2 : 3,
                    header |= level_flags << 6,
                    0 !== s.strstart && (header |= 32),
                    header += 31 - header % 31,
                    putShortMSB(s, header),
                    0 !== s.strstart && (putShortMSB(s, strm.adler >>> 16),
                    putShortMSB(s, 65535 & strm.adler)),
                    strm.adler = 1,
                    s.status = 113,
                    flush_pending(strm),
                    0 !== s.pending)
                        return s.last_flush = -1,
                        Z_OK
                }
                if (57 === s.status)
                    if (strm.adler = 0,
                    put_byte(s, 31),
                    put_byte(s, 139),
                    put_byte(s, 8),
                    s.gzhead)
                        put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (s.gzhead.extra ? 4 : 0) + (s.gzhead.name ? 8 : 0) + (s.gzhead.comment ? 16 : 0)),
                        put_byte(s, 255 & s.gzhead.time),
                        put_byte(s, s.gzhead.time >> 8 & 255),
                        put_byte(s, s.gzhead.time >> 16 & 255),
                        put_byte(s, s.gzhead.time >> 24 & 255),
                        put_byte(s, 9 === s.level ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0),
                        put_byte(s, 255 & s.gzhead.os),
                        s.gzhead.extra && s.gzhead.extra.length && (put_byte(s, 255 & s.gzhead.extra.length),
                        put_byte(s, s.gzhead.extra.length >> 8 & 255)),
                        s.gzhead.hcrc && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0)),
                        s.gzindex = 0,
                        s.status = 69;
                    else if (put_byte(s, 0),
                    put_byte(s, 0),
                    put_byte(s, 0),
                    put_byte(s, 0),
                    put_byte(s, 0),
                    put_byte(s, 9 === s.level ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0),
                    put_byte(s, 3),
                    s.status = 113,
                    flush_pending(strm),
                    0 !== s.pending)
                        return s.last_flush = -1,
                        Z_OK;
                if (69 === s.status) {
                    if (s.gzhead.extra) {
                        let beg = s.pending
                          , left = (65535 & s.gzhead.extra.length) - s.gzindex;
                        for (; s.pending + left > s.pending_buf_size; ) {
                            let copy = s.pending_buf_size - s.pending;
                            if (s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending),
                            s.pending = s.pending_buf_size,
                            s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)),
                            s.gzindex += copy,
                            flush_pending(strm),
                            0 !== s.pending)
                                return s.last_flush = -1,
                                Z_OK;
                            beg = 0,
                            left -= copy
                        }
                        let gzhead_extra = new Uint8Array(s.gzhead.extra);
                        s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending),
                        s.pending += left,
                        s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)),
                        s.gzindex = 0
                    }
                    s.status = 73
                }
                if (73 === s.status) {
                    if (s.gzhead.name) {
                        let val, beg = s.pending;
                        do {
                            if (s.pending === s.pending_buf_size) {
                                if (s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)),
                                flush_pending(strm),
                                0 !== s.pending)
                                    return s.last_flush = -1,
                                    Z_OK;
                                beg = 0
                            }
                            val = s.gzindex < s.gzhead.name.length ? 255 & s.gzhead.name.charCodeAt(s.gzindex++) : 0,
                            put_byte(s, val)
                        } while (0 !== val);
                        s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)),
                        s.gzindex = 0
                    }
                    s.status = 91
                }
                if (91 === s.status) {
                    if (s.gzhead.comment) {
                        let val, beg = s.pending;
                        do {
                            if (s.pending === s.pending_buf_size) {
                                if (s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)),
                                flush_pending(strm),
                                0 !== s.pending)
                                    return s.last_flush = -1,
                                    Z_OK;
                                beg = 0
                            }
                            val = s.gzindex < s.gzhead.comment.length ? 255 & s.gzhead.comment.charCodeAt(s.gzindex++) : 0,
                            put_byte(s, val)
                        } while (0 !== val);
                        s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg))
                    }
                    s.status = 103
                }
                if (103 === s.status) {
                    if (s.gzhead.hcrc) {
                        if (s.pending + 2 > s.pending_buf_size && (flush_pending(strm),
                        0 !== s.pending))
                            return s.last_flush = -1,
                            Z_OK;
                        put_byte(s, 255 & strm.adler),
                        put_byte(s, strm.adler >> 8 & 255),
                        strm.adler = 0
                    }
                    if (s.status = 113,
                    flush_pending(strm),
                    0 !== s.pending)
                        return s.last_flush = -1,
                        Z_OK
                }
                if (0 !== strm.avail_in || 0 !== s.lookahead || flush !== Z_NO_FLUSH && 666 !== s.status) {
                    let bstate = 0 === s.level ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? ((s,flush)=>{
                        let bflush;
                        for (; ; ) {
                            if (0 === s.lookahead && (fill_window(s),
                            0 === s.lookahead)) {
                                if (flush === Z_NO_FLUSH)
                                    return 1;
                                break
                            }
                            if (s.match_length = 0,
                            bflush = _tr_tally(s, 0, s.window[s.strstart]),
                            s.lookahead--,
                            s.strstart++,
                            bflush && (flush_block_only(s, !1),
                            0 === s.strm.avail_out))
                                return 1
                        }
                        return s.insert = 0,
                        flush === Z_FINISH ? (flush_block_only(s, !0),
                        0 === s.strm.avail_out ? 3 : 4) : s.sym_next && (flush_block_only(s, !1),
                        0 === s.strm.avail_out) ? 1 : 2
                    }
                    )(s, flush) : s.strategy === Z_RLE ? ((s,flush)=>{
                        let bflush, prev, scan, strend;
                        const _win = s.window;
                        for (; ; ) {
                            if (s.lookahead <= 258) {
                                if (fill_window(s),
                                s.lookahead <= 258 && flush === Z_NO_FLUSH)
                                    return 1;
                                if (0 === s.lookahead)
                                    break
                            }
                            if (s.match_length = 0,
                            s.lookahead >= 3 && s.strstart > 0 && (scan = s.strstart - 1,
                            prev = _win[scan],
                            prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan])) {
                                strend = s.strstart + 258;
                                do {} while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
                                s.match_length = 258 - (strend - scan),
                                s.match_length > s.lookahead && (s.match_length = s.lookahead)
                            }
                            if (s.match_length >= 3 ? (bflush = _tr_tally(s, 1, s.match_length - 3),
                            s.lookahead -= s.match_length,
                            s.strstart += s.match_length,
                            s.match_length = 0) : (bflush = _tr_tally(s, 0, s.window[s.strstart]),
                            s.lookahead--,
                            s.strstart++),
                            bflush && (flush_block_only(s, !1),
                            0 === s.strm.avail_out))
                                return 1
                        }
                        return s.insert = 0,
                        flush === Z_FINISH ? (flush_block_only(s, !0),
                        0 === s.strm.avail_out ? 3 : 4) : s.sym_next && (flush_block_only(s, !1),
                        0 === s.strm.avail_out) ? 1 : 2
                    }
                    )(s, flush) : configuration_table[s.level].func(s, flush);
                    if (3 !== bstate && 4 !== bstate || (s.status = 666),
                    1 === bstate || 3 === bstate)
                        return 0 === strm.avail_out && (s.last_flush = -1),
                        Z_OK;
                    if (2 === bstate && (flush === Z_PARTIAL_FLUSH ? _tr_align(s) : flush !== Z_BLOCK && (_tr_stored_block(s, 0, 0, !1),
                    flush === Z_FULL_FLUSH && (zero(s.head),
                    0 === s.lookahead && (s.strstart = 0,
                    s.block_start = 0,
                    s.insert = 0))),
                    flush_pending(strm),
                    0 === strm.avail_out))
                        return s.last_flush = -1,
                        Z_OK
                }
                return flush !== Z_FINISH ? Z_OK : s.wrap <= 0 ? Z_STREAM_END : (2 === s.wrap ? (put_byte(s, 255 & strm.adler),
                put_byte(s, strm.adler >> 8 & 255),
                put_byte(s, strm.adler >> 16 & 255),
                put_byte(s, strm.adler >> 24 & 255),
                put_byte(s, 255 & strm.total_in),
                put_byte(s, strm.total_in >> 8 & 255),
                put_byte(s, strm.total_in >> 16 & 255),
                put_byte(s, strm.total_in >> 24 & 255)) : (putShortMSB(s, strm.adler >>> 16),
                putShortMSB(s, 65535 & strm.adler)),
                flush_pending(strm),
                s.wrap > 0 && (s.wrap = -s.wrap),
                0 !== s.pending ? Z_OK : Z_STREAM_END)
            }
            ,
            module.exports.deflateEnd = strm=>{
                if (deflateStateCheck(strm))
                    return Z_STREAM_ERROR;
                const status = strm.state.status;
                return strm.state = null,
                113 === status ? err(strm, Z_DATA_ERROR) : Z_OK
            }
            ,
            module.exports.deflateSetDictionary = (strm,dictionary)=>{
                let dictLength = dictionary.length;
                if (deflateStateCheck(strm))
                    return Z_STREAM_ERROR;
                const s = strm.state
                  , wrap = s.wrap;
                if (2 === wrap || 1 === wrap && 42 !== s.status || s.lookahead)
                    return Z_STREAM_ERROR;
                if (1 === wrap && (strm.adler = adler32(strm.adler, dictionary, dictLength, 0)),
                s.wrap = 0,
                dictLength >= s.w_size) {
                    0 === wrap && (zero(s.head),
                    s.strstart = 0,
                    s.block_start = 0,
                    s.insert = 0);
                    let tmpDict = new Uint8Array(s.w_size);
                    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0),
                    dictionary = tmpDict,
                    dictLength = s.w_size
                }
                const avail = strm.avail_in
                  , next = strm.next_in
                  , input = strm.input;
                for (strm.avail_in = dictLength,
                strm.next_in = 0,
                strm.input = dictionary,
                fill_window(s); s.lookahead >= 3; ) {
                    let str = s.strstart
                      , n = s.lookahead - 2;
                    do {
                        s.ins_h = HASH(s, s.ins_h, s.window[str + 3 - 1]),
                        s.prev[str & s.w_mask] = s.head[s.ins_h],
                        s.head[s.ins_h] = str,
                        str++
                    } while (--n);
                    s.strstart = str,
                    s.lookahead = 2,
                    fill_window(s)
                }
                return s.strstart += s.lookahead,
                s.block_start = s.strstart,
                s.insert = s.lookahead,
                s.lookahead = 0,
                s.match_length = s.prev_length = 2,
                s.match_available = 0,
                strm.next_in = next,
                strm.input = input,
                strm.avail_in = avail,
                s.wrap = wrap,
                Z_OK
            }
            ,
            module.exports.deflateInfo = "pako deflate (from Nodeca project)"
        }
        ,
        83734: module=>{
            "use strict";
            module.exports = function() {
                this.text = 0,
                this.time = 0,
                this.xflags = 0,
                this.os = 0,
                this.extra = null,
                this.extra_len = 0,
                this.name = "",
                this.comment = "",
                this.hcrc = 0,
                this.done = !1
            }
        }
        ,
        75614: module=>{
            "use strict";
            module.exports = function(strm, start) {
                let _in, last, _out, beg, end, dmax, wsize, whave, wnext, s_window, hold, bits, lcode, dcode, lmask, dmask, here, op, len, dist, from, from_source, input, output;
                const state = strm.state;
                _in = strm.next_in,
                input = strm.input,
                last = _in + (strm.avail_in - 5),
                _out = strm.next_out,
                output = strm.output,
                beg = _out - (start - strm.avail_out),
                end = _out + (strm.avail_out - 257),
                dmax = state.dmax,
                wsize = state.wsize,
                whave = state.whave,
                wnext = state.wnext,
                s_window = state.window,
                hold = state.hold,
                bits = state.bits,
                lcode = state.lencode,
                dcode = state.distcode,
                lmask = (1 << state.lenbits) - 1,
                dmask = (1 << state.distbits) - 1;
                top: do {
                    bits < 15 && (hold += input[_in++] << bits,
                    bits += 8,
                    hold += input[_in++] << bits,
                    bits += 8),
                    here = lcode[hold & lmask];
                    dolen: for (; ; ) {
                        if (op = here >>> 24,
                        hold >>>= op,
                        bits -= op,
                        op = here >>> 16 & 255,
                        0 === op)
                            output[_out++] = 65535 & here;
                        else {
                            if (!(16 & op)) {
                                if (0 == (64 & op)) {
                                    here = lcode[(65535 & here) + (hold & (1 << op) - 1)];
                                    continue dolen
                                }
                                if (32 & op) {
                                    state.mode = 16191;
                                    break top
                                }
                                strm.msg = "invalid literal/length code",
                                state.mode = 16209;
                                break top
                            }
                            len = 65535 & here,
                            op &= 15,
                            op && (bits < op && (hold += input[_in++] << bits,
                            bits += 8),
                            len += hold & (1 << op) - 1,
                            hold >>>= op,
                            bits -= op),
                            bits < 15 && (hold += input[_in++] << bits,
                            bits += 8,
                            hold += input[_in++] << bits,
                            bits += 8),
                            here = dcode[hold & dmask];
                            dodist: for (; ; ) {
                                if (op = here >>> 24,
                                hold >>>= op,
                                bits -= op,
                                op = here >>> 16 & 255,
                                !(16 & op)) {
                                    if (0 == (64 & op)) {
                                        here = dcode[(65535 & here) + (hold & (1 << op) - 1)];
                                        continue dodist
                                    }
                                    strm.msg = "invalid distance code",
                                    state.mode = 16209;
                                    break top
                                }
                                if (dist = 65535 & here,
                                op &= 15,
                                bits < op && (hold += input[_in++] << bits,
                                bits += 8,
                                bits < op && (hold += input[_in++] << bits,
                                bits += 8)),
                                dist += hold & (1 << op) - 1,
                                dist > dmax) {
                                    strm.msg = "invalid distance too far back",
                                    state.mode = 16209;
                                    break top
                                }
                                if (hold >>>= op,
                                bits -= op,
                                op = _out - beg,
                                dist > op) {
                                    if (op = dist - op,
                                    op > whave && state.sane) {
                                        strm.msg = "invalid distance too far back",
                                        state.mode = 16209;
                                        break top
                                    }
                                    if (from = 0,
                                    from_source = s_window,
                                    0 === wnext) {
                                        if (from += wsize - op,
                                        op < len) {
                                            len -= op;
                                            do {
                                                output[_out++] = s_window[from++]
                                            } while (--op);
                                            from = _out - dist,
                                            from_source = output
                                        }
                                    } else if (wnext < op) {
                                        if (from += wsize + wnext - op,
                                        op -= wnext,
                                        op < len) {
                                            len -= op;
                                            do {
                                                output[_out++] = s_window[from++]
                                            } while (--op);
                                            if (from = 0,
                                            wnext < len) {
                                                op = wnext,
                                                len -= op;
                                                do {
                                                    output[_out++] = s_window[from++]
                                                } while (--op);
                                                from = _out - dist,
                                                from_source = output
                                            }
                                        }
                                    } else if (from += wnext - op,
                                    op < len) {
                                        len -= op;
                                        do {
                                            output[_out++] = s_window[from++]
                                        } while (--op);
                                        from = _out - dist,
                                        from_source = output
                                    }
                                    for (; len > 2; )
                                        output[_out++] = from_source[from++],
                                        output[_out++] = from_source[from++],
                                        output[_out++] = from_source[from++],
                                        len -= 3;
                                    len && (output[_out++] = from_source[from++],
                                    len > 1 && (output[_out++] = from_source[from++]))
                                } else {
                                    from = _out - dist;
                                    do {
                                        output[_out++] = output[from++],
                                        output[_out++] = output[from++],
                                        output[_out++] = output[from++],
                                        len -= 3
                                    } while (len > 2);
                                    len && (output[_out++] = output[from++],
                                    len > 1 && (output[_out++] = output[from++]))
                                }
                                break
                            }
                        }
                        break
                    }
                } while (_in < last && _out < end);
                len = bits >> 3,
                _in -= len,
                bits -= len << 3,
                hold &= (1 << bits) - 1,
                strm.next_in = _in,
                strm.next_out = _out,
                strm.avail_in = _in < last ? last - _in + 5 : 5 - (_in - last),
                strm.avail_out = _out < end ? end - _out + 257 : 257 - (_out - end),
                state.hold = hold,
                state.bits = bits
            }
        }
        ,
        36453: (module,__unused_webpack_exports,__webpack_require__)=>{
            "use strict";
            const adler32 = __webpack_require__(71926)
              , crc32 = __webpack_require__(35122)
              , inflate_fast = __webpack_require__(75614)
              , inflate_table = __webpack_require__(82418)
              , {Z_FINISH, Z_BLOCK, Z_TREES, Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR, Z_BUF_ERROR, Z_DEFLATED} = __webpack_require__(89605)
              , BAD = 16209
              , zswap32 = q=>(q >>> 24 & 255) + (q >>> 8 & 65280) + ((65280 & q) << 8) + ((255 & q) << 24);
            function InflateState() {
                this.strm = null,
                this.mode = 0,
                this.last = !1,
                this.wrap = 0,
                this.havedict = !1,
                this.flags = 0,
                this.dmax = 0,
                this.check = 0,
                this.total = 0,
                this.head = null,
                this.wbits = 0,
                this.wsize = 0,
                this.whave = 0,
                this.wnext = 0,
                this.window = null,
                this.hold = 0,
                this.bits = 0,
                this.length = 0,
                this.offset = 0,
                this.extra = 0,
                this.lencode = null,
                this.distcode = null,
                this.lenbits = 0,
                this.distbits = 0,
                this.ncode = 0,
                this.nlen = 0,
                this.ndist = 0,
                this.have = 0,
                this.next = null,
                this.lens = new Uint16Array(320),
                this.work = new Uint16Array(288),
                this.lendyn = null,
                this.distdyn = null,
                this.sane = 0,
                this.back = 0,
                this.was = 0
            }
            const inflateStateCheck = strm=>{
                if (!strm)
                    return 1;
                const state = strm.state;
                return !state || state.strm !== strm || state.mode < 16180 || state.mode > 16211 ? 1 : 0
            }
              , inflateResetKeep = strm=>{
                if (inflateStateCheck(strm))
                    return Z_STREAM_ERROR;
                const state = strm.state;
                return strm.total_in = strm.total_out = state.total = 0,
                strm.msg = "",
                state.wrap && (strm.adler = 1 & state.wrap),
                state.mode = 16180,
                state.last = 0,
                state.havedict = 0,
                state.flags = -1,
                state.dmax = 32768,
                state.head = null,
                state.hold = 0,
                state.bits = 0,
                state.lencode = state.lendyn = new Int32Array(852),
                state.distcode = state.distdyn = new Int32Array(592),
                state.sane = 1,
                state.back = -1,
                Z_OK
            }
              , inflateReset = strm=>{
                if (inflateStateCheck(strm))
                    return Z_STREAM_ERROR;
                const state = strm.state;
                return state.wsize = 0,
                state.whave = 0,
                state.wnext = 0,
                inflateResetKeep(strm)
            }
              , inflateReset2 = (strm,windowBits)=>{
                let wrap;
                if (inflateStateCheck(strm))
                    return Z_STREAM_ERROR;
                const state = strm.state;
                return windowBits < 0 ? (wrap = 0,
                windowBits = -windowBits) : (wrap = 5 + (windowBits >> 4),
                windowBits < 48 && (windowBits &= 15)),
                windowBits && (windowBits < 8 || windowBits > 15) ? Z_STREAM_ERROR : (null !== state.window && state.wbits !== windowBits && (state.window = null),
                state.wrap = wrap,
                state.wbits = windowBits,
                inflateReset(strm))
            }
              , inflateInit2 = (strm,windowBits)=>{
                if (!strm)
                    return Z_STREAM_ERROR;
                const state = new InflateState;
                strm.state = state,
                state.strm = strm,
                state.window = null,
                state.mode = 16180;
                const ret = inflateReset2(strm, windowBits);
                return ret !== Z_OK && (strm.state = null),
                ret
            }
            ;
            let lenfix, distfix, virgin = !0;
            const fixedtables = state=>{
                if (virgin) {
                    lenfix = new Int32Array(512),
                    distfix = new Int32Array(32);
                    let sym = 0;
                    for (; sym < 144; )
                        state.lens[sym++] = 8;
                    for (; sym < 256; )
                        state.lens[sym++] = 9;
                    for (; sym < 280; )
                        state.lens[sym++] = 7;
                    for (; sym < 288; )
                        state.lens[sym++] = 8;
                    for (inflate_table(1, state.lens, 0, 288, lenfix, 0, state.work, {
                        bits: 9
                    }),
                    sym = 0; sym < 32; )
                        state.lens[sym++] = 5;
                    inflate_table(2, state.lens, 0, 32, distfix, 0, state.work, {
                        bits: 5
                    }),
                    virgin = !1
                }
                state.lencode = lenfix,
                state.lenbits = 9,
                state.distcode = distfix,
                state.distbits = 5
            }
              , updatewindow = (strm,src,end,copy)=>{
                let dist;
                const state = strm.state;
                return null === state.window && (state.wsize = 1 << state.wbits,
                state.wnext = 0,
                state.whave = 0,
                state.window = new Uint8Array(state.wsize)),
                copy >= state.wsize ? (state.window.set(src.subarray(end - state.wsize, end), 0),
                state.wnext = 0,
                state.whave = state.wsize) : (dist = state.wsize - state.wnext,
                dist > copy && (dist = copy),
                state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext),
                (copy -= dist) ? (state.window.set(src.subarray(end - copy, end), 0),
                state.wnext = copy,
                state.whave = state.wsize) : (state.wnext += dist,
                state.wnext === state.wsize && (state.wnext = 0),
                state.whave < state.wsize && (state.whave += dist))),
                0
            }
            ;
            module.exports.inflateReset = inflateReset,
            module.exports.inflateReset2 = inflateReset2,
            module.exports.inflateResetKeep = inflateResetKeep,
            module.exports.inflateInit = strm=>inflateInit2(strm, 15),
            module.exports.inflateInit2 = inflateInit2,
            module.exports.inflate = (strm,flush)=>{
                let state, input, output, next, put, have, left, hold, bits, _in, _out, copy, from, from_source, here_bits, here_op, here_val, last_bits, last_op, last_val, len, ret, here = 0;
                const hbuf = new Uint8Array(4);
                let opts, n;
                const order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
                if (inflateStateCheck(strm) || !strm.output || !strm.input && 0 !== strm.avail_in)
                    return Z_STREAM_ERROR;
                state = strm.state,
                16191 === state.mode && (state.mode = 16192),
                put = strm.next_out,
                output = strm.output,
                left = strm.avail_out,
                next = strm.next_in,
                input = strm.input,
                have = strm.avail_in,
                hold = state.hold,
                bits = state.bits,
                _in = have,
                _out = left,
                ret = Z_OK;
                inf_leave: for (; ; )
                    switch (state.mode) {
                    case 16180:
                        if (0 === state.wrap) {
                            state.mode = 16192;
                            break
                        }
                        for (; bits < 16; ) {
                            if (0 === have)
                                break inf_leave;
                            have--,
                            hold += input[next++] << bits,
                            bits += 8
                        }
                        if (2 & state.wrap && 35615 === hold) {
                            0 === state.wbits && (state.wbits = 15),
                            state.check = 0,
                            hbuf[0] = 255 & hold,
                            hbuf[1] = hold >>> 8 & 255,
                            state.check = crc32(state.check, hbuf, 2, 0),
                            hold = 0,
                            bits = 0,
                            state.mode = 16181;
                            break
                        }
                        if (state.head && (state.head.done = !1),
                        !(1 & state.wrap) || (((255 & hold) << 8) + (hold >> 8)) % 31) {
                            strm.msg = "incorrect header check",
                            state.mode = BAD;
                            break
                        }
                        if ((15 & hold) !== Z_DEFLATED) {
                            strm.msg = "unknown compression method",
                            state.mode = BAD;
                            break
                        }
                        if (hold >>>= 4,
                        bits -= 4,
                        len = 8 + (15 & hold),
                        0 === state.wbits && (state.wbits = len),
                        len > 15 || len > state.wbits) {
                            strm.msg = "invalid window size",
                            state.mode = BAD;
                            break
                        }
                        state.dmax = 1 << state.wbits,
                        state.flags = 0,
                        strm.adler = state.check = 1,
                        state.mode = 512 & hold ? 16189 : 16191,
                        hold = 0,
                        bits = 0;
                        break;
                    case 16181:
                        for (; bits < 16; ) {
                            if (0 === have)
                                break inf_leave;
                            have--,
                            hold += input[next++] << bits,
                            bits += 8
                        }
                        if (state.flags = hold,
                        (255 & state.flags) !== Z_DEFLATED) {
                            strm.msg = "unknown compression method",
                            state.mode = BAD;
                            break
                        }
                        if (57344 & state.flags) {
                            strm.msg = "unknown header flags set",
                            state.mode = BAD;
                            break
                        }
                        state.head && (state.head.text = hold >> 8 & 1),
                        512 & state.flags && 4 & state.wrap && (hbuf[0] = 255 & hold,
                        hbuf[1] = hold >>> 8 & 255,
                        state.check = crc32(state.check, hbuf, 2, 0)),
                        hold = 0,
                        bits = 0,
                        state.mode = 16182;
                    case 16182:
                        for (; bits < 32; ) {
                            if (0 === have)
                                break inf_leave;
                            have--,
                            hold += input[next++] << bits,
                            bits += 8
                        }
                        state.head && (state.head.time = hold),
                        512 & state.flags && 4 & state.wrap && (hbuf[0] = 255 & hold,
                        hbuf[1] = hold >>> 8 & 255,
                        hbuf[2] = hold >>> 16 & 255,
                        hbuf[3] = hold >>> 24 & 255,
                        state.check = crc32(state.check, hbuf, 4, 0)),
                        hold = 0,
                        bits = 0,
                        state.mode = 16183;
                    case 16183:
                        for (; bits < 16; ) {
                            if (0 === have)
                                break inf_leave;
                            have--,
                            hold += input[next++] << bits,
                            bits += 8
                        }
                        state.head && (state.head.xflags = 255 & hold,
                        state.head.os = hold >> 8),
                        512 & state.flags && 4 & state.wrap && (hbuf[0] = 255 & hold,
                        hbuf[1] = hold >>> 8 & 255,
                        state.check = crc32(state.check, hbuf, 2, 0)),
                        hold = 0,
                        bits = 0,
                        state.mode = 16184;
                    case 16184:
                        if (1024 & state.flags) {
                            for (; bits < 16; ) {
                                if (0 === have)
                                    break inf_leave;
                                have--,
                                hold += input[next++] << bits,
                                bits += 8
                            }
                            state.length = hold,
                            state.head && (state.head.extra_len = hold),
                            512 & state.flags && 4 & state.wrap && (hbuf[0] = 255 & hold,
                            hbuf[1] = hold >>> 8 & 255,
                            state.check = crc32(state.check, hbuf, 2, 0)),
                            hold = 0,
                            bits = 0
                        } else
                            state.head && (state.head.extra = null);
                        state.mode = 16185;
                    case 16185:
                        if (1024 & state.flags && (copy = state.length,
                        copy > have && (copy = have),
                        copy && (state.head && (len = state.head.extra_len - state.length,
                        state.head.extra || (state.head.extra = new Uint8Array(state.head.extra_len)),
                        state.head.extra.set(input.subarray(next, next + copy), len)),
                        512 & state.flags && 4 & state.wrap && (state.check = crc32(state.check, input, copy, next)),
                        have -= copy,
                        next += copy,
                        state.length -= copy),
                        state.length))
                            break inf_leave;
                        state.length = 0,
                        state.mode = 16186;
                    case 16186:
                        if (2048 & state.flags) {
                            if (0 === have)
                                break inf_leave;
                            copy = 0;
                            do {
                                len = input[next + copy++],
                                state.head && len && state.length < 65536 && (state.head.name += String.fromCharCode(len))
                            } while (len && copy < have);
                            if (512 & state.flags && 4 & state.wrap && (state.check = crc32(state.check, input, copy, next)),
                            have -= copy,
                            next += copy,
                            len)
                                break inf_leave
                        } else
                            state.head && (state.head.name = null);
                        state.length = 0,
                        state.mode = 16187;
                    case 16187:
                        if (4096 & state.flags) {
                            if (0 === have)
                                break inf_leave;
                            copy = 0;
                            do {
                                len = input[next + copy++],
                                state.head && len && state.length < 65536 && (state.head.comment += String.fromCharCode(len))
                            } while (len && copy < have);
                            if (512 & state.flags && 4 & state.wrap && (state.check = crc32(state.check, input, copy, next)),
                            have -= copy,
                            next += copy,
                            len)
                                break inf_leave
                        } else
                            state.head && (state.head.comment = null);
                        state.mode = 16188;
                    case 16188:
                        if (512 & state.flags) {
                            for (; bits < 16; ) {
                                if (0 === have)
                                    break inf_leave;
                                have--,
                                hold += input[next++] << bits,
                                bits += 8
                            }
                            if (4 & state.wrap && hold !== (65535 & state.check)) {
                                strm.msg = "header crc mismatch",
                                state.mode = BAD;
                                break
                            }
                            hold = 0,
                            bits = 0
                        }
                        state.head && (state.head.hcrc = state.flags >> 9 & 1,
                        state.head.done = !0),
                        strm.adler = state.check = 0,
                        state.mode = 16191;
                        break;
                    case 16189:
                        for (; bits < 32; ) {
                            if (0 === have)
                                break inf_leave;
                            have--,
                            hold += input[next++] << bits,
                            bits += 8
                        }
                        strm.adler = state.check = zswap32(hold),
                        hold = 0,
                        bits = 0,
                        state.mode = 16190;
                    case 16190:
                        if (0 === state.havedict)
                            return strm.next_out = put,
                            strm.avail_out = left,
                            strm.next_in = next,
                            strm.avail_in = have,
                            state.hold = hold,
                            state.bits = bits,
                            Z_NEED_DICT;
                        strm.adler = state.check = 1,
                        state.mode = 16191;
                    case 16191:
                        if (flush === Z_BLOCK || flush === Z_TREES)
                            break inf_leave;
                    case 16192:
                        if (state.last) {
                            hold >>>= 7 & bits,
                            bits -= 7 & bits,
                            state.mode = 16206;
                            break
                        }
                        for (; bits < 3; ) {
                            if (0 === have)
                                break inf_leave;
                            have--,
                            hold += input[next++] << bits,
                            bits += 8
                        }
                        switch (state.last = 1 & hold,
                        hold >>>= 1,
                        bits -= 1,
                        3 & hold) {
                        case 0:
                            state.mode = 16193;
                            break;
                        case 1:
                            if (fixedtables(state),
                            state.mode = 16199,
                            flush === Z_TREES) {
                                hold >>>= 2,
                                bits -= 2;
                                break inf_leave
                            }
                            break;
                        case 2:
                            state.mode = 16196;
                            break;
                        case 3:
                            strm.msg = "invalid block type",
                            state.mode = BAD
                        }
                        hold >>>= 2,
                        bits -= 2;
                        break;
                    case 16193:
                        for (hold >>>= 7 & bits,
                        bits -= 7 & bits; bits < 32; ) {
                            if (0 === have)
                                break inf_leave;
                            have--,
                            hold += input[next++] << bits,
                            bits += 8
                        }
                        if ((65535 & hold) != (hold >>> 16 ^ 65535)) {
                            strm.msg = "invalid stored block lengths",
                            state.mode = BAD;
                            break
                        }
                        if (state.length = 65535 & hold,
                        hold = 0,
                        bits = 0,
                        state.mode = 16194,
                        flush === Z_TREES)
                            break inf_leave;
                    case 16194:
                        state.mode = 16195;
                    case 16195:
                        if (copy = state.length,
                        copy) {
                            if (copy > have && (copy = have),
                            copy > left && (copy = left),
                            0 === copy)
                                break inf_leave;
                            output.set(input.subarray(next, next + copy), put),
                            have -= copy,
                            next += copy,
                            left -= copy,
                            put += copy,
                            state.length -= copy;
                            break
                        }
                        state.mode = 16191;
                        break;
                    case 16196:
                        for (; bits < 14; ) {
                            if (0 === have)
                                break inf_leave;
                            have--,
                            hold += input[next++] << bits,
                            bits += 8
                        }
                        if (state.nlen = 257 + (31 & hold),
                        hold >>>= 5,
                        bits -= 5,
                        state.ndist = 1 + (31 & hold),
                        hold >>>= 5,
                        bits -= 5,
                        state.ncode = 4 + (15 & hold),
                        hold >>>= 4,
                        bits -= 4,
                        state.nlen > 286 || state.ndist > 30) {
                            strm.msg = "too many length or distance symbols",
                            state.mode = BAD;
                            break
                        }
                        state.have = 0,
                        state.mode = 16197;
                    case 16197:
                        for (; state.have < state.ncode; ) {
                            for (; bits < 3; ) {
                                if (0 === have)
                                    break inf_leave;
                                have--,
                                hold += input[next++] << bits,
                                bits += 8
                            }
                            state.lens[order[state.have++]] = 7 & hold,
                            hold >>>= 3,
                            bits -= 3
                        }
                        for (; state.have < 19; )
                            state.lens[order[state.have++]] = 0;
                        if (state.lencode = state.lendyn,
                        state.lenbits = 7,
                        opts = {
                            bits: state.lenbits
                        },
                        ret = inflate_table(0, state.lens, 0, 19, state.lencode, 0, state.work, opts),
                        state.lenbits = opts.bits,
                        ret) {
                            strm.msg = "invalid code lengths set",
                            state.mode = BAD;
                            break
                        }
                        state.have = 0,
                        state.mode = 16198;
                    case 16198:
                        for (; state.have < state.nlen + state.ndist; ) {
                            for (; here = state.lencode[hold & (1 << state.lenbits) - 1],
                            here_bits = here >>> 24,
                            here_op = here >>> 16 & 255,
                            here_val = 65535 & here,
                            !(here_bits <= bits); ) {
                                if (0 === have)
                                    break inf_leave;
                                have--,
                                hold += input[next++] << bits,
                                bits += 8
                            }
                            if (here_val < 16)
                                hold >>>= here_bits,
                                bits -= here_bits,
                                state.lens[state.have++] = here_val;
                            else {
                                if (16 === here_val) {
                                    for (n = here_bits + 2; bits < n; ) {
                                        if (0 === have)
                                            break inf_leave;
                                        have--,
                                        hold += input[next++] << bits,
                                        bits += 8
                                    }
                                    if (hold >>>= here_bits,
                                    bits -= here_bits,
                                    0 === state.have) {
                                        strm.msg = "invalid bit length repeat",
                                        state.mode = BAD;
                                        break
                                    }
                                    len = state.lens[state.have - 1],
                                    copy = 3 + (3 & hold),
                                    hold >>>= 2,
                                    bits -= 2
                                } else if (17 === here_val) {
                                    for (n = here_bits + 3; bits < n; ) {
                                        if (0 === have)
                                            break inf_leave;
                                        have--,
                                        hold += input[next++] << bits,
                                        bits += 8
                                    }
                                    hold >>>= here_bits,
                                    bits -= here_bits,
                                    len = 0,
                                    copy = 3 + (7 & hold),
                                    hold >>>= 3,
                                    bits -= 3
                                } else {
                                    for (n = here_bits + 7; bits < n; ) {
                                        if (0 === have)
                                            break inf_leave;
                                        have--,
                                        hold += input[next++] << bits,
                                        bits += 8
                                    }
                                    hold >>>= here_bits,
                                    bits -= here_bits,
                                    len = 0,
                                    copy = 11 + (127 & hold),
                                    hold >>>= 7,
                                    bits -= 7
                                }
                                if (state.have + copy > state.nlen + state.ndist) {
                                    strm.msg = "invalid bit length repeat",
                                    state.mode = BAD;
                                    break
                                }
                                for (; copy--; )
                                    state.lens[state.have++] = len
                            }
                        }
                        if (state.mode === BAD)
                            break;
                        if (0 === state.lens[256]) {
                            strm.msg = "invalid code -- missing end-of-block",
                            state.mode = BAD;
                            break
                        }
                        if (state.lenbits = 9,
                        opts = {
                            bits: state.lenbits
                        },
                        ret = inflate_table(1, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts),
                        state.lenbits = opts.bits,
                        ret) {
                            strm.msg = "invalid literal/lengths set",
                            state.mode = BAD;
                            break
                        }
                        if (state.distbits = 6,
                        state.distcode = state.distdyn,
                        opts = {
                            bits: state.distbits
                        },
                        ret = inflate_table(2, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts),
                        state.distbits = opts.bits,
                        ret) {
                            strm.msg = "invalid distances set",
                            state.mode = BAD;
                            break
                        }
                        if (state.mode = 16199,
                        flush === Z_TREES)
                            break inf_leave;
                    case 16199:
                        state.mode = 16200;
                    case 16200:
                        if (have >= 6 && left >= 258) {
                            strm.next_out = put,
                            strm.avail_out = left,
                            strm.next_in = next,
                            strm.avail_in = have,
                            state.hold = hold,
                            state.bits = bits,
                            inflate_fast(strm, _out),
                            put = strm.next_out,
                            output = strm.output,
                            left = strm.avail_out,
                            next = strm.next_in,
                            input = strm.input,
                            have = strm.avail_in,
                            hold = state.hold,
                            bits = state.bits,
                            16191 === state.mode && (state.back = -1);
                            break
                        }
                        for (state.back = 0; here = state.lencode[hold & (1 << state.lenbits) - 1],
                        here_bits = here >>> 24,
                        here_op = here >>> 16 & 255,
                        here_val = 65535 & here,
                        !(here_bits <= bits); ) {
                            if (0 === have)
                                break inf_leave;
                            have--,
                            hold += input[next++] << bits,
                            bits += 8
                        }
                        if (here_op && 0 == (240 & here_op)) {
                            for (last_bits = here_bits,
                            last_op = here_op,
                            last_val = here_val; here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)],
                            here_bits = here >>> 24,
                            here_op = here >>> 16 & 255,
                            here_val = 65535 & here,
                            !(last_bits + here_bits <= bits); ) {
                                if (0 === have)
                                    break inf_leave;
                                have--,
                                hold += input[next++] << bits,
                                bits += 8
                            }
                            hold >>>= last_bits,
                            bits -= last_bits,
                            state.back += last_bits
                        }
                        if (hold >>>= here_bits,
                        bits -= here_bits,
                        state.back += here_bits,
                        state.length = here_val,
                        0 === here_op) {
                            state.mode = 16205;
                            break
                        }
                        if (32 & here_op) {
                            state.back = -1,
                            state.mode = 16191;
                            break
                        }
                        if (64 & here_op) {
                            strm.msg = "invalid literal/length code",
                            state.mode = BAD;
                            break
                        }
                        state.extra = 15 & here_op,
                        state.mode = 16201;
                    case 16201:
                        if (state.extra) {
                            for (n = state.extra; bits < n; ) {
                                if (0 === have)
                                    break inf_leave;
                                have--,
                                hold += input[next++] << bits,
                                bits += 8
                            }
                            state.length += hold & (1 << state.extra) - 1,
                            hold >>>= state.extra,
                            bits -= state.extra,
                            state.back += state.extra
                        }
                        state.was = state.length,
                        state.mode = 16202;
                    case 16202:
                        for (; here = state.distcode[hold & (1 << state.distbits) - 1],
                        here_bits = here >>> 24,
                        here_op = here >>> 16 & 255,
                        here_val = 65535 & here,
                        !(here_bits <= bits); ) {
                            if (0 === have)
                                break inf_leave;
                            have--,
                            hold += input[next++] << bits,
                            bits += 8
                        }
                        if (0 == (240 & here_op)) {
                            for (last_bits = here_bits,
                            last_op = here_op,
                            last_val = here_val; here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)],
                            here_bits = here >>> 24,
                            here_op = here >>> 16 & 255,
                            here_val = 65535 & here,
                            !(last_bits + here_bits <= bits); ) {
                                if (0 === have)
                                    break inf_leave;
                                have--,
                                hold += input[next++] << bits,
                                bits += 8
                            }
                            hold >>>= last_bits,
                            bits -= last_bits,
                            state.back += last_bits
                        }
                        if (hold >>>= here_bits,
                        bits -= here_bits,
                        state.back += here_bits,
                        64 & here_op) {
                            strm.msg = "invalid distance code",
                            state.mode = BAD;
                            break
                        }
                        state.offset = here_val,
                        state.extra = 15 & here_op,
                        state.mode = 16203;
                    case 16203:
                        if (state.extra) {
                            for (n = state.extra; bits < n; ) {
                                if (0 === have)
                                    break inf_leave;
                                have--,
                                hold += input[next++] << bits,
                                bits += 8
                            }
                            state.offset += hold & (1 << state.extra) - 1,
                            hold >>>= state.extra,
                            bits -= state.extra,
                            state.back += state.extra
                        }
                        if (state.offset > state.dmax) {
                            strm.msg = "invalid distance too far back",
                            state.mode = BAD;
                            break
                        }
                        state.mode = 16204;
                    case 16204:
                        if (0 === left)
                            break inf_leave;
                        if (copy = _out - left,
                        state.offset > copy) {
                            if (copy = state.offset - copy,
                            copy > state.whave && state.sane) {
                                strm.msg = "invalid distance too far back",
                                state.mode = BAD;
                                break
                            }
                            copy > state.wnext ? (copy -= state.wnext,
                            from = state.wsize - copy) : from = state.wnext - copy,
                            copy > state.length && (copy = state.length),
                            from_source = state.window
                        } else
                            from_source = output,
                            from = put - state.offset,
                            copy = state.length;
                        copy > left && (copy = left),
                        left -= copy,
                        state.length -= copy;
                        do {
                            output[put++] = from_source[from++]
                        } while (--copy);
                        0 === state.length && (state.mode = 16200);
                        break;
                    case 16205:
                        if (0 === left)
                            break inf_leave;
                        output[put++] = state.length,
                        left--,
                        state.mode = 16200;
                        break;
                    case 16206:
                        if (state.wrap) {
                            for (; bits < 32; ) {
                                if (0 === have)
                                    break inf_leave;
                                have--,
                                hold |= input[next++] << bits,
                                bits += 8
                            }
                            if (_out -= left,
                            strm.total_out += _out,
                            state.total += _out,
                            4 & state.wrap && _out && (strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out)),
                            _out = left,
                            4 & state.wrap && (state.flags ? hold : zswap32(hold)) !== state.check) {
                                strm.msg = "incorrect data check",
                                state.mode = BAD;
                                break
                            }
                            hold = 0,
                            bits = 0
                        }
                        state.mode = 16207;
                    case 16207:
                        if (state.wrap && state.flags) {
                            for (; bits < 32; ) {
                                if (0 === have)
                                    break inf_leave;
                                have--,
                                hold += input[next++] << bits,
                                bits += 8
                            }
                            if (4 & state.wrap && hold !== (4294967295 & state.total)) {
                                strm.msg = "incorrect length check",
                                state.mode = BAD;
                                break
                            }
                            hold = 0,
                            bits = 0
                        }
                        state.mode = 16208;
                    case 16208:
                        ret = Z_STREAM_END;
                        break inf_leave;
                    case BAD:
                        ret = Z_DATA_ERROR;
                        break inf_leave;
                    case 16210:
                        return Z_MEM_ERROR;
                    default:
                        return Z_STREAM_ERROR
                    }
                return strm.next_out = put,
                strm.avail_out = left,
                strm.next_in = next,
                strm.avail_in = have,
                state.hold = hold,
                state.bits = bits,
                (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < 16206 || flush !== Z_FINISH)) && updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out) ? (state.mode = 16210,
                Z_MEM_ERROR) : (_in -= strm.avail_in,
                _out -= strm.avail_out,
                strm.total_in += _in,
                strm.total_out += _out,
                state.total += _out,
                4 & state.wrap && _out && (strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out)),
                strm.data_type = state.bits + (state.last ? 64 : 0) + (16191 === state.mode ? 128 : 0) + (16199 === state.mode || 16194 === state.mode ? 256 : 0),
                (0 === _in && 0 === _out || flush === Z_FINISH) && ret === Z_OK && (ret = Z_BUF_ERROR),
                ret)
            }
            ,
            module.exports.inflateEnd = strm=>{
                if (inflateStateCheck(strm))
                    return Z_STREAM_ERROR;
                let state = strm.state;
                return state.window && (state.window = null),
                strm.state = null,
                Z_OK
            }
            ,
            module.exports.inflateGetHeader = (strm,head)=>{
                if (inflateStateCheck(strm))
                    return Z_STREAM_ERROR;
                const state = strm.state;
                return 0 == (2 & state.wrap) ? Z_STREAM_ERROR : (state.head = head,
                head.done = !1,
                Z_OK)
            }
            ,
            module.exports.inflateSetDictionary = (strm,dictionary)=>{
                const dictLength = dictionary.length;
                let state, dictid, ret;
                return inflateStateCheck(strm) ? Z_STREAM_ERROR : (state = strm.state,
                0 !== state.wrap && 16190 !== state.mode ? Z_STREAM_ERROR : 16190 === state.mode && (dictid = 1,
                dictid = adler32(dictid, dictionary, dictLength, 0),
                dictid !== state.check) ? Z_DATA_ERROR : (ret = updatewindow(strm, dictionary, dictLength, dictLength),
                ret ? (state.mode = 16210,
                Z_MEM_ERROR) : (state.havedict = 1,
                Z_OK)))
            }
            ,
            module.exports.inflateInfo = "pako inflate (from Nodeca project)"
        }
        ,
        82418: module=>{
            "use strict";
            const lbase = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0])
              , lext = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78])
              , dbase = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0])
              , dext = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]);
            module.exports = (type,lens,lens_index,codes,table,table_index,work,opts)=>{
                const bits = opts.bits;
                let incr, fill, low, mask, next, match, len = 0, sym = 0, min = 0, max = 0, root = 0, curr = 0, drop = 0, left = 0, used = 0, huff = 0, base = null;
                const count = new Uint16Array(16)
                  , offs = new Uint16Array(16);
                let here_bits, here_op, here_val, extra = null;
                for (len = 0; len <= 15; len++)
                    count[len] = 0;
                for (sym = 0; sym < codes; sym++)
                    count[lens[lens_index + sym]]++;
                for (root = bits,
                max = 15; max >= 1 && 0 === count[max]; max--)
                    ;
                if (root > max && (root = max),
                0 === max)
                    return table[table_index++] = 20971520,
                    table[table_index++] = 20971520,
                    opts.bits = 1,
                    0;
                for (min = 1; min < max && 0 === count[min]; min++)
                    ;
                for (root < min && (root = min),
                left = 1,
                len = 1; len <= 15; len++)
                    if (left <<= 1,
                    left -= count[len],
                    left < 0)
                        return -1;
                if (left > 0 && (0 === type || 1 !== max))
                    return -1;
                for (offs[1] = 0,
                len = 1; len < 15; len++)
                    offs[len + 1] = offs[len] + count[len];
                for (sym = 0; sym < codes; sym++)
                    0 !== lens[lens_index + sym] && (work[offs[lens[lens_index + sym]]++] = sym);
                if (0 === type ? (base = extra = work,
                match = 20) : 1 === type ? (base = lbase,
                extra = lext,
                match = 257) : (base = dbase,
                extra = dext,
                match = 0),
                huff = 0,
                sym = 0,
                len = min,
                next = table_index,
                curr = root,
                drop = 0,
                low = -1,
                used = 1 << root,
                mask = used - 1,
                1 === type && used > 852 || 2 === type && used > 592)
                    return 1;
                for (; ; ) {
                    here_bits = len - drop,
                    work[sym] + 1 < match ? (here_op = 0,
                    here_val = work[sym]) : work[sym] >= match ? (here_op = extra[work[sym] - match],
                    here_val = base[work[sym] - match]) : (here_op = 96,
                    here_val = 0),
                    incr = 1 << len - drop,
                    fill = 1 << curr,
                    min = fill;
                    do {
                        fill -= incr,
                        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0
                    } while (0 !== fill);
                    for (incr = 1 << len - 1; huff & incr; )
                        incr >>= 1;
                    if (0 !== incr ? (huff &= incr - 1,
                    huff += incr) : huff = 0,
                    sym++,
                    0 == --count[len]) {
                        if (len === max)
                            break;
                        len = lens[lens_index + work[sym]]
                    }
                    if (len > root && (huff & mask) !== low) {
                        for (0 === drop && (drop = root),
                        next += min,
                        curr = len - drop,
                        left = 1 << curr; curr + drop < max && (left -= count[curr + drop],
                        !(left <= 0)); )
                            curr++,
                            left <<= 1;
                        if (used += 1 << curr,
                        1 === type && used > 852 || 2 === type && used > 592)
                            return 1;
                        low = huff & mask,
                        table[low] = root << 24 | curr << 16 | next - table_index | 0
                    }
                }
                return 0 !== huff && (table[next + huff] = len - drop << 24 | 64 << 16 | 0),
                opts.bits = root,
                0
            }
        }
        ,
        41171: module=>{
            "use strict";
            module.exports = {
                2: "need dictionary",
                1: "stream end",
                0: "",
                "-1": "file error",
                "-2": "stream error",
                "-3": "data error",
                "-4": "insufficient memory",
                "-5": "buffer error",
                "-6": "incompatible version"
            }
        }
        ,
        17794: module=>{
            "use strict";
            function zero(buf) {
                let len = buf.length;
                for (; --len >= 0; )
                    buf[len] = 0
            }
            const extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
              , extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
              , extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
              , bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
              , static_ltree = new Array(576);
            zero(static_ltree);
            const static_dtree = new Array(60);
            zero(static_dtree);
            const _dist_code = new Array(512);
            zero(_dist_code);
            const _length_code = new Array(256);
            zero(_length_code);
            const base_length = new Array(29);
            zero(base_length);
            const base_dist = new Array(30);
            function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
                this.static_tree = static_tree,
                this.extra_bits = extra_bits,
                this.extra_base = extra_base,
                this.elems = elems,
                this.max_length = max_length,
                this.has_stree = static_tree && static_tree.length
            }
            let static_l_desc, static_d_desc, static_bl_desc;
            function TreeDesc(dyn_tree, stat_desc) {
                this.dyn_tree = dyn_tree,
                this.max_code = 0,
                this.stat_desc = stat_desc
            }
            zero(base_dist);
            const d_code = dist=>dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)]
              , put_short = (s,w)=>{
                s.pending_buf[s.pending++] = 255 & w,
                s.pending_buf[s.pending++] = w >>> 8 & 255
            }
              , send_bits = (s,value,length)=>{
                s.bi_valid > 16 - length ? (s.bi_buf |= value << s.bi_valid & 65535,
                put_short(s, s.bi_buf),
                s.bi_buf = value >> 16 - s.bi_valid,
                s.bi_valid += length - 16) : (s.bi_buf |= value << s.bi_valid & 65535,
                s.bi_valid += length)
            }
              , send_code = (s,c,tree)=>{
                send_bits(s, tree[2 * c], tree[2 * c + 1])
            }
              , bi_reverse = (code,len)=>{
                let res = 0;
                do {
                    res |= 1 & code,
                    code >>>= 1,
                    res <<= 1
                } while (--len > 0);
                return res >>> 1
            }
              , gen_codes = (tree,max_code,bl_count)=>{
                const next_code = new Array(16);
                let bits, n, code = 0;
                for (bits = 1; bits <= 15; bits++)
                    code = code + bl_count[bits - 1] << 1,
                    next_code[bits] = code;
                for (n = 0; n <= max_code; n++) {
                    let len = tree[2 * n + 1];
                    0 !== len && (tree[2 * n] = bi_reverse(next_code[len]++, len))
                }
            }
              , init_block = s=>{
                let n;
                for (n = 0; n < 286; n++)
                    s.dyn_ltree[2 * n] = 0;
                for (n = 0; n < 30; n++)
                    s.dyn_dtree[2 * n] = 0;
                for (n = 0; n < 19; n++)
                    s.bl_tree[2 * n] = 0;
                s.dyn_ltree[512] = 1,
                s.opt_len = s.static_len = 0,
                s.sym_next = s.matches = 0
            }
              , bi_windup = s=>{
                s.bi_valid > 8 ? put_short(s, s.bi_buf) : s.bi_valid > 0 && (s.pending_buf[s.pending++] = s.bi_buf),
                s.bi_buf = 0,
                s.bi_valid = 0
            }
              , smaller = (tree,n,m,depth)=>{
                const _n2 = 2 * n
                  , _m2 = 2 * m;
                return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m]
            }
              , pqdownheap = (s,tree,k)=>{
                const v = s.heap[k];
                let j = k << 1;
                for (; j <= s.heap_len && (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth) && j++,
                !smaller(tree, v, s.heap[j], s.depth)); )
                    s.heap[k] = s.heap[j],
                    k = j,
                    j <<= 1;
                s.heap[k] = v
            }
              , compress_block = (s,ltree,dtree)=>{
                let dist, lc, code, extra, sx = 0;
                if (0 !== s.sym_next)
                    do {
                        dist = 255 & s.pending_buf[s.sym_buf + sx++],
                        dist += (255 & s.pending_buf[s.sym_buf + sx++]) << 8,
                        lc = s.pending_buf[s.sym_buf + sx++],
                        0 === dist ? send_code(s, lc, ltree) : (code = _length_code[lc],
                        send_code(s, code + 256 + 1, ltree),
                        extra = extra_lbits[code],
                        0 !== extra && (lc -= base_length[code],
                        send_bits(s, lc, extra)),
                        dist--,
                        code = d_code(dist),
                        send_code(s, code, dtree),
                        extra = extra_dbits[code],
                        0 !== extra && (dist -= base_dist[code],
                        send_bits(s, dist, extra)))
                    } while (sx < s.sym_next);
                send_code(s, 256, ltree)
            }
              , build_tree = (s,desc)=>{
                const tree = desc.dyn_tree
                  , stree = desc.stat_desc.static_tree
                  , has_stree = desc.stat_desc.has_stree
                  , elems = desc.stat_desc.elems;
                let n, m, node, max_code = -1;
                for (s.heap_len = 0,
                s.heap_max = 573,
                n = 0; n < elems; n++)
                    0 !== tree[2 * n] ? (s.heap[++s.heap_len] = max_code = n,
                    s.depth[n] = 0) : tree[2 * n + 1] = 0;
                for (; s.heap_len < 2; )
                    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0,
                    tree[2 * node] = 1,
                    s.depth[node] = 0,
                    s.opt_len--,
                    has_stree && (s.static_len -= stree[2 * node + 1]);
                for (desc.max_code = max_code,
                n = s.heap_len >> 1; n >= 1; n--)
                    pqdownheap(s, tree, n);
                node = elems;
                do {
                    n = s.heap[1],
                    s.heap[1] = s.heap[s.heap_len--],
                    pqdownheap(s, tree, 1),
                    m = s.heap[1],
                    s.heap[--s.heap_max] = n,
                    s.heap[--s.heap_max] = m,
                    tree[2 * node] = tree[2 * n] + tree[2 * m],
                    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1,
                    tree[2 * n + 1] = tree[2 * m + 1] = node,
                    s.heap[1] = node++,
                    pqdownheap(s, tree, 1)
                } while (s.heap_len >= 2);
                s.heap[--s.heap_max] = s.heap[1],
                ((s,desc)=>{
                    const tree = desc.dyn_tree
                      , max_code = desc.max_code
                      , stree = desc.stat_desc.static_tree
                      , has_stree = desc.stat_desc.has_stree
                      , extra = desc.stat_desc.extra_bits
                      , base = desc.stat_desc.extra_base
                      , max_length = desc.stat_desc.max_length;
                    let h, n, m, bits, xbits, f, overflow = 0;
                    for (bits = 0; bits <= 15; bits++)
                        s.bl_count[bits] = 0;
                    for (tree[2 * s.heap[s.heap_max] + 1] = 0,
                    h = s.heap_max + 1; h < 573; h++)
                        n = s.heap[h],
                        bits = tree[2 * tree[2 * n + 1] + 1] + 1,
                        bits > max_length && (bits = max_length,
                        overflow++),
                        tree[2 * n + 1] = bits,
                        n > max_code || (s.bl_count[bits]++,
                        xbits = 0,
                        n >= base && (xbits = extra[n - base]),
                        f = tree[2 * n],
                        s.opt_len += f * (bits + xbits),
                        has_stree && (s.static_len += f * (stree[2 * n + 1] + xbits)));
                    if (0 !== overflow) {
                        do {
                            for (bits = max_length - 1; 0 === s.bl_count[bits]; )
                                bits--;
                            s.bl_count[bits]--,
                            s.bl_count[bits + 1] += 2,
                            s.bl_count[max_length]--,
                            overflow -= 2
                        } while (overflow > 0);
                        for (bits = max_length; 0 !== bits; bits--)
                            for (n = s.bl_count[bits]; 0 !== n; )
                                m = s.heap[--h],
                                m > max_code || (tree[2 * m + 1] !== bits && (s.opt_len += (bits - tree[2 * m + 1]) * tree[2 * m],
                                tree[2 * m + 1] = bits),
                                n--)
                    }
                }
                )(s, desc),
                gen_codes(tree, max_code, s.bl_count)
            }
              , scan_tree = (s,tree,max_code)=>{
                let n, curlen, prevlen = -1, nextlen = tree[1], count = 0, max_count = 7, min_count = 4;
                for (0 === nextlen && (max_count = 138,
                min_count = 3),
                tree[2 * (max_code + 1) + 1] = 65535,
                n = 0; n <= max_code; n++)
                    curlen = nextlen,
                    nextlen = tree[2 * (n + 1) + 1],
                    ++count < max_count && curlen === nextlen || (count < min_count ? s.bl_tree[2 * curlen] += count : 0 !== curlen ? (curlen !== prevlen && s.bl_tree[2 * curlen]++,
                    s.bl_tree[32]++) : count <= 10 ? s.bl_tree[34]++ : s.bl_tree[36]++,
                    count = 0,
                    prevlen = curlen,
                    0 === nextlen ? (max_count = 138,
                    min_count = 3) : curlen === nextlen ? (max_count = 6,
                    min_count = 3) : (max_count = 7,
                    min_count = 4))
            }
              , send_tree = (s,tree,max_code)=>{
                let n, curlen, prevlen = -1, nextlen = tree[1], count = 0, max_count = 7, min_count = 4;
                for (0 === nextlen && (max_count = 138,
                min_count = 3),
                n = 0; n <= max_code; n++)
                    if (curlen = nextlen,
                    nextlen = tree[2 * (n + 1) + 1],
                    !(++count < max_count && curlen === nextlen)) {
                        if (count < min_count)
                            do {
                                send_code(s, curlen, s.bl_tree)
                            } while (0 != --count);
                        else
                            0 !== curlen ? (curlen !== prevlen && (send_code(s, curlen, s.bl_tree),
                            count--),
                            send_code(s, 16, s.bl_tree),
                            send_bits(s, count - 3, 2)) : count <= 10 ? (send_code(s, 17, s.bl_tree),
                            send_bits(s, count - 3, 3)) : (send_code(s, 18, s.bl_tree),
                            send_bits(s, count - 11, 7));
                        count = 0,
                        prevlen = curlen,
                        0 === nextlen ? (max_count = 138,
                        min_count = 3) : curlen === nextlen ? (max_count = 6,
                        min_count = 3) : (max_count = 7,
                        min_count = 4)
                    }
            }
            ;
            let static_init_done = !1;
            const _tr_stored_block = (s,buf,stored_len,last)=>{
                send_bits(s, 0 + (last ? 1 : 0), 3),
                bi_windup(s),
                put_short(s, stored_len),
                put_short(s, ~stored_len),
                stored_len && s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending),
                s.pending += stored_len
            }
            ;
            module.exports._tr_init = s=>{
                static_init_done || ((()=>{
                    let n, bits, length, code, dist;
                    const bl_count = new Array(16);
                    for (length = 0,
                    code = 0; code < 28; code++)
                        for (base_length[code] = length,
                        n = 0; n < 1 << extra_lbits[code]; n++)
                            _length_code[length++] = code;
                    for (_length_code[length - 1] = code,
                    dist = 0,
                    code = 0; code < 16; code++)
                        for (base_dist[code] = dist,
                        n = 0; n < 1 << extra_dbits[code]; n++)
                            _dist_code[dist++] = code;
                    for (dist >>= 7; code < 30; code++)
                        for (base_dist[code] = dist << 7,
                        n = 0; n < 1 << extra_dbits[code] - 7; n++)
                            _dist_code[256 + dist++] = code;
                    for (bits = 0; bits <= 15; bits++)
                        bl_count[bits] = 0;
                    for (n = 0; n <= 143; )
                        static_ltree[2 * n + 1] = 8,
                        n++,
                        bl_count[8]++;
                    for (; n <= 255; )
                        static_ltree[2 * n + 1] = 9,
                        n++,
                        bl_count[9]++;
                    for (; n <= 279; )
                        static_ltree[2 * n + 1] = 7,
                        n++,
                        bl_count[7]++;
                    for (; n <= 287; )
                        static_ltree[2 * n + 1] = 8,
                        n++,
                        bl_count[8]++;
                    for (gen_codes(static_ltree, 287, bl_count),
                    n = 0; n < 30; n++)
                        static_dtree[2 * n + 1] = 5,
                        static_dtree[2 * n] = bi_reverse(n, 5);
                    static_l_desc = new StaticTreeDesc(static_ltree,extra_lbits,257,286,15),
                    static_d_desc = new StaticTreeDesc(static_dtree,extra_dbits,0,30,15),
                    static_bl_desc = new StaticTreeDesc(new Array(0),extra_blbits,0,19,7)
                }
                )(),
                static_init_done = !0),
                s.l_desc = new TreeDesc(s.dyn_ltree,static_l_desc),
                s.d_desc = new TreeDesc(s.dyn_dtree,static_d_desc),
                s.bl_desc = new TreeDesc(s.bl_tree,static_bl_desc),
                s.bi_buf = 0,
                s.bi_valid = 0,
                init_block(s)
            }
            ,
            module.exports._tr_stored_block = _tr_stored_block,
            module.exports._tr_flush_block = (s,buf,stored_len,last)=>{
                let opt_lenb, static_lenb, max_blindex = 0;
                s.level > 0 ? (2 === s.strm.data_type && (s.strm.data_type = (s=>{
                    let n, block_mask = 4093624447;
                    for (n = 0; n <= 31; n++,
                    block_mask >>>= 1)
                        if (1 & block_mask && 0 !== s.dyn_ltree[2 * n])
                            return 0;
                    if (0 !== s.dyn_ltree[18] || 0 !== s.dyn_ltree[20] || 0 !== s.dyn_ltree[26])
                        return 1;
                    for (n = 32; n < 256; n++)
                        if (0 !== s.dyn_ltree[2 * n])
                            return 1;
                    return 0
                }
                )(s)),
                build_tree(s, s.l_desc),
                build_tree(s, s.d_desc),
                max_blindex = (s=>{
                    let max_blindex;
                    for (scan_tree(s, s.dyn_ltree, s.l_desc.max_code),
                    scan_tree(s, s.dyn_dtree, s.d_desc.max_code),
                    build_tree(s, s.bl_desc),
                    max_blindex = 18; max_blindex >= 3 && 0 === s.bl_tree[2 * bl_order[max_blindex] + 1]; max_blindex--)
                        ;
                    return s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4,
                    max_blindex
                }
                )(s),
                opt_lenb = s.opt_len + 3 + 7 >>> 3,
                static_lenb = s.static_len + 3 + 7 >>> 3,
                static_lenb <= opt_lenb && (opt_lenb = static_lenb)) : opt_lenb = static_lenb = stored_len + 5,
                stored_len + 4 <= opt_lenb && -1 !== buf ? _tr_stored_block(s, buf, stored_len, last) : 4 === s.strategy || static_lenb === opt_lenb ? (send_bits(s, 2 + (last ? 1 : 0), 3),
                compress_block(s, static_ltree, static_dtree)) : (send_bits(s, 4 + (last ? 1 : 0), 3),
                ((s,lcodes,dcodes,blcodes)=>{
                    let rank;
                    for (send_bits(s, lcodes - 257, 5),
                    send_bits(s, dcodes - 1, 5),
                    send_bits(s, blcodes - 4, 4),
                    rank = 0; rank < blcodes; rank++)
                        send_bits(s, s.bl_tree[2 * bl_order[rank] + 1], 3);
                    send_tree(s, s.dyn_ltree, lcodes - 1),
                    send_tree(s, s.dyn_dtree, dcodes - 1)
                }
                )(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1),
                compress_block(s, s.dyn_ltree, s.dyn_dtree)),
                init_block(s),
                last && bi_windup(s)
            }
            ,
            module.exports._tr_tally = (s,dist,lc)=>(s.pending_buf[s.sym_buf + s.sym_next++] = dist,
            s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8,
            s.pending_buf[s.sym_buf + s.sym_next++] = lc,
            0 === dist ? s.dyn_ltree[2 * lc]++ : (s.matches++,
            dist--,
            s.dyn_ltree[2 * (_length_code[lc] + 256 + 1)]++,
            s.dyn_dtree[2 * d_code(dist)]++),
            s.sym_next === s.sym_end),
            module.exports._tr_align = s=>{
                send_bits(s, 2, 3),
                send_code(s, 256, static_ltree),
                (s=>{
                    16 === s.bi_valid ? (put_short(s, s.bi_buf),
                    s.bi_buf = 0,
                    s.bi_valid = 0) : s.bi_valid >= 8 && (s.pending_buf[s.pending++] = 255 & s.bi_buf,
                    s.bi_buf >>= 8,
                    s.bi_valid -= 8)
                }
                )(s)
            }
        }
        ,
        63875: module=>{
            "use strict";
            module.exports = function() {
                this.input = null,
                this.next_in = 0,
                this.avail_in = 0,
                this.total_in = 0,
                this.output = null,
                this.next_out = 0,
                this.avail_out = 0,
                this.total_out = 0,
                this.msg = "",
                this.state = null,
                this.data_type = 2,
                this.adler = 0
            }
        }
        ,
        84817: (module,__unused_webpack_exports,__webpack_require__)=>{
            "use strict";
            var mod, __create = Object.create, __defProp = Object.defineProperty, __getOwnPropDesc = Object.getOwnPropertyDescriptor, __getOwnPropNames = Object.getOwnPropertyNames, __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty, __export = (target,all)=>{
                for (var name in all)
                    __defProp(target, name, {
                        get: all[name],
                        enumerable: !0
                    })
            }
            , __copyProps = (to,from,except,desc)=>{
                if (from && "object" == typeof from || "function" == typeof from)
                    for (let key of __getOwnPropNames(from))
                        __hasOwnProp.call(to, key) || key === except || __defProp(to, key, {
                            get: ()=>from[key],
                            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
                        });
                return to
            }
            , __toESM = (mod,isNodeMode,target)=>(target = null != mod ? __create(__getProtoOf(mod)) : {},
            __copyProps(!isNodeMode && mod && mod.__esModule ? target : __defProp(target, "default", {
                value: mod,
                enumerable: !0
            }), mod)), src_exports = {};
            __export(src_exports, {
                Account: ()=>Account,
                AccountInterface: ()=>AccountInterface,
                BlockStatus: ()=>BlockStatus,
                BlockTag: ()=>BlockTag,
                CairoCustomEnum: ()=>CairoCustomEnum,
                CairoOption: ()=>CairoOption,
                CairoOptionVariant: ()=>CairoOptionVariant,
                CairoResult: ()=>CairoResult,
                CairoResultVariant: ()=>CairoResultVariant,
                CallData: ()=>CallData,
                Contract: ()=>Contract,
                ContractFactory: ()=>ContractFactory,
                ContractInterface: ()=>ContractInterface,
                CustomError: ()=>CustomError,
                EntryPointType: ()=>EntryPointType,
                GatewayError: ()=>GatewayError,
                HttpError: ()=>HttpError,
                LibraryError: ()=>LibraryError,
                Litteral: ()=>Litteral,
                Provider: ()=>Provider,
                ProviderInterface: ()=>ProviderInterface,
                RPC: ()=>rpc_exports,
                RpcProvider: ()=>RpcProvider,
                SIMULATION_FLAG: ()=>SIMULATION_FLAG,
                Sequencer: ()=>sequencer_exports,
                SequencerProvider: ()=>SequencerProvider,
                Signer: ()=>Signer,
                SignerInterface: ()=>SignerInterface,
                TransactionExecutionStatus: ()=>TransactionExecutionStatus,
                TransactionFinalityStatus: ()=>TransactionFinalityStatus,
                TransactionStatus: ()=>TransactionStatus,
                TransactionType: ()=>TransactionType,
                Uint: ()=>Uint,
                ValidateType: ()=>ValidateType,
                addAddressPadding: ()=>addAddressPadding,
                buildUrl: ()=>buildUrl,
                cairo: ()=>cairo_exports,
                constants: ()=>constants_exports,
                contractClassResponseToLegacyCompiledContract: ()=>contractClassResponseToLegacyCompiledContract,
                defaultProvider: ()=>defaultProvider,
                ec: ()=>ec_exports,
                encode: ()=>encode_exports,
                events: ()=>events_exports,
                extractContractHashes: ()=>extractContractHashes,
                fixProto: ()=>fixProto,
                fixStack: ()=>fixStack,
                getCalldata: ()=>getCalldata,
                getChecksumAddress: ()=>getChecksumAddress,
                getDefaultNodeUrl: ()=>getDefaultNodeUrl,
                hash: ()=>hash_exports,
                isSierra: ()=>isSierra,
                isUrl: ()=>isUrl,
                json: ()=>json_exports,
                merkle: ()=>merkle_exports,
                num: ()=>num_exports,
                number: ()=>number,
                parseUDCEvent: ()=>parseUDCEvent,
                provider: ()=>provider_exports,
                selector: ()=>selector_exports,
                shortString: ()=>shortString_exports,
                splitArgsAndOptions: ()=>splitArgsAndOptions,
                stark: ()=>stark_exports,
                starknetId: ()=>starknetId_exports,
                transaction: ()=>transaction_exports,
                typedData: ()=>typedData_exports,
                types: ()=>types_exports,
                uint256: ()=>uint256_exports,
                validateAndParseAddress: ()=>validateAndParseAddress,
                validateChecksumAddress: ()=>validateChecksumAddress
            }),
            module.exports = (mod = src_exports,
            __copyProps(__defProp({}, "__esModule", {
                value: !0
            }), mod));
            var constants_exports = {};
            __export(constants_exports, {
                ADDR_BOUND: ()=>ADDR_BOUND,
                API_VERSION: ()=>API_VERSION,
                BN_FEE_TRANSACTION_VERSION_1: ()=>BN_FEE_TRANSACTION_VERSION_1,
                BN_FEE_TRANSACTION_VERSION_2: ()=>BN_FEE_TRANSACTION_VERSION_2,
                BN_TRANSACTION_VERSION_1: ()=>BN_TRANSACTION_VERSION_1,
                BN_TRANSACTION_VERSION_2: ()=>BN_TRANSACTION_VERSION_2,
                BaseUrl: ()=>BaseUrl,
                HEX_STR_TRANSACTION_VERSION_1: ()=>HEX_STR_TRANSACTION_VERSION_1,
                HEX_STR_TRANSACTION_VERSION_2: ()=>HEX_STR_TRANSACTION_VERSION_2,
                IS_BROWSER: ()=>IS_BROWSER,
                MASK_250: ()=>MASK_250,
                MAX_STORAGE_ITEM_SIZE: ()=>MAX_STORAGE_ITEM_SIZE,
                NetworkName: ()=>NetworkName,
                RPC_DEFAULT_VERSION: ()=>RPC_DEFAULT_VERSION,
                RPC_NODES: ()=>RPC_NODES,
                StarknetChainId: ()=>StarknetChainId,
                TEXT_TO_FELT_MAX_LEN: ()=>TEXT_TO_FELT_MAX_LEN,
                TransactionHashPrefix: ()=>TransactionHashPrefix,
                UDC: ()=>UDC,
                ZERO: ()=>ZERO
            });
            var encode_exports = {};
            __export(encode_exports, {
                IS_BROWSER: ()=>IS_BROWSER,
                addHexPrefix: ()=>addHexPrefix,
                arrayBufferToString: ()=>arrayBufferToString,
                atobUniversal: ()=>atobUniversal,
                btoaUniversal: ()=>btoaUniversal,
                buf2hex: ()=>buf2hex,
                calcByteLength: ()=>calcByteLength,
                padLeft: ()=>padLeft,
                pascalToSnake: ()=>pascalToSnake,
                removeHexPrefix: ()=>removeHexPrefix,
                sanitizeBytes: ()=>sanitizeBytes,
                sanitizeHex: ()=>sanitizeHex,
                stringToArrayBuffer: ()=>stringToArrayBuffer,
                utf8ToArray: ()=>utf8ToArray
            });
            var import_base = __webpack_require__(79667)
              , IS_BROWSER = "undefined" != typeof window
              , STRING_ZERO = "0";
            function arrayBufferToString(array) {
                return new Uint8Array(array).reduce(((data,byte)=>data + String.fromCharCode(byte)), "")
            }
            function utf8ToArray(str) {
                return (new TextEncoder).encode(str)
            }
            function stringToArrayBuffer(str) {
                return utf8ToArray(str)
            }
            function atobUniversal(a) {
                return import_base.base64.decode(a)
            }
            function btoaUniversal(b) {
                return import_base.base64.encode(new Uint8Array(b))
            }
            function buf2hex(buffer) {
                return buffer.reduce(((r,x)=>r + x.toString(16).padStart(2, "0")), "")
            }
            function removeHexPrefix(hex) {
                return hex.replace(/^0x/i, "")
            }
            function addHexPrefix(hex) {
                return `0x${removeHexPrefix(hex)}`
            }
            function padLeft(str, length, padding=STRING_ZERO) {
                return function(str, length, left, padding=STRING_ZERO) {
                    const diff = length - str.length;
                    let result = str;
                    if (diff > 0) {
                        const pad = padding.repeat(diff);
                        result = left ? pad + str : str + pad
                    }
                    return result
                }(str, length, !0, padding)
            }
            function calcByteLength(str, byteSize=8) {
                const {length} = str
                  , remainder = length % byteSize;
                return remainder ? (length - remainder) / byteSize * byteSize + byteSize : length
            }
            function sanitizeBytes(str, byteSize=8, padding=STRING_ZERO) {
                return padLeft(str, calcByteLength(str, byteSize), padding)
            }
            function sanitizeHex(hex) {
                return (hex = sanitizeBytes(hex = removeHexPrefix(hex), 2)) && (hex = addHexPrefix(hex)),
                hex
            }
            var pascalToSnake = text=>/[a-z]/.test(text) ? text.split(/(?=[A-Z])/).join("_").toUpperCase() : text
              , TEXT_TO_FELT_MAX_LEN = 31
              , HEX_STR_TRANSACTION_VERSION_1 = "0x1"
              , HEX_STR_TRANSACTION_VERSION_2 = "0x2"
              , BN_TRANSACTION_VERSION_1 = 1n
              , BN_TRANSACTION_VERSION_2 = 2n
              , BN_FEE_TRANSACTION_VERSION_1 = 2n ** 128n + BN_TRANSACTION_VERSION_1
              , BN_FEE_TRANSACTION_VERSION_2 = 2n ** 128n + BN_TRANSACTION_VERSION_2
              , ZERO = 0n
              , MASK_250 = 2n ** 250n - 1n
              , API_VERSION = ZERO
              , MAX_STORAGE_ITEM_SIZE = 256n
              , ADDR_BOUND = 2n ** 251n - MAX_STORAGE_ITEM_SIZE
              , BaseUrl = (BaseUrl2=>(BaseUrl2.SN_MAIN = "https://alpha-mainnet.starknet.io",
            BaseUrl2.SN_GOERLI = "https://alpha4.starknet.io",
            BaseUrl2.SN_SEPOLIA = "https://alpha-sepolia.starknet.io",
            BaseUrl2))(BaseUrl || {})
              , NetworkName = (NetworkName2=>(NetworkName2.SN_MAIN = "SN_MAIN",
            NetworkName2.SN_GOERLI = "SN_GOERLI",
            NetworkName2.SN_SEPOLIA = "SN_SEPOLIA",
            NetworkName2))(NetworkName || {})
              , StarknetChainId = (StarknetChainId4=>(StarknetChainId4.SN_MAIN = "0x534e5f4d41494e",
            StarknetChainId4.SN_GOERLI = "0x534e5f474f45524c49",
            StarknetChainId4.SN_SEPOLIA = "0x534e5f5345504f4c4941",
            StarknetChainId4))(StarknetChainId || {})
              , TransactionHashPrefix = (TransactionHashPrefix2=>(TransactionHashPrefix2.DECLARE = "0x6465636c617265",
            TransactionHashPrefix2.DEPLOY = "0x6465706c6f79",
            TransactionHashPrefix2.DEPLOY_ACCOUNT = "0x6465706c6f795f6163636f756e74",
            TransactionHashPrefix2.INVOKE = "0x696e766f6b65",
            TransactionHashPrefix2.L1_HANDLER = "0x6c315f68616e646c6572",
            TransactionHashPrefix2))(TransactionHashPrefix || {})
              , UDC = {
                ADDRESS: "0x041a78e741e5af2fec34b695679bc6891742439f7afb8484ecd7766661ad02bf",
                ENTRYPOINT: "deployContract"
            }
              , RPC_DEFAULT_VERSION = "v0_5"
              , RPC_NODES = {
                SN_GOERLI: ["https://starknet-testnet.public.blastapi.io/rpc/", "https://free-rpc.nethermind.io/goerli-juno/"],
                SN_MAIN: ["https://starknet-mainnet.public.blastapi.io/rpc/", "https://free-rpc.nethermind.io/mainnet-juno/"],
                SN_SEPOLIA: ["https://starknet-sepolia.public.blastapi.io/rpc/", "https://free-rpc.nethermind.io/sepolia-juno/"]
            }
              , types_exports = {};
            __export(types_exports, {
                BlockStatus: ()=>BlockStatus,
                BlockTag: ()=>BlockTag,
                EntryPointType: ()=>EntryPointType,
                Litteral: ()=>Litteral,
                RPC: ()=>rpc_exports,
                SIMULATION_FLAG: ()=>SIMULATION_FLAG,
                Sequencer: ()=>sequencer_exports,
                TransactionExecutionStatus: ()=>TransactionExecutionStatus,
                TransactionFinalityStatus: ()=>TransactionFinalityStatus,
                TransactionStatus: ()=>TransactionStatus,
                TransactionType: ()=>TransactionType,
                Uint: ()=>Uint,
                ValidateType: ()=>ValidateType
            });
            var SIMULATION_FLAG = (SIMULATION_FLAG2=>(SIMULATION_FLAG2.SKIP_VALIDATE = "SKIP_VALIDATE",
            SIMULATION_FLAG2.SKIP_EXECUTE = "SKIP_EXECUTE",
            SIMULATION_FLAG2))(SIMULATION_FLAG || {})
              , ValidateType = (ValidateType2=>(ValidateType2.DEPLOY = "DEPLOY",
            ValidateType2.CALL = "CALL",
            ValidateType2.INVOKE = "INVOKE",
            ValidateType2))(ValidateType || {})
              , Uint = (Uint2=>(Uint2.u8 = "core::integer::u8",
            Uint2.u16 = "core::integer::u16",
            Uint2.u32 = "core::integer::u32",
            Uint2.u64 = "core::integer::u64",
            Uint2.u128 = "core::integer::u128",
            Uint2.u256 = "core::integer::u256",
            Uint2))(Uint || {})
              , Litteral = (Litteral2=>(Litteral2.ClassHash = "core::starknet::class_hash::ClassHash",
            Litteral2.ContractAddress = "core::starknet::contract_address::ContractAddress",
            Litteral2))(Litteral || {})
              , EntryPointType = (EntryPointType2=>(EntryPointType2.EXTERNAL = "EXTERNAL",
            EntryPointType2.L1_HANDLER = "L1_HANDLER",
            EntryPointType2.CONSTRUCTOR = "CONSTRUCTOR",
            EntryPointType2))(EntryPointType || {})
              , TransactionType = (TransactionType2=>(TransactionType2.DECLARE = "DECLARE",
            TransactionType2.DEPLOY = "DEPLOY",
            TransactionType2.DEPLOY_ACCOUNT = "DEPLOY_ACCOUNT",
            TransactionType2.INVOKE = "INVOKE_FUNCTION",
            TransactionType2))(TransactionType || {})
              , TransactionStatus = (TransactionStatus2=>(TransactionStatus2.NOT_RECEIVED = "NOT_RECEIVED",
            TransactionStatus2.RECEIVED = "RECEIVED",
            TransactionStatus2.ACCEPTED_ON_L2 = "ACCEPTED_ON_L2",
            TransactionStatus2.ACCEPTED_ON_L1 = "ACCEPTED_ON_L1",
            TransactionStatus2.REJECTED = "REJECTED",
            TransactionStatus2.REVERTED = "REVERTED",
            TransactionStatus2))(TransactionStatus || {})
              , TransactionFinalityStatus = (TransactionFinalityStatus2=>(TransactionFinalityStatus2.NOT_RECEIVED = "NOT_RECEIVED",
            TransactionFinalityStatus2.RECEIVED = "RECEIVED",
            TransactionFinalityStatus2.ACCEPTED_ON_L2 = "ACCEPTED_ON_L2",
            TransactionFinalityStatus2.ACCEPTED_ON_L1 = "ACCEPTED_ON_L1",
            TransactionFinalityStatus2))(TransactionFinalityStatus || {})
              , TransactionExecutionStatus = (TransactionExecutionStatus2=>(TransactionExecutionStatus2.REJECTED = "REJECTED",
            TransactionExecutionStatus2.REVERTED = "REVERTED",
            TransactionExecutionStatus2.SUCCEEDED = "SUCCEEDED",
            TransactionExecutionStatus2))(TransactionExecutionStatus || {})
              , BlockStatus = (BlockStatus2=>(BlockStatus2.PENDING = "PENDING",
            BlockStatus2.ACCEPTED_ON_L1 = "ACCEPTED_ON_L1",
            BlockStatus2.ACCEPTED_ON_L2 = "ACCEPTED_ON_L2",
            BlockStatus2.REJECTED = "REJECTED",
            BlockStatus2))(BlockStatus || {})
              , BlockTag = (BlockTag2=>(BlockTag2.pending = "pending",
            BlockTag2.latest = "latest",
            BlockTag2))(BlockTag || {})
              , rpc_exports = {};
            __export(rpc_exports, {
                EBlockTag: ()=>EBlockTag,
                EDataAvailabilityMode: ()=>EDataAvailabilityMode,
                ESimulationFlag: ()=>ESimulationFlag,
                ETransactionExecutionStatus: ()=>ETransactionExecutionStatus,
                ETransactionFinalityStatus: ()=>ETransactionFinalityStatus,
                ETransactionStatus: ()=>ETransactionStatus,
                ETransactionType: ()=>ETransactionType,
                Errors: ()=>errors_exports,
                JRPC: ()=>jsonrpc_exports,
                SPEC: ()=>components_exports
            });
            var jsonrpc_exports = {}
              , errors_exports = {}
              , components_exports = {}
              , ETransactionType = (ETransactionType2=>(ETransactionType2.DECLARE = "DECLARE",
            ETransactionType2.DEPLOY = "DEPLOY",
            ETransactionType2.DEPLOY_ACCOUNT = "DEPLOY_ACCOUNT",
            ETransactionType2.INVOKE = "INVOKE",
            ETransactionType2.L1_HANDLER = "L1_HANDLER",
            ETransactionType2))(ETransactionType || {})
              , ESimulationFlag = (ESimulationFlag2=>(ESimulationFlag2.SKIP_VALIDATE = "SKIP_VALIDATE",
            ESimulationFlag2.SKIP_FEE_CHARGE = "SKIP_FEE_CHARGE",
            ESimulationFlag2))(ESimulationFlag || {})
              , ETransactionStatus = (ETransactionStatus2=>(ETransactionStatus2.RECEIVED = "RECEIVED",
            ETransactionStatus2.REJECTED = "REJECTED",
            ETransactionStatus2.ACCEPTED_ON_L2 = "ACCEPTED_ON_L2",
            ETransactionStatus2.ACCEPTED_ON_L1 = "ACCEPTED_ON_L1",
            ETransactionStatus2))(ETransactionStatus || {})
              , ETransactionFinalityStatus = (ETransactionFinalityStatus2=>(ETransactionFinalityStatus2.ACCEPTED_ON_L2 = "ACCEPTED_ON_L2",
            ETransactionFinalityStatus2.ACCEPTED_ON_L1 = "ACCEPTED_ON_L1",
            ETransactionFinalityStatus2))(ETransactionFinalityStatus || {})
              , ETransactionExecutionStatus = (ETransactionExecutionStatus2=>(ETransactionExecutionStatus2.SUCCEEDED = "SUCCEEDED",
            ETransactionExecutionStatus2.REVERTED = "REVERTED",
            ETransactionExecutionStatus2))(ETransactionExecutionStatus || {})
              , EBlockTag = (EBlockTag2=>(EBlockTag2.LATEST = "latest",
            EBlockTag2.PENDING = "pending",
            EBlockTag2))(EBlockTag || {})
              , EDataAvailabilityMode = (EDataAvailabilityMode2=>(EDataAvailabilityMode2.L1 = "L1",
            EDataAvailabilityMode2.L2 = "L2",
            EDataAvailabilityMode2))(EDataAvailabilityMode || {})
              , sequencer_exports = {};
            function assert(condition, message) {
                if (!condition)
                    throw new Error(message || "Assertion failure")
            }
            var num_exports = {};
            __export(num_exports, {
                assertInRange: ()=>assertInRange,
                bigNumberishArrayToDecimalStringArray: ()=>bigNumberishArrayToDecimalStringArray,
                bigNumberishArrayToHexadecimalStringArray: ()=>bigNumberishArrayToHexadecimalStringArray,
                cleanHex: ()=>cleanHex,
                getDecimalString: ()=>getDecimalString,
                getHexString: ()=>getHexString,
                getHexStringArray: ()=>getHexStringArray,
                hexToBytes: ()=>hexToBytes,
                hexToDecimalString: ()=>hexToDecimalString,
                isBigInt: ()=>isBigInt,
                isHex: ()=>isHex,
                isStringWholeNumber: ()=>isStringWholeNumber,
                toBigInt: ()=>toBigInt,
                toCairoBool: ()=>toCairoBool,
                toHex: ()=>toHex,
                toHexString: ()=>toHexString,
                toStorageKey: ()=>toStorageKey
            });
            var import_utils = __webpack_require__(40219);
            function isHex(hex) {
                return /^0x[0-9a-f]*$/i.test(hex)
            }
            function toBigInt(value) {
                return BigInt(value)
            }
            function isBigInt(value) {
                return "bigint" == typeof value
            }
            function toHex(number2) {
                return addHexPrefix(toBigInt(number2).toString(16))
            }
            var toHexString = toHex;
            function toStorageKey(number2) {
                return addHexPrefix(toBigInt(number2).toString(16).padStart(64, "0"))
            }
            function hexToDecimalString(hex) {
                return BigInt(addHexPrefix(hex)).toString(10)
            }
            var cleanHex = hex=>hex.toLowerCase().replace(/^(0x)0+/, "$1");
            function assertInRange(input, lowerBound, upperBound, inputName="") {
                const messageSuffix = "" === inputName ? "invalid length" : `invalid ${inputName} length`
                  , inputBigInt = BigInt(input)
                  , lowerBoundBigInt = BigInt(lowerBound)
                  , upperBoundBigInt = BigInt(upperBound);
                assert(inputBigInt >= lowerBoundBigInt && inputBigInt <= upperBoundBigInt, `Message not signable, ${messageSuffix}.`)
            }
            function bigNumberishArrayToDecimalStringArray(rawCalldata) {
                return rawCalldata.map((x=>toBigInt(x).toString(10)))
            }
            function bigNumberishArrayToHexadecimalStringArray(rawCalldata) {
                return rawCalldata.map((x=>toHex(x)))
            }
            var isStringWholeNumber = value=>/^\d+$/.test(value);
            function getDecimalString(value) {
                if (isHex(value))
                    return hexToDecimalString(value);
                if (isStringWholeNumber(value))
                    return value;
                throw new Error(`${value} need to be hex-string or whole-number-string`)
            }
            function getHexString(value) {
                if (isHex(value))
                    return value;
                if (isStringWholeNumber(value))
                    return toHexString(value);
                throw new Error(`${value} need to be hex-string or whole-number-string`)
            }
            function getHexStringArray(value) {
                return value.map((el=>getHexString(el)))
            }
            var toCairoBool = value=>(+value).toString();
            function hexToBytes(value) {
                if (!isHex(value))
                    throw new Error(`${value} need to be a hex-string`);
                let adaptedValue = removeHexPrefix(value);
                return adaptedValue.length % 2 != 0 && (adaptedValue = `0${adaptedValue}`),
                (0,
                import_utils.hexToBytes)(adaptedValue)
            }
            var selector_exports = {};
            __export(selector_exports, {
                getSelector: ()=>getSelector,
                getSelectorFromName: ()=>getSelectorFromName,
                keccakBn: ()=>keccakBn,
                starknetKeccak: ()=>starknetKeccak
            });
            var import_starknet = __webpack_require__(37962);
            function keccakBn(value) {
                const hexWithoutPrefix = removeHexPrefix(toHex(BigInt(value)))
                  , evenHex = hexWithoutPrefix.length % 2 == 0 ? hexWithoutPrefix : `0${hexWithoutPrefix}`;
                return addHexPrefix((0,
                import_starknet.keccak)(hexToBytes(addHexPrefix(evenHex))).toString(16))
            }
            function starknetKeccak(str) {
                const hash = BigInt(function(str) {
                    return addHexPrefix((0,
                    import_starknet.keccak)(utf8ToArray(str)).toString(16))
                }(str));
                return hash & MASK_250
            }
            function getSelectorFromName(funcName) {
                return toHex(starknetKeccak(funcName))
            }
            function getSelector(value) {
                return isHex(value) ? value : isStringWholeNumber(value) ? toHexString(value) : getSelectorFromName(value)
            }
            var shortString_exports = {};
            function isASCII(str) {
                return /^[\x00-\x7F]*$/.test(str)
            }
            function isShortString(str) {
                return str.length <= TEXT_TO_FELT_MAX_LEN
            }
            function isDecimalString(str) {
                return /^[0-9]*$/i.test(str)
            }
            function isText(val) {
                return "string" == typeof val && !isHex(val) && !isStringWholeNumber(val)
            }
            __export(shortString_exports, {
                decodeShortString: ()=>decodeShortString,
                encodeShortString: ()=>encodeShortString,
                isASCII: ()=>isASCII,
                isDecimalString: ()=>isDecimalString,
                isLongText: ()=>isLongText,
                isShortString: ()=>isShortString,
                isShortText: ()=>isShortText,
                isText: ()=>isText,
                splitLongString: ()=>splitLongString
            });
            var isShortText = val=>isText(val) && isShortString(val)
              , isLongText = val=>isText(val) && !isShortString(val);
            function splitLongString(longStr) {
                const regex = RegExp(`[^]{1,${TEXT_TO_FELT_MAX_LEN}}`, "g");
                return longStr.match(regex) || []
            }
            function encodeShortString(str) {
                if (!isASCII(str))
                    throw new Error(`${str} is not an ASCII string`);
                if (!isShortString(str))
                    throw new Error(`${str} is too long`);
                return addHexPrefix(str.replace(/./g, (char=>char.charCodeAt(0).toString(16))))
            }
            function decodeShortString(str) {
                if (!isASCII(str))
                    throw new Error(`${str} is not an ASCII string`);
                if (isHex(str))
                    return removeHexPrefix(str).replace(/.{2}/g, (hex=>String.fromCharCode(parseInt(hex, 16))));
                if (isDecimalString(str))
                    return decodeShortString("0X".concat(BigInt(str).toString(16)));
                throw new Error(`${str} is not Hex or decimal`)
            }
            var cairo_exports = {};
            __export(cairo_exports, {
                felt: ()=>felt,
                getAbiContractVersion: ()=>getAbiContractVersion,
                getArrayType: ()=>getArrayType,
                isCairo1Abi: ()=>isCairo1Abi,
                isCairo1Type: ()=>isCairo1Type,
                isLen: ()=>isLen,
                isTypeArray: ()=>isTypeArray,
                isTypeBool: ()=>isTypeBool,
                isTypeContractAddress: ()=>isTypeContractAddress,
                isTypeEnum: ()=>isTypeEnum,
                isTypeEthAddress: ()=>isTypeEthAddress,
                isTypeFelt: ()=>isTypeFelt,
                isTypeLitteral: ()=>isTypeLitteral,
                isTypeNamedTuple: ()=>isTypeNamedTuple,
                isTypeOption: ()=>isTypeOption,
                isTypeResult: ()=>isTypeResult,
                isTypeStruct: ()=>isTypeStruct,
                isTypeTuple: ()=>isTypeTuple,
                isTypeUint: ()=>isTypeUint,
                isTypeUint256: ()=>isTypeUint256,
                tuple: ()=>tuple,
                uint256: ()=>uint256
            });
            var uint256_exports = {};
            __export(uint256_exports, {
                UINT_128_MAX: ()=>UINT_128_MAX,
                UINT_256_MAX: ()=>UINT_256_MAX,
                bnToUint256: ()=>bnToUint256,
                isUint256: ()=>isUint256,
                uint256ToBN: ()=>uint256ToBN
            });
            var UINT_128_MAX = (1n << 128n) - 1n
              , UINT_256_MAX = (1n << 256n) - 1n;
            function uint256ToBN(uint2562) {
                return (toBigInt(uint2562.high) << 128n) + toBigInt(uint2562.low)
            }
            function isUint256(bn) {
                return toBigInt(bn) <= UINT_256_MAX
            }
            function bnToUint256(bn) {
                const bi = toBigInt(bn);
                if (!isUint256(bi))
                    throw new Error("Number is too large");
                return {
                    low: addHexPrefix((bi & UINT_128_MAX).toString(16)),
                    high: addHexPrefix((bi >> 128n).toString(16))
                }
            }
            var isLen = name=>/_len$/.test(name)
              , isTypeFelt = type=>"felt" === type || "core::felt252" === type
              , isTypeArray = type=>/\*/.test(type) || type.startsWith("core::array::Array::") || type.startsWith("core::array::Span::")
              , isTypeTuple = type=>/^\(.*\)$/i.test(type)
              , isTypeNamedTuple = type=>/\(.*\)/i.test(type) && type.includes(":")
              , isTypeStruct = (type,structs)=>type in structs
              , isTypeEnum = (type,enums)=>type in enums
              , isTypeOption = type=>type.startsWith("core::option::Option::")
              , isTypeResult = type=>type.startsWith("core::result::Result::")
              , isTypeUint = type=>Object.values(Uint).includes(type)
              , isTypeLitteral = type=>Object.values(Litteral).includes(type)
              , isTypeUint256 = type=>"core::integer::u256" === type
              , isTypeBool = type=>"core::bool" === type
              , isTypeContractAddress = type=>"core::starknet::contract_address::ContractAddress" === type
              , isTypeEthAddress = type=>"core::starknet::eth_address::EthAddress" === type
              , isCairo1Type = type=>type.includes("::")
              , getArrayType = type=>isCairo1Type(type) ? type.substring(type.indexOf("<") + 1, type.lastIndexOf(">")) : type.replace("*", "");
            function isCairo1Abi(abi) {
                const {cairo} = getAbiContractVersion(abi);
                if (void 0 === cairo)
                    throw Error("Unable to determine Cairo version");
                return "1" === cairo
            }
            function getAbiContractVersion(abi) {
                if (abi.find((it=>"interface" === it.type)))
                    return {
                        cairo: "1",
                        compiler: "2"
                    };
                const testFunction = abi.find((it=>"function" === it.type && (it.inputs.length || it.outputs.length)));
                if (!testFunction)
                    return {
                        cairo: void 0,
                        compiler: void 0
                    };
                const io = testFunction.inputs.length ? testFunction.inputs : testFunction.outputs;
                return isCairo1Type(io[0].type) ? {
                    cairo: "1",
                    compiler: "1"
                } : {
                    cairo: "0",
                    compiler: "0"
                }
            }
            var uint256 = it=>{
                const bn = BigInt(it);
                if (!isUint256(bn))
                    throw new Error("Number is too large");
                return {
                    low: (bn & UINT_128_MAX).toString(10),
                    high: (bn >> 128n).toString(10)
                }
            }
              , tuple = (...args)=>({
                ...args
            });
            function felt(it) {
                if (isBigInt(it) || "number" == typeof it && Number.isInteger(it))
                    return it.toString();
                if (isText(it)) {
                    if (!isShortString(it))
                        throw new Error(`${it} is a long string > 31 chars, felt can store short strings, split it to array of short strings`);
                    const encoded = encodeShortString(it);
                    return BigInt(encoded).toString()
                }
                if ("string" == typeof it && isHex(it))
                    return BigInt(it).toString();
                if ("string" == typeof it && isStringWholeNumber(it))
                    return it;
                if ("boolean" == typeof it)
                    return "" + +it;
                throw new Error(`${it} can't be computed by felt()`)
            }
            var CairoCustomEnum = class {
                constructor(enumContent) {
                    const variantsList = Object.values(enumContent);
                    if (0 === variantsList.length)
                        throw new Error("This Enum must have a least 1 variant");
                    if (1 !== variantsList.filter((content=>void 0 !== content)).length)
                        throw new Error("This Enum must have exactly one active variant");
                    this.variant = enumContent
                }
                unwrap() {
                    const activeVariant = Object.entries(this.variant).find((item=>void 0 !== item[1]));
                    if (void 0 !== activeVariant)
                        return activeVariant[1]
                }
                activeVariant() {
                    const activeVariant = Object.entries(this.variant).find((item=>void 0 !== item[1]));
                    return void 0 === activeVariant ? "" : activeVariant[0]
                }
            }
              , CairoOptionVariant = (CairoOptionVariant2=>(CairoOptionVariant2[CairoOptionVariant2.Some = 0] = "Some",
            CairoOptionVariant2[CairoOptionVariant2.None = 1] = "None",
            CairoOptionVariant2))(CairoOptionVariant || {})
              , CairoOption = class {
                constructor(variant, someContent) {
                    if (!(variant in CairoOptionVariant))
                        throw new Error("Wrong variant : should be CairoOptionVariant.Some or .None.");
                    if (0 === variant) {
                        if (void 0 === someContent)
                            throw new Error('The creation of a Cairo Option with "Some" variant needs a content as input.');
                        this.Some = someContent,
                        this.None = void 0
                    } else
                        this.Some = void 0,
                        this.None = !0
                }
                unwrap() {
                    if (!this.None)
                        return this.Some
                }
                isSome() {
                    return !(void 0 === this.Some)
                }
                isNone() {
                    return !0 === this.None
                }
            }
              , CairoResultVariant = (CairoResultVariant2=>(CairoResultVariant2[CairoResultVariant2.Ok = 0] = "Ok",
            CairoResultVariant2[CairoResultVariant2.Err = 1] = "Err",
            CairoResultVariant2))(CairoResultVariant || {})
              , CairoResult = class {
                constructor(variant, resultContent) {
                    if (!(variant in CairoResultVariant))
                        throw new Error("Wrong variant : should be CairoResultVariant.Ok or .Err.");
                    0 === variant ? (this.Ok = resultContent,
                    this.Err = void 0) : (this.Ok = void 0,
                    this.Err = resultContent)
                }
                unwrap() {
                    if (void 0 !== this.Ok)
                        return this.Ok;
                    if (void 0 !== this.Err)
                        return this.Err;
                    throw new Error("Both Result.Ok and .Err are undefined. Not authorized.")
                }
                isOk() {
                    return !(void 0 === this.Ok)
                }
                isErr() {
                    return !(void 0 === this.Err)
                }
            }
              , guard_isBN = (data,type,key)=>{
                if (!isBigInt(data[key]))
                    throw new Error(`Data and formatter mismatch on ${key}:${type[key]}, expected response data ${key}:${data[key]} to be BN instead it is ${typeof data[key]}`)
            }
              , guard_unknown = (data,type,key)=>{
                throw new Error(`Unhandled formatter type on ${key}:${type[key]} for data ${key}:${data[key]}`)
            }
            ;
            function formatter(data, type, sameType) {
                return Object.entries(data).reduce(((acc,[key,value])=>{
                    const elType = sameType ?? type[key];
                    if (!(key in type) && !sameType)
                        return acc[key] = value,
                        acc;
                    if ("string" === elType) {
                        if (Array.isArray(data[key])) {
                            const arrayStr = formatter(data[key], data[key].map((_=>elType)));
                            return acc[key] = Object.values(arrayStr).join(""),
                            acc
                        }
                        return guard_isBN(data, type, key),
                        acc[key] = decodeShortString(value),
                        acc
                    }
                    if ("number" === elType)
                        return guard_isBN(data, type, key),
                        acc[key] = Number(value),
                        acc;
                    if ("function" == typeof elType)
                        return acc[key] = elType(value),
                        acc;
                    if (Array.isArray(elType)) {
                        const arrayObj = formatter(data[key], elType, elType[0]);
                        return acc[key] = Object.values(arrayObj),
                        acc
                    }
                    return "object" == typeof elType ? (acc[key] = formatter(data[key], elType),
                    acc) : (guard_unknown(data, type, key),
                    acc)
                }
                ), {})
            }
            function createAbiParser(abi) {
                const version = function(abi) {
                    return abi.find((it=>"interface" === it.type)) ? 2 : isCairo1Abi(abi) ? 1 : 0
                }(abi);
                if (0 === version || 1 === version)
                    return new class {
                        constructor(abi) {
                            this.abi = abi
                        }
                        methodInputsLength(abiMethod) {
                            return abiMethod.inputs.reduce(((acc,input)=>isLen(input.name) ? acc : acc + 1), 0)
                        }
                        getMethod(name) {
                            return this.abi.find((it=>it.name === name))
                        }
                        getLegacyFormat() {
                            return this.abi
                        }
                    }
                    (abi);
                if (2 === version)
                    return new class {
                        constructor(abi) {
                            this.abi = abi
                        }
                        methodInputsLength(abiMethod) {
                            return abiMethod.inputs.length
                        }
                        getMethod(name) {
                            return this.abi.find((it=>"interface" === it.type)).items.find((it=>it.name === name))
                        }
                        getLegacyFormat() {
                            return this.abi.flatMap((e=>"interface" === e.type ? e.items : e))
                        }
                    }
                    (abi);
                throw Error(`Unsupported ABI version ${version}`)
            }
            function isNoConstructorValid(method, argsCalldata, abiMethod) {
                return "constructor" === method && !abiMethod && !argsCalldata.length
            }
            function parseSubTuple(s) {
                if (!s.includes("("))
                    return {
                        subTuple: [],
                        result: s
                    };
                const subTuple = [];
                let result = ""
                  , i = 0;
                for (; i < s.length; ) {
                    if ("(" === s[i]) {
                        let counter = 1;
                        const lBracket = i;
                        for (i++; counter; )
                            ")" === s[i] && counter--,
                            "(" === s[i] && counter++,
                            i++;
                        subTuple.push(s.substring(lBracket, i)),
                        result += " ",
                        i--
                    } else
                        result += s[i];
                    i++
                }
                return {
                    subTuple,
                    result
                }
            }
            function extractTupleMemberTypes(type) {
                return isCairo1Type(type) ? function(type) {
                    const cleanType = type.replace(/\s/g, "").slice(1, -1)
                      , {subTuple, result} = parseSubTuple(cleanType);
                    return result.split(",").map((it=>subTuple.length ? it.replace(" ", subTuple.shift()) : it))
                }(type) : function(type) {
                    const cleanType = type.replace(/\s/g, "").slice(1, -1)
                      , {subTuple, result} = parseSubTuple(cleanType);
                    let recomposed = result.split(",").map((it=>subTuple.length ? it.replace(" ", subTuple.shift()) : it));
                    return isTypeNamedTuple(type) && (recomposed = recomposed.reduce(((acc,it)=>acc.concat(function(namedTuple) {
                        const name = namedTuple.substring(0, namedTuple.indexOf(":"));
                        return {
                            name,
                            type: namedTuple.substring(name.length + ":".length)
                        }
                    }(it))), [])),
                    recomposed
                }(type)
            }
            function orderPropsByAbi(unorderedObject, abiOfObject, structs, enums) {
                const orderInput = (unorderedItem,abiType)=>{
                    if (isTypeArray(abiType))
                        return function(myArray, abiParam) {
                            const typeInArray = getArrayType(abiParam);
                            if ("string" == typeof myArray)
                                return myArray;
                            return myArray.map((myElem=>orderInput(myElem, typeInArray)))
                        }(unorderedItem, abiType);
                    if (isTypeEnum(abiType, enums)) {
                        const abiObj = enums[abiType];
                        return orderEnum(unorderedItem, abiObj)
                    }
                    if (isTypeTuple(abiType))
                        return function(unorderedObject2, abiParam) {
                            const orderedObject2 = extractTupleMemberTypes(abiParam).reduce(((orderedObject,abiTypeCairoX,index)=>{
                                const myObjKeys = Object.keys(unorderedObject2)
                                  , setProperty = value=>Object.defineProperty(orderedObject, index.toString(), {
                                    enumerable: !0,
                                    value: value ?? unorderedObject2[myObjKeys[index]]
                                })
                                  , abiType = abiTypeCairoX?.type ? abiTypeCairoX.type : abiTypeCairoX;
                                return setProperty(orderInput(unorderedObject2[myObjKeys[index]], abiType)),
                                orderedObject
                            }
                            ), {});
                            return orderedObject2
                        }(unorderedItem, abiType);
                    if (isTypeEthAddress(abiType))
                        return unorderedItem;
                    if (isTypeUint256(abiType)) {
                        const u256 = unorderedItem;
                        if ("object" != typeof u256)
                            return u256;
                        if (!("low"in u256) || !("high"in u256))
                            throw Error(`Your object includes the property : ${abiType}, containing an Uint256 object without the 'low' and 'high' keys.`);
                        return {
                            low: u256.low,
                            high: u256.high
                        }
                    }
                    if (isTypeStruct(abiType, structs)) {
                        const abiOfStruct = structs[abiType].members;
                        return orderStruct(unorderedItem, abiOfStruct)
                    }
                    return unorderedItem
                }
                  , orderStruct = (unorderedObject2,abiObject)=>abiObject.reduce(((orderedObject,abiParam)=>{
                    if ("undefined" === unorderedObject2[abiParam.name] && (isCairo1Type(abiParam.type) || !isLen(abiParam.name)))
                        throw Error(`Your object needs a property with key : ${abiParam.name} .`);
                    var value;
                    return value = orderInput(unorderedObject2[abiParam.name], abiParam.type),
                    Object.defineProperty(orderedObject, abiParam.name, {
                        enumerable: !0,
                        value: value ?? unorderedObject2[abiParam.name]
                    }),
                    orderedObject
                }
                ), {});
                const orderEnum = (unorderedObject2,abiObject)=>{
                    if (isTypeResult(abiObject.name)) {
                        const unorderedResult = unorderedObject2
                          , resultOkType = abiObject.name.substring(abiObject.name.indexOf("<") + 1, abiObject.name.lastIndexOf(","))
                          , resultErrType = abiObject.name.substring(abiObject.name.indexOf(",") + 1, abiObject.name.lastIndexOf(">"));
                        return unorderedResult.isOk() ? new CairoResult(0,orderInput(unorderedObject2.unwrap(), resultOkType)) : new CairoResult(1,orderInput(unorderedObject2.unwrap(), resultErrType))
                    }
                    if (isTypeOption(abiObject.name)) {
                        const unorderedOption = unorderedObject2
                          , resultSomeType = abiObject.name.substring(abiObject.name.indexOf("<") + 1, abiObject.name.lastIndexOf(">"));
                        return unorderedOption.isSome() ? new CairoOption(0,orderInput(unorderedOption.unwrap(), resultSomeType)) : new CairoOption(1,{})
                    }
                    const unorderedCustomEnum = unorderedObject2
                      , newEntries = Object.entries(unorderedCustomEnum.variant).map((variant=>{
                        if (void 0 === variant[1])
                            return variant;
                        const variantType = abiObject.type.substring(abiObject.type.lastIndexOf("<") + 1, abiObject.type.lastIndexOf(">"));
                        return "()" === variantType ? variant : [variant[0], orderInput(unorderedCustomEnum.unwrap(), variantType)]
                    }
                    ));
                    return new CairoCustomEnum(Object.fromEntries(newEntries))
                }
                ;
                return abiOfObject.reduce(((orderedObject,abiParam)=>{
                    return isLen(abiParam.name) && !isCairo1Type(abiParam.type) || (value = orderInput(unorderedObject[abiParam.name], abiParam.type),
                    Object.defineProperty(orderedObject, abiParam.name, {
                        enumerable: !0,
                        value
                    })),
                    orderedObject;
                    var value
                }
                ), {})
            }
            function parseBaseTypes(type, val) {
                if (!0 === isTypeUint256(type)) {
                    const el_uint256 = uint256(val);
                    return [felt(el_uint256.low), felt(el_uint256.high)]
                }
                return felt(val)
            }
            function parseUint256(element) {
                if ("object" == typeof element) {
                    const {low, high} = element;
                    return [felt(low), felt(high)]
                }
                const el_uint256 = uint256(element);
                return [felt(el_uint256.low), felt(el_uint256.high)]
            }
            function parseCalldataValue(element, type, structs, enums) {
                if (void 0 === element)
                    throw Error(`Missing parameter for type ${type}`);
                if (Array.isArray(element)) {
                    const result = [];
                    result.push(felt(element.length));
                    const arrayType = getArrayType(type);
                    return element.reduce(((acc,it)=>acc.concat(parseCalldataValue(it, arrayType, structs, enums))), result)
                }
                if (structs[type] && structs[type].members.length) {
                    if (isTypeUint256(type))
                        return parseUint256(element);
                    if ("core::starknet::eth_address::EthAddress" === type)
                        return parseBaseTypes(type, element);
                    const {members} = structs[type]
                      , subElement = element;
                    return members.reduce(((acc,it)=>acc.concat(parseCalldataValue(subElement[it.name], it.type, structs, enums))), [])
                }
                if (isTypeTuple(type)) {
                    const tupled = function(element, typeStr) {
                        const memberTypes = extractTupleMemberTypes(typeStr)
                          , elements = Object.values(element);
                        if (elements.length !== memberTypes.length)
                            throw Error(`ParseTuple: provided and expected abi tuple size do not match.\n      provided: ${elements} \n      expected: ${memberTypes}`);
                        return memberTypes.map(((it,dx)=>({
                            element: elements[dx],
                            type: it.type ?? it
                        })))
                    }(element, type);
                    return tupled.reduce(((acc,it)=>{
                        const parsedData = parseCalldataValue(it.element, it.type, structs, enums);
                        return acc.concat(parsedData)
                    }
                    ), [])
                }
                if (isTypeUint256(type))
                    return parseUint256(element);
                if (isTypeEnum(type, enums)) {
                    const {variants} = enums[type];
                    if (isTypeOption(type)) {
                        const myOption = element;
                        if (myOption.isSome()) {
                            const listTypeVariant2 = variants.find((variant=>"Some" === variant.name));
                            if (void 0 === listTypeVariant2)
                                throw Error("Error in abi : Option has no 'Some' variant.");
                            const typeVariantSome = listTypeVariant2.type;
                            if ("()" === typeVariantSome)
                                return (0).toString();
                            const parsedParameter2 = parseCalldataValue(myOption.unwrap(), typeVariantSome, structs, enums);
                            return Array.isArray(parsedParameter2) ? [(0).toString(), ...parsedParameter2] : [(0).toString(), parsedParameter2]
                        }
                        return 1..toString()
                    }
                    if (isTypeResult(type)) {
                        const myResult = element;
                        if (myResult.isOk()) {
                            const listTypeVariant3 = variants.find((variant=>"Ok" === variant.name));
                            if (void 0 === listTypeVariant3)
                                throw Error("Error in abi : Result has no 'Ok' variant.");
                            const typeVariantOk = listTypeVariant3.type;
                            if ("()" === typeVariantOk)
                                return (0).toString();
                            const parsedParameter3 = parseCalldataValue(myResult.unwrap(), typeVariantOk, structs, enums);
                            return Array.isArray(parsedParameter3) ? [(0).toString(), ...parsedParameter3] : [(0).toString(), parsedParameter3]
                        }
                        const listTypeVariant2 = variants.find((variant=>"Err" === variant.name));
                        if (void 0 === listTypeVariant2)
                            throw Error("Error in abi : Result has no 'Err' variant.");
                        const typeVariantErr = listTypeVariant2.type;
                        if ("()" === typeVariantErr)
                            return 1..toString();
                        const parsedParameter2 = parseCalldataValue(myResult.unwrap(), typeVariantErr, structs, enums);
                        return Array.isArray(parsedParameter2) ? [1..toString(), ...parsedParameter2] : [1..toString(), parsedParameter2]
                    }
                    const myEnum = element
                      , activeVariant = myEnum.activeVariant()
                      , listTypeVariant = variants.find((variant=>variant.name === activeVariant));
                    if (void 0 === listTypeVariant)
                        throw Error(`Not find in abi : Enum has no '${activeVariant}' variant.`);
                    const typeActiveVariant = listTypeVariant.type
                      , numActiveVariant = variants.findIndex((variant=>variant.name === activeVariant));
                    if ("()" === typeActiveVariant)
                        return numActiveVariant.toString();
                    const parsedParameter = parseCalldataValue(myEnum.unwrap(), typeActiveVariant, structs, enums);
                    return Array.isArray(parsedParameter) ? [numActiveVariant.toString(), ...parsedParameter] : [numActiveVariant.toString(), parsedParameter]
                }
                if ("object" == typeof element)
                    throw Error(`Parameter ${element} do not align with abi parameter ${type}`);
                return parseBaseTypes(type, element)
            }
            function parseBaseTypes2(type, it) {
                let temp;
                switch (!0) {
                case isTypeBool(type):
                    return temp = it.next().value,
                    Boolean(BigInt(temp));
                case isTypeUint256(type):
                    return uint256ToBN({
                        low: it.next().value,
                        high: it.next().value
                    });
                default:
                    return temp = it.next().value,
                    BigInt(temp)
                }
            }
            function parseResponseValue(responseIterator, element, structs, enums) {
                if ("()" === element.type)
                    return {};
                if (isTypeUint256(element.type)) {
                    return uint256ToBN({
                        low: responseIterator.next().value,
                        high: responseIterator.next().value
                    })
                }
                if (isTypeArray(element.type)) {
                    const parsedDataArr = []
                      , el = {
                        name: "",
                        type: getArrayType(element.type)
                    }
                      , len = BigInt(responseIterator.next().value);
                    for (; parsedDataArr.length < len; )
                        parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));
                    return parsedDataArr
                }
                if (structs && element.type in structs && structs[element.type])
                    return "core::starknet::eth_address::EthAddress" === element.type ? parseBaseTypes2(element.type, responseIterator) : structs[element.type].members.reduce(((acc,el)=>(acc[el.name] = parseResponseValue(responseIterator, el, structs, enums),
                    acc)), {});
                if (enums && element.type in enums && enums[element.type]) {
                    const variantNum = Number(responseIterator.next().value)
                      , rawEnum = enums[element.type].variants.reduce(((acc,variant,num)=>num === variantNum ? (acc[variant.name] = parseResponseValue(responseIterator, {
                        name: "",
                        type: variant.type
                    }, structs, enums),
                    acc) : (acc[variant.name] = void 0,
                    acc)), {});
                    if (element.type.startsWith("core::option::Option")) {
                        const content = 0 === variantNum ? rawEnum.Some : void 0;
                        return new CairoOption(variantNum,content)
                    }
                    if (element.type.startsWith("core::result::Result")) {
                        let content;
                        return content = 0 === variantNum ? rawEnum.Ok : rawEnum.Err,
                        new CairoResult(variantNum,content)
                    }
                    return new CairoCustomEnum(rawEnum)
                }
                if (isTypeTuple(element.type)) {
                    return extractTupleMemberTypes(element.type).reduce(((acc,it,idx)=>{
                        const name = it?.name ? it.name : idx
                          , el = {
                            name,
                            type: it?.type ? it.type : it
                        };
                        return acc[name] = parseResponseValue(responseIterator, el, structs, enums),
                        acc
                    }
                    ), {})
                }
                if (isTypeArray(element.type)) {
                    const parsedDataArr = []
                      , el = {
                        name: "",
                        type: getArrayType(element.type)
                    }
                      , len = BigInt(responseIterator.next().value);
                    for (; parsedDataArr.length < len; )
                        parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));
                    return parsedDataArr
                }
                return parseBaseTypes2(element.type, responseIterator)
            }
            function responseParser(responseIterator, output, structs, enums, parsedResult) {
                const {name, type} = output;
                let temp;
                switch (!0) {
                case isLen(name):
                    return temp = responseIterator.next().value,
                    BigInt(temp);
                case structs && type in structs || isTypeTuple(type):
                case enums && isTypeEnum(type, enums):
                    return parseResponseValue(responseIterator, output, structs, enums);
                case isTypeArray(type):
                    if (isCairo1Type(type))
                        return parseResponseValue(responseIterator, output, structs, enums);
                    const parsedDataArr = [];
                    if (parsedResult && parsedResult[`${name}_len`]) {
                        const arrLen = parsedResult[`${name}_len`];
                        for (; parsedDataArr.length < arrLen; )
                            parsedDataArr.push(parseResponseValue(responseIterator, {
                                name,
                                type: output.type.replace("*", "")
                            }, structs, enums))
                    }
                    return parsedDataArr;
                default:
                    return parseBaseTypes2(type, responseIterator)
                }
            }
            var validateFelt = (parameter,input)=>{
                if (assert("string" == typeof parameter || "number" == typeof parameter || "bigint" == typeof parameter, `Validate: arg ${input.name} should be a felt typed as (String, Number or BigInt)`),
                "string" == typeof parameter && !isHex(parameter))
                    return;
                const param = BigInt(parameter.toString(10));
                assert(param >= 0n && param <= 2n ** 252n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`)
            }
              , validateUint = (parameter,input)=>{
                "number" == typeof parameter && assert(parameter <= Number.MAX_SAFE_INTEGER, "Validation: Parameter is to large to be typed as Number use (BigInt or String)"),
                assert("string" == typeof parameter || "number" == typeof parameter || "bigint" == typeof parameter || "object" == typeof parameter && "low"in parameter && "high"in parameter, `Validate: arg ${input.name} of cairo type ${input.type} should be type (String, Number or BigInt), but is ${typeof parameter} ${parameter}.`);
                const param = "object" == typeof parameter ? uint256ToBN(parameter) : toBigInt(parameter);
                switch (input.type) {
                case "core::integer::u8":
                    assert(param >= 0n && param <= 255n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0 - 255]`);
                    break;
                case "core::integer::u16":
                    assert(param >= 0n && param <= 65535n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 65535]`);
                    break;
                case "core::integer::u32":
                    assert(param >= 0n && param <= 4294967295n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 4294967295]`);
                    break;
                case "core::integer::u64":
                    assert(param >= 0n && param <= 2n ** 64n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^64-1]`);
                    break;
                case "core::integer::u128":
                    assert(param >= 0n && param <= 2n ** 128n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^128-1]`);
                    break;
                case "core::integer::u256":
                    assert(param >= 0n && param <= 2n ** 256n - 1n, `Validate: arg ${input.name} is ${input.type} 0 - 2^256-1`);
                    break;
                case "core::starknet::class_hash::ClassHash":
                case "core::starknet::contract_address::ContractAddress":
                    assert(param >= 0n && param <= 2n ** 252n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`)
                }
            }
              , validateBool = (parameter,input)=>{
                assert("boolean" == typeof parameter, `Validate: arg ${input.name} of cairo type ${input.type} should be type (Boolean)`)
            }
              , validateStruct = (parameter,input,structs)=>{
                if ("core::integer::u256" !== input.type)
                    if ("core::starknet::eth_address::EthAddress" !== input.type)
                        assert("object" == typeof parameter && !Array.isArray(parameter), `Validate: arg ${input.name} is cairo type struct (${input.type}), and should be defined as js object (not array)`),
                        structs[input.type].members.forEach((({name})=>{
                            assert(Object.keys(parameter).includes(name), `Validate: arg ${input.name} should have a property ${name}`)
                        }
                        ));
                    else {
                        assert("object" != typeof parameter, `EthAddress type is waiting a BigNumberish. Got ${parameter}`);
                        const param = BigInt(parameter.toString(10));
                        assert(param >= 0n && param <= 2n ** 160n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^160-1]`)
                    }
                else
                    validateUint(parameter, input)
            }
              , validateEnum = (parameter,input)=>{
                assert("object" == typeof parameter && !Array.isArray(parameter), `Validate: arg ${input.name} is cairo type Enum (${input.type}), and should be defined as js object (not array)`);
                const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(parameter))
                  , keys = [...Object.getOwnPropertyNames(parameter), ...methodsKeys];
                if (!(isTypeOption(input.type) && keys.includes("isSome") && keys.includes("isNone") || isTypeResult(input.type) && keys.includes("isOk") && keys.includes("isErr") || keys.includes("variant") && keys.includes("activeVariant")))
                    throw new Error(`Validate Enum: argument ${input.name}, type ${input.type}, value received ${parameter}, is not an Enum.`)
            }
              , validateTuple = (parameter,input)=>{
                assert("object" == typeof parameter && !Array.isArray(parameter), `Validate: arg ${input.name} should be a tuple (defined as object)`)
            }
              , validateArray = (parameter,input,structs,enums)=>{
                const baseType = getArrayType(input.type);
                if (!isTypeFelt(baseType) || !isLongText(parameter))
                    switch (assert(Array.isArray(parameter), `Validate: arg ${input.name} should be an Array`),
                    !0) {
                    case isTypeFelt(baseType):
                        parameter.forEach((param=>validateFelt(param, input)));
                        break;
                    case isTypeTuple(baseType):
                        parameter.forEach((it=>validateTuple(it, {
                            name: input.name,
                            type: baseType
                        })));
                        break;
                    case isTypeArray(baseType):
                        parameter.forEach((param=>validateArray(param, {
                            name: "",
                            type: baseType
                        }, structs, enums)));
                        break;
                    case isTypeStruct(baseType, structs):
                        parameter.forEach((it=>validateStruct(it, {
                            name: input.name,
                            type: baseType
                        }, structs)));
                        break;
                    case isTypeEnum(baseType, enums):
                        parameter.forEach((it=>validateEnum(it, {
                            name: input.name,
                            type: baseType
                        })));
                        break;
                    case isTypeUint(baseType) || isTypeLitteral(baseType):
                        parameter.forEach((param=>validateUint(param, input)));
                        break;
                    case isTypeBool(baseType):
                        parameter.forEach((param=>validateBool(param, input)));
                        break;
                    default:
                        throw new Error(`Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`)
                    }
            }
            ;
            function validateFields(abiMethod, args, structs, enums) {
                abiMethod.inputs.reduce(((acc,input)=>{
                    const parameter = args[acc];
                    switch (!0) {
                    case isLen(input.name):
                        return acc;
                    case isTypeFelt(input.type):
                        validateFelt(parameter, input);
                        break;
                    case isTypeUint(input.type) || isTypeLitteral(input.type):
                        validateUint(parameter, input);
                        break;
                    case isTypeBool(input.type):
                        validateBool(parameter, input);
                        break;
                    case isTypeArray(input.type):
                        validateArray(parameter, input, structs, enums);
                        break;
                    case isTypeStruct(input.type, structs):
                        validateStruct(parameter, input, structs);
                        break;
                    case isTypeEnum(input.type, enums):
                        validateEnum(parameter, input);
                        break;
                    case isTypeTuple(input.type):
                        validateTuple(parameter, input);
                        break;
                    default:
                        throw new Error(`Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`)
                    }
                    return acc + 1
                }
                ), 0)
            }
            var CallData = class {
                constructor(abi) {
                    this.structs = CallData.getAbiStruct(abi),
                    this.enums = CallData.getAbiEnum(abi),
                    this.parser = createAbiParser(abi),
                    this.abi = this.parser.getLegacyFormat()
                }
                validate(type, method, args=[]) {
                    if ("DEPLOY" !== type) {
                        assert(this.abi.filter((abi=>{
                            if ("function" !== abi.type)
                                return !1;
                            const isView = "view" === abi.stateMutability || "view" === abi.state_mutability;
                            return "INVOKE" === type ? !isView : isView
                        }
                        )).map((abi=>abi.name)).includes(method), ("INVOKE" === type ? "invocable" : "viewable") + " method not found in abi")
                    }
                    const abiMethod = this.abi.find((abi=>"DEPLOY" === type ? abi.name === method && "constructor" === abi.type : abi.name === method && "function" === abi.type));
                    if (isNoConstructorValid(method, args, abiMethod))
                        return;
                    const inputsLength = this.parser.methodInputsLength(abiMethod);
                    if (args.length !== inputsLength)
                        throw Error(`Invalid number of arguments, expected ${inputsLength} arguments, but got ${args.length}`);
                    validateFields(abiMethod, args, this.structs, this.enums)
                }
                compile(method, argsCalldata) {
                    const abiMethod = this.abi.find((abiFunction=>abiFunction.name === method));
                    if (isNoConstructorValid(method, argsCalldata, abiMethod))
                        return [];
                    let args;
                    if (Array.isArray(argsCalldata))
                        args = argsCalldata;
                    else {
                        const orderedObject = orderPropsByAbi(argsCalldata, abiMethod.inputs, this.structs, this.enums);
                        args = Object.values(orderedObject),
                        validateFields(abiMethod, args, this.structs, this.enums)
                    }
                    const argsIterator = args[Symbol.iterator]()
                      , callArray = abiMethod.inputs.reduce(((acc,input)=>isLen(input.name) && !isCairo1Type(input.type) ? acc : acc.concat(function(argsIterator, input, structs, enums) {
                        const {name, type} = input;
                        let {value} = argsIterator.next();
                        switch (!0) {
                        case isTypeArray(type):
                            if (!Array.isArray(value) && !isText(value))
                                throw Error(`ABI expected parameter ${name} to be array or long string, got ${value}`);
                            return "string" == typeof value && (value = splitLongString(value)),
                            parseCalldataValue(value, input.type, structs, enums);
                        case "core::starknet::eth_address::EthAddress" === type:
                            return parseBaseTypes(type, value);
                        case isTypeStruct(type, structs) || isTypeTuple(type) || isTypeUint256(type):
                        case isTypeEnum(type, enums):
                            return parseCalldataValue(value, type, structs, enums);
                        default:
                            return parseBaseTypes(type, value)
                        }
                    }(argsIterator, input, this.structs, this.enums))), []);
                    return Object.defineProperty(callArray, "__compiled__", {
                        enumerable: !1,
                        writable: !1,
                        value: !0
                    }),
                    callArray
                }
                static compile(rawArgs) {
                    const createTree = obj=>{
                        const getEntries = (o,prefix=".")=>{
                            const oe = Array.isArray(o) ? [o.length.toString(), ...o] : o;
                            return Object.entries(oe).flatMap((([k,v])=>{
                                let value = v;
                                "entrypoint" === k ? value = getSelectorFromName(value) : isLongText(value) && (value = splitLongString(value));
                                const kk = Array.isArray(oe) && "0" === k ? "$$len" : k;
                                if (isBigInt(value))
                                    return [[`${prefix}${kk}`, felt(value)]];
                                if (Object(value) === value) {
                                    const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(value))
                                      , keys = [...Object.getOwnPropertyNames(value), ...methodsKeys];
                                    if (keys.includes("isSome") && keys.includes("isNone")) {
                                        const myOption = value
                                          , variantNb = myOption.isSome() ? 0 : 1;
                                        return myOption.isSome() ? getEntries({
                                            0: variantNb,
                                            1: myOption.unwrap()
                                        }, `${prefix}${kk}.`) : [[`${prefix}${kk}`, felt(variantNb)]]
                                    }
                                    if (keys.includes("isOk") && keys.includes("isErr")) {
                                        const myResult = value
                                          , variantNb = myResult.isOk() ? 0 : 1;
                                        return getEntries({
                                            0: variantNb,
                                            1: myResult.unwrap()
                                        }, `${prefix}${kk}.`)
                                    }
                                    if (keys.includes("variant") && keys.includes("activeVariant")) {
                                        const myEnum = value
                                          , activeVariant = myEnum.activeVariant()
                                          , activeVariantNb = Object.keys(myEnum.variant).findIndex((variant=>variant === activeVariant));
                                        return "object" == typeof myEnum.unwrap() && 0 === Object.keys(myEnum.unwrap()).length ? [[`${prefix}${kk}`, felt(activeVariantNb)]] : getEntries({
                                            0: activeVariantNb,
                                            1: myEnum.unwrap()
                                        }, `${prefix}${kk}.`)
                                    }
                                    return getEntries(value, `${prefix}${kk}.`)
                                }
                                return [[`${prefix}${kk}`, felt(value)]]
                            }
                            ))
                        }
                        ;
                        return Object.fromEntries(getEntries(obj))
                    }
                    ;
                    let callTreeArray;
                    if (Array.isArray(rawArgs)) {
                        const callTree = createTree({
                            ...rawArgs
                        });
                        callTreeArray = Object.values(callTree)
                    } else {
                        const callTree = createTree(rawArgs);
                        callTreeArray = Object.values(callTree)
                    }
                    return Object.defineProperty(callTreeArray, "__compiled__", {
                        enumerable: !1,
                        writable: !1,
                        value: !0
                    }),
                    callTreeArray
                }
                parse(method, response) {
                    const {outputs} = this.abi.find((abi=>abi.name === method))
                      , responseIterator = response.flat()[Symbol.iterator]()
                      , parsed = outputs.flat().reduce(((acc,output,idx)=>{
                        const propName = output.name ?? idx;
                        return acc[propName] = responseParser(responseIterator, output, this.structs, this.enums, acc),
                        acc[propName] && acc[`${propName}_len`] && delete acc[`${propName}_len`],
                        acc
                    }
                    ), {});
                    return 1 === Object.keys(parsed).length && 0 in parsed ? parsed[0] : parsed
                }
                format(method, response, format) {
                    return formatter(this.parse(method, response), format)
                }
                static getAbiStruct(abi) {
                    return abi.filter((abiEntry=>"struct" === abiEntry.type)).reduce(((acc,abiEntry)=>({
                        ...acc,
                        [abiEntry.name]: abiEntry
                    })), {})
                }
                static getAbiEnum(abi) {
                    const fullEnumList = abi.filter((abiEntry=>"enum" === abiEntry.type)).reduce(((acc,abiEntry)=>({
                        ...acc,
                        [abiEntry.name]: abiEntry
                    })), {});
                    return delete fullEnumList["core::bool"],
                    fullEnumList
                }
                static toCalldata(rawCalldata=[]) {
                    return CallData.compile(rawCalldata)
                }
                static toHex(raw=[]) {
                    return CallData.compile(raw).map((it=>toHex(it)))
                }
            }
              , hash_exports = {};
            __export(hash_exports, {
                calculateContractAddressFromHash: ()=>calculateContractAddressFromHash,
                calculateDeclareTransactionHash: ()=>calculateDeclareTransactionHash,
                calculateDeployAccountTransactionHash: ()=>calculateDeployAccountTransactionHash,
                calculateDeployTransactionHash: ()=>calculateDeployTransactionHash,
                calculateTransactionHash: ()=>calculateTransactionHash,
                calculateTransactionHashCommon: ()=>calculateTransactionHashCommon,
                computeCompiledClassHash: ()=>computeCompiledClassHash,
                computeContractClassHash: ()=>computeContractClassHash,
                computeHashOnElements: ()=>computeHashOnElements,
                computeLegacyContractClassHash: ()=>computeLegacyContractClassHash,
                computeSierraContractClassHash: ()=>computeSierraContractClassHash,
                default: ()=>computeHintedClassHash,
                feeTransactionVersion: ()=>feeTransactionVersion,
                feeTransactionVersion_2: ()=>feeTransactionVersion_2,
                formatSpaces: ()=>formatSpaces,
                getSelector: ()=>getSelector,
                getSelectorFromName: ()=>getSelectorFromName,
                getVersionsByType: ()=>getVersionsByType,
                keccakBn: ()=>keccakBn,
                poseidon: ()=>poseidon,
                starknetKeccak: ()=>starknetKeccak,
                transactionVersion: ()=>transactionVersion,
                transactionVersion_2: ()=>transactionVersion_2
            });
            var import_starknet2 = __webpack_require__(37962)
              , ec_exports = {};
            __export(ec_exports, {
                starkCurve: ()=>starkCurve,
                weierstrass: ()=>weierstrass
            });
            var starkCurve = __toESM(__webpack_require__(37962))
              , weierstrass = __toESM(__webpack_require__(96551))
              , json_exports = {};
            __export(json_exports, {
                parse: ()=>parse2,
                parseAlwaysAsBig: ()=>parseAlwaysAsBig,
                stringify: ()=>stringify2,
                stringifyAlwaysAsBig: ()=>stringifyAlwaysAsBig
            });
            var json = __toESM(__webpack_require__(30484))
              , parseIntAsNumberOrBigInt = x=>{
                if (!json.isInteger(x))
                    return parseFloat(x);
                const v = parseInt(x, 10);
                return Number.isSafeInteger(v) ? v : BigInt(x)
            }
              , parse2 = x=>json.parse(String(x), void 0, parseIntAsNumberOrBigInt)
              , parseAlwaysAsBig = x=>json.parse(String(x), void 0, json.parseNumberAndBigInt)
              , stringify2 = (value,replacer,space,numberStringifiers)=>json.stringify(value, replacer, space, numberStringifiers)
              , stringifyAlwaysAsBig = stringify2
              , poseidon = __toESM(__webpack_require__(33192))
              , transactionVersion = BN_TRANSACTION_VERSION_1
              , transactionVersion_2 = BN_TRANSACTION_VERSION_2
              , feeTransactionVersion = BN_FEE_TRANSACTION_VERSION_1
              , feeTransactionVersion_2 = BN_FEE_TRANSACTION_VERSION_2;
            function getVersionsByType(versionType) {
                return "fee" === versionType ? {
                    v1: feeTransactionVersion,
                    v2: feeTransactionVersion_2
                } : {
                    v1: transactionVersion,
                    v2: transactionVersion_2
                }
            }
            function computeHashOnElements(data) {
                return [...data, data.length].reduce(((x,y)=>starkCurve.pedersen(toBigInt(x), toBigInt(y))), 0).toString()
            }
            function calculateTransactionHashCommon(txHashPrefix, version, contractAddress, entryPointSelector, calldata, maxFee, chainId, additionalData=[]) {
                const calldataHash = computeHashOnElements(calldata);
                return computeHashOnElements([txHashPrefix, version, contractAddress, entryPointSelector, calldataHash, maxFee, chainId, ...additionalData])
            }
            function calculateDeployTransactionHash(contractAddress, constructorCalldata, version, chainId, constructorName="constructor") {
                return calculateTransactionHashCommon("0x6465706c6f79", version, contractAddress, getSelectorFromName(constructorName), constructorCalldata, 0, chainId)
            }
            function calculateDeclareTransactionHash(classHash, senderAddress, version, maxFee, chainId, nonce, compiledClassHash) {
                return calculateTransactionHashCommon("0x6465636c617265", version, senderAddress, 0, [classHash], maxFee, chainId, [nonce, ...compiledClassHash ? [compiledClassHash] : []])
            }
            function calculateDeployAccountTransactionHash(contractAddress, classHash, constructorCalldata, salt, version, maxFee, chainId, nonce) {
                return calculateTransactionHashCommon("0x6465706c6f795f6163636f756e74", version, contractAddress, 0, [classHash, salt, ...constructorCalldata], maxFee, chainId, [nonce])
            }
            function calculateTransactionHash(contractAddress, version, calldata, maxFee, chainId, nonce) {
                return calculateTransactionHashCommon("0x696e766f6b65", version, contractAddress, 0, calldata, maxFee, chainId, [nonce])
            }
            function calculateContractAddressFromHash(salt, classHash, constructorCalldata, deployerAddress) {
                const constructorCalldataHash = computeHashOnElements(CallData.compile(constructorCalldata))
                  , hash = computeHashOnElements([felt("0x535441524b4e45545f434f4e54524143545f41444452455353"), deployerAddress, salt, classHash, constructorCalldataHash]);
                return toHex(BigInt(hash) % ADDR_BOUND)
            }
            function nullSkipReplacer(key, value) {
                return "attributes" === key || "accessible_scopes" === key ? Array.isArray(value) && 0 === value.length ? void 0 : value : "debug_info" === key ? null : null === value ? void 0 : value
            }
            function formatSpaces(json2) {
                let insideQuotes = !1;
                const newString = [];
                for (const char of json2)
                    '"' === char && !1 == (newString.length > 0 && "\\" === newString.slice(-1)[0]) && (insideQuotes = !insideQuotes),
                    insideQuotes ? newString.push(char) : newString.push(":" === char ? ": " : "," === char ? ", " : char);
                return newString.join("")
            }
            function computeHintedClassHash(compiledContract) {
                const {abi, program} = compiledContract
                  , serializedJson = formatSpaces(stringify2({
                    abi,
                    program
                }, nullSkipReplacer));
                return addHexPrefix(starkCurve.keccak(utf8ToArray(serializedJson)).toString(16))
            }
            function computeLegacyContractClassHash(contract) {
                const compiledContract = "string" == typeof contract ? parse2(contract) : contract
                  , apiVersion = toHex(API_VERSION)
                  , externalEntryPointsHash = computeHashOnElements(compiledContract.entry_points_by_type.EXTERNAL.flatMap((e=>[e.selector, e.offset])))
                  , l1HandlerEntryPointsHash = computeHashOnElements(compiledContract.entry_points_by_type.L1_HANDLER.flatMap((e=>[e.selector, e.offset])))
                  , constructorEntryPointHash = computeHashOnElements(compiledContract.entry_points_by_type.CONSTRUCTOR.flatMap((e=>[e.selector, e.offset])))
                  , builtinsHash = computeHashOnElements(compiledContract.program.builtins.map((s=>encodeShortString(s))))
                  , hintedClassHash = computeHintedClassHash(compiledContract)
                  , dataHash = computeHashOnElements(compiledContract.program.data);
                return computeHashOnElements([apiVersion, externalEntryPointsHash, l1HandlerEntryPointsHash, constructorEntryPointHash, builtinsHash, hintedClassHash, dataHash])
            }
            function hashEntryPoint(data) {
                const base = data.flatMap((it=>{
                    return [BigInt(it.selector), BigInt(it.offset), (builtins = it.builtins,
                    (0,
                    import_starknet2.poseidonHashMany)(builtins.flatMap((it=>BigInt(encodeShortString(it))))))];
                    var builtins
                }
                ));
                return (0,
                import_starknet2.poseidonHashMany)(base)
            }
            function computeCompiledClassHash(casm) {
                const compiledClassVersion = BigInt(encodeShortString("COMPILED_CLASS_V1"))
                  , externalEntryPointsHash = hashEntryPoint(casm.entry_points_by_type.EXTERNAL)
                  , l1Handlers = hashEntryPoint(casm.entry_points_by_type.L1_HANDLER)
                  , constructor = hashEntryPoint(casm.entry_points_by_type.CONSTRUCTOR)
                  , bytecode = (0,
                import_starknet2.poseidonHashMany)(casm.bytecode.map((it=>BigInt(it))));
                return toHex((0,
                import_starknet2.poseidonHashMany)([compiledClassVersion, externalEntryPointsHash, l1Handlers, constructor, bytecode]))
            }
            function hashEntryPointSierra(data) {
                const base = data.flatMap((it=>[BigInt(it.selector), BigInt(it.function_idx)]));
                return (0,
                import_starknet2.poseidonHashMany)(base)
            }
            function computeSierraContractClassHash(sierra) {
                const compiledClassVersion = BigInt(encodeShortString("CONTRACT_CLASS_V0.1.0"))
                  , externalEntryPointsHash = hashEntryPointSierra(sierra.entry_points_by_type.EXTERNAL)
                  , l1Handlers = hashEntryPointSierra(sierra.entry_points_by_type.L1_HANDLER)
                  , constructor = hashEntryPointSierra(sierra.entry_points_by_type.CONSTRUCTOR)
                  , abiHash = function(sierra) {
                    const indentString = formatSpaces(stringify2(sierra.abi, null));
                    return BigInt(addHexPrefix(starkCurve.keccak(utf8ToArray(indentString)).toString(16)))
                }(sierra)
                  , sierraProgram = (0,
                import_starknet2.poseidonHashMany)(sierra.sierra_program.map((it=>BigInt(it))));
                return toHex((0,
                import_starknet2.poseidonHashMany)([compiledClassVersion, externalEntryPointsHash, l1Handlers, constructor, abiHash, sierraProgram]))
            }
            function computeContractClassHash(contract) {
                const compiledContract = "string" == typeof contract ? parse2(contract) : contract;
                return "sierra_program"in compiledContract ? computeSierraContractClassHash(compiledContract) : computeLegacyContractClassHash(compiledContract)
            }
            var stark_exports = {};
            __export(stark_exports, {
                compressProgram: ()=>compressProgram,
                decompressProgram: ()=>decompressProgram,
                estimatedFeeToMaxFee: ()=>estimatedFeeToMaxFee,
                formatSignature: ()=>formatSignature,
                makeAddress: ()=>makeAddress,
                randomAddress: ()=>randomAddress,
                signatureToDecimalArray: ()=>signatureToDecimalArray,
                signatureToHexArray: ()=>signatureToHexArray
            });
            var import_starknet3 = __webpack_require__(37962)
              , import_pako = __webpack_require__(68660);
            function compressProgram(jsonProgram) {
                const stringified = "string" == typeof jsonProgram ? jsonProgram : stringify2(jsonProgram);
                return btoaUniversal((0,
                import_pako.gzip)(stringified))
            }
            function decompressProgram(base642) {
                if (Array.isArray(base642))
                    return base642;
                const decompressed = arrayBufferToString((0,
                import_pako.ungzip)(atobUniversal(base642)));
                return parse2(decompressed)
            }
            function randomAddress() {
                const randomKeyPair = import_starknet3.utils.randomPrivateKey();
                return (0,
                import_starknet3.getStarkKey)(randomKeyPair)
            }
            function makeAddress(input) {
                return addHexPrefix(input).toLowerCase()
            }
            function formatSignature(sig) {
                if (!sig)
                    throw Error("formatSignature: provided signature is undefined");
                if (Array.isArray(sig))
                    return sig.map((it=>toHex(it)));
                try {
                    const {r, s} = sig;
                    return [toHex(r), toHex(s)]
                } catch (e) {
                    throw new Error("Signature need to be weierstrass.SignatureType or an array for custom")
                }
            }
            function signatureToDecimalArray(sig) {
                return bigNumberishArrayToDecimalStringArray(formatSignature(sig))
            }
            function signatureToHexArray(sig) {
                return bigNumberishArrayToHexadecimalStringArray(formatSignature(sig))
            }
            function estimatedFeeToMaxFee(estimatedFee, overhead=.5) {
                const overHeadPercent = Math.round(100 * (1 + overhead));
                return toBigInt(estimatedFee) * toBigInt(overHeadPercent) / 100n
            }
            function isSierra(contract) {
                return "sierra_program"in ("string" == typeof contract ? parse2(contract) : contract)
            }
            function extractContractHashes(payload) {
                const response = {
                    ...payload
                };
                if (isSierra(payload.contract) && (!payload.compiledClassHash && payload.casm && (response.compiledClassHash = computeCompiledClassHash(payload.casm)),
                !response.compiledClassHash))
                    throw new Error("Extract compiledClassHash failed, provide (CairoAssembly).casm file or compiledClassHash");
                if (response.classHash = payload.classHash ?? computeContractClassHash(payload.contract),
                !response.classHash)
                    throw new Error("Extract classHash failed, provide (CompiledContract).json file or classHash");
                return response
            }
            function contractClassResponseToLegacyCompiledContract(ccr) {
                if (isSierra(ccr))
                    throw Error("ContractClassResponse need to be LegacyContractClass (cairo0 response class)");
                const contract = ccr;
                return {
                    ...contract,
                    program: decompressProgram(contract.program)
                }
            }
            var import_isomorphic_fetch = __toESM(__webpack_require__(94301))
              , fetchPonyfill_default = "undefined" != typeof window && window.fetch || void 0 !== __webpack_require__.g && __webpack_require__.g.fetch || import_isomorphic_fetch.default
              , provider_exports = {};
            function wait(delay) {
                return new Promise((res=>{
                    setTimeout(res, delay)
                }
                ))
            }
            function createSierraContractClass(contract) {
                const result = {
                    ...contract
                };
                return delete result.sierra_program_debug_info,
                result.abi = formatSpaces(stringify2(contract.abi)),
                result.sierra_program = formatSpaces(stringify2(contract.sierra_program)),
                result.sierra_program = compressProgram(result.sierra_program),
                result
            }
            function parseContract(contract) {
                const parsedContract = "string" == typeof contract ? parse2(contract) : contract;
                return isSierra(contract) ? createSierraContractClass(parsedContract) : {
                    ...parsedContract,
                    ..."program"in parsedContract && {
                        program: compressProgram(parsedContract.program)
                    }
                }
            }
            __export(provider_exports, {
                createSierraContractClass: ()=>createSierraContractClass,
                parseContract: ()=>parseContract,
                wait: ()=>wait
            });
            function fixStack(target, fn=target.constructor) {
                const {captureStackTrace} = Error;
                captureStackTrace && captureStackTrace(target, fn)
            }
            function fixProto(target, prototype) {
                const {setPrototypeOf} = Object;
                setPrototypeOf ? setPrototypeOf(target, prototype) : target.__proto__ = prototype
            }
            var CustomError = class extends Error {
                constructor(message) {
                    super(message),
                    Object.defineProperty(this, "name", {
                        value: new.target.name,
                        enumerable: !1,
                        configurable: !0
                    }),
                    fixProto(this, new.target.prototype),
                    fixStack(this)
                }
            }
              , LibraryError = class extends CustomError {
            }
              , GatewayError = class extends LibraryError {
                constructor(message, errorCode) {
                    super(message),
                    this.errorCode = errorCode
                }
            }
              , HttpError = class extends LibraryError {
                constructor(message, errorCode) {
                    super(message),
                    this.errorCode = errorCode
                }
            }
              , starknetId_exports = {};
            __export(starknetId_exports, {
                StarknetIdContract: ()=>StarknetIdContract,
                getStarknetIdContract: ()=>getStarknetIdContract,
                useDecoded: ()=>useDecoded,
                useEncoded: ()=>useEncoded
            });
            var basicAlphabet = "abcdefghijklmnopqrstuvwxyz0123456789-"
              , basicSizePlusOne = BigInt(basicAlphabet.length + 1)
              , bigAlphabet = "这来"
              , basicAlphabetSize = BigInt(basicAlphabet.length)
              , bigAlphabetSize = BigInt(bigAlphabet.length)
              , bigAlphabetSizePlusOne = BigInt(bigAlphabet.length + 1);
            function extractStars(str) {
                let k = 0;
                for (; str.endsWith(bigAlphabet[bigAlphabet.length - 1]); )
                    str = str.substring(0, str.length - 1),
                    k += 1;
                return [str, k]
            }
            function useDecoded(encoded) {
                let decoded = "";
                return encoded.forEach((subdomain=>{
                    for (; subdomain !== ZERO; ) {
                        const code = subdomain % basicSizePlusOne;
                        if (subdomain /= basicSizePlusOne,
                        code === BigInt(basicAlphabet.length)) {
                            const nextSubdomain = subdomain / bigAlphabetSizePlusOne;
                            if (nextSubdomain === ZERO) {
                                const code2 = subdomain % bigAlphabetSizePlusOne;
                                subdomain = nextSubdomain,
                                decoded += code2 === ZERO ? basicAlphabet[0] : bigAlphabet[Number(code2) - 1]
                            } else {
                                decoded += bigAlphabet[Number(subdomain % bigAlphabetSize)],
                                subdomain /= bigAlphabetSize
                            }
                        } else
                            decoded += basicAlphabet[Number(code)]
                    }
                    const [str,k] = extractStars(decoded);
                    k && (decoded = str + (k % 2 == 0 ? bigAlphabet[bigAlphabet.length - 1].repeat(k / 2 - 1) + bigAlphabet[0] + basicAlphabet[1] : bigAlphabet[bigAlphabet.length - 1].repeat((k - 1) / 2 + 1))),
                    decoded += "."
                }
                )),
                decoded ? decoded.concat("stark") : decoded
            }
            function useEncoded(decoded) {
                let encoded = BigInt(0)
                  , multiplier = BigInt(1);
                if (decoded.endsWith(bigAlphabet[0] + basicAlphabet[1])) {
                    const [str,k] = extractStars(decoded.substring(0, decoded.length - 2));
                    decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(2 * (k + 1))
                } else {
                    const [str,k] = extractStars(decoded);
                    k && (decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(1 + 2 * (k - 1)))
                }
                for (let i = 0; i < decoded.length; i += 1) {
                    const char = decoded[i]
                      , index = basicAlphabet.indexOf(char)
                      , bnIndex = BigInt(basicAlphabet.indexOf(char));
                    if (-1 !== index)
                        i === decoded.length - 1 && decoded[i] === basicAlphabet[0] ? (encoded += multiplier * basicAlphabetSize,
                        multiplier *= basicSizePlusOne,
                        multiplier *= basicSizePlusOne) : (encoded += multiplier * bnIndex,
                        multiplier *= basicSizePlusOne);
                    else if (-1 !== bigAlphabet.indexOf(char)) {
                        encoded += multiplier * basicAlphabetSize,
                        multiplier *= basicSizePlusOne;
                        const newid = (i === decoded.length - 1 ? 1 : 0) + bigAlphabet.indexOf(char);
                        encoded += multiplier * BigInt(newid),
                        multiplier *= bigAlphabetSize
                    }
                }
                return encoded
            }
            var StarknetIdContract = (StarknetIdContract2=>(StarknetIdContract2.MAINNET = "0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678",
            StarknetIdContract2.TESTNET = "0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce",
            StarknetIdContract2))(StarknetIdContract || {});
            function getStarknetIdContract(chainId) {
                switch (chainId) {
                case "0x534e5f4d41494e":
                    return "0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678";
                case "0x534e5f474f45524c49":
                    return "0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce";
                default:
                    throw new Error("Starknet.id is not yet deployed on this network")
                }
            }
            async function getStarkName(provider, address, StarknetIdContract2) {
                const chainId = await provider.getChainId()
                  , contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);
                try {
                    const hexDomain = await provider.callContract({
                        contractAddress: contract,
                        entrypoint: "address_to_domain",
                        calldata: CallData.compile({
                            address
                        })
                    })
                      , stringDomain = useDecoded(hexDomain.result.map((element=>BigInt(element))).slice(1));
                    if (!stringDomain)
                        throw Error("Starkname not found");
                    return stringDomain
                } catch (e) {
                    if (e instanceof Error && "Starkname not found" === e.message)
                        throw e;
                    throw Error("Could not get stark name")
                }
            }
            async function getAddressFromStarkName(provider, name, StarknetIdContract2) {
                const chainId = await provider.getChainId()
                  , contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);
                try {
                    return (await provider.callContract({
                        contractAddress: contract,
                        entrypoint: "domain_to_address",
                        calldata: CallData.compile({
                            domain: [useEncoded(name.replace(".stark", "")).toString(10)]
                        })
                    })).result[0]
                } catch {
                    throw Error("Could not get address from stark name")
                }
            }
            var validBlockTags = Object.values(BlockTag)
              , Block = class {
                constructor(_identifier) {
                    this.hash = null,
                    this.number = null,
                    this.tag = null,
                    this.valueOf = ()=>this.number,
                    this.toString = ()=>this.hash,
                    this.setIdentifier(_identifier)
                }
                setIdentifier(__identifier) {
                    "string" == typeof __identifier && isHex(__identifier) ? this.hash = __identifier : "bigint" == typeof __identifier ? this.hash = toHex(__identifier) : "number" == typeof __identifier ? this.number = __identifier : "string" == typeof __identifier && validBlockTags.includes(__identifier) ? this.tag = __identifier : this.tag = "pending"
                }
                get queryIdentifier() {
                    return null !== this.number ? `blockNumber=${this.number}` : null !== this.hash ? `blockHash=${this.hash}` : `blockNumber=${this.tag}`
                }
                get identifier() {
                    return null !== this.number ? {
                        block_number: this.number
                    } : null !== this.hash ? {
                        block_hash: this.hash
                    } : this.tag
                }
                set identifier(_identifier) {
                    this.setIdentifier(_identifier)
                }
                get sequencerIdentifier() {
                    return null !== this.hash ? {
                        blockHash: this.hash
                    } : {
                        blockNumber: this.number ?? this.tag
                    }
                }
            }
              , getDefaultNodeUrl = (networkName,mute=!1,version=RPC_DEFAULT_VERSION)=>{
                const nodes = RPC_NODES[networkName ?? "SN_GOERLI"];
                return `${nodes[Math.floor(Math.random() * nodes.length)]}${version}`
            }
              , defaultOptions_headers = {
                "Content-Type": "application/json"
            }
              , defaultOptions_blockIdentifier = "pending"
              , defaultOptions_retries = 200
              , RpcProvider = class {
                constructor(optionsOrProvider) {
                    this.responseParser = new class {
                        parseGetBlockResponse(res) {
                            return {
                                timestamp: res.timestamp,
                                block_hash: "block_hash"in res ? res.block_hash : "",
                                block_number: "block_number"in res ? res.block_number : -1,
                                new_root: "new_root"in res ? res.new_root : "",
                                parent_hash: res.parent_hash,
                                status: "status"in res ? res.status : "PENDING",
                                transactions: res.transactions
                            }
                        }
                        parseGetTransactionResponse(res) {
                            return {
                                calldata: "calldata"in res ? res.calldata : [],
                                contract_address: "contract_address"in res ? res.contract_address : "",
                                sender_address: "sender_address"in res ? res.sender_address : "",
                                max_fee: "max_fee"in res ? res.max_fee : "",
                                nonce: "nonce"in res ? res.nonce : "",
                                signature: "signature"in res ? res.signature : [],
                                transaction_hash: res.transaction_hash,
                                version: res.version
                            }
                        }
                        parseFeeEstimateResponse(res) {
                            return {
                                overall_fee: toBigInt(res[0].overall_fee),
                                gas_consumed: toBigInt(res[0].gas_consumed),
                                gas_price: toBigInt(res[0].gas_price)
                            }
                        }
                        parseFeeEstimateBulkResponse(res) {
                            return res.map((val=>({
                                overall_fee: toBigInt(val.overall_fee),
                                gas_consumed: toBigInt(val.gas_consumed),
                                gas_price: toBigInt(val.gas_price)
                            })))
                        }
                        parseCallContractResponse(res) {
                            return {
                                result: res
                            }
                        }
                        parseSimulateTransactionResponse(res) {
                            return res.map((it=>({
                                ...it,
                                suggestedMaxFee: estimatedFeeToMaxFee(BigInt(it.fee_estimation.overall_fee))
                            })))
                        }
                        parseContractClassResponse(res) {
                            return {
                                ...res,
                                abi: "string" == typeof res.abi ? JSON.parse(res.abi) : res.abi
                            }
                        }
                    }
                    ,
                    this.getBlockHashAndNumber = this.getBlockLatestAccepted,
                    this.getStateUpdate = this.getBlockStateUpdate,
                    this.traceBlockTransactions = this.getBlockTransactionsTraces,
                    this.getTransactionCount = this.getBlockTransactionCount,
                    this.traceTransaction = this.getTransactionTrace,
                    this.getSimulateTransaction = this.simulateTransaction;
                    const {nodeUrl, retries, headers, blockIdentifier, chainId, rpcVersion} = optionsOrProvider || {};
                    Object.values(NetworkName).includes(nodeUrl) ? this.nodeUrl = getDefaultNodeUrl(nodeUrl, optionsOrProvider?.default, rpcVersion) : this.nodeUrl = nodeUrl || getDefaultNodeUrl(void 0, optionsOrProvider?.default, rpcVersion),
                    this.retries = retries || defaultOptions_retries,
                    this.headers = {
                        ...defaultOptions_headers,
                        ...headers
                    },
                    this.blockIdentifier = blockIdentifier || defaultOptions_blockIdentifier,
                    this.chainId = chainId
                }
                fetch(method, params, id=0) {
                    const rpcRequestBody = {
                        id,
                        jsonrpc: "2.0",
                        method,
                        ...params && {
                            params
                        }
                    };
                    return fetchPonyfill_default(this.nodeUrl, {
                        method: "POST",
                        body: stringify2(rpcRequestBody),
                        headers: this.headers
                    })
                }
                errorHandler(method, params, rpcError, otherError) {
                    if (rpcError) {
                        const {code, message, data} = rpcError;
                        throw new LibraryError(`RPC: ${method} with params ${stringify2(params)}\n ${code}: ${message}: ${stringify2(data)}`)
                    }
                    if (otherError instanceof LibraryError)
                        throw otherError;
                    if (otherError)
                        throw Error(otherError.message)
                }
                async fetchEndpoint(method, params) {
                    try {
                        const rawResult = await this.fetch(method, params)
                          , {error, result} = await rawResult.json();
                        return this.errorHandler(method, params, error),
                        result
                    } catch (error) {
                        throw this.errorHandler(method, params, error?.response?.data, error),
                        error
                    }
                }
                async getChainId() {
                    return this.chainId ?? (this.chainId = await this.fetchEndpoint("starknet_chainId")),
                    this.chainId
                }
                async getSpecVersion() {
                    return this.fetchEndpoint("starknet_specVersion")
                }
                async getNonceForAddress(contractAddress, blockIdentifier=this.blockIdentifier) {
                    const contract_address = toHex(contractAddress)
                      , block_id = new Block(blockIdentifier).identifier;
                    return this.fetchEndpoint("starknet_getNonce", {
                        contract_address,
                        block_id
                    })
                }
                async getBlock(blockIdentifier=this.blockIdentifier) {
                    return this.getBlockWithTxHashes(blockIdentifier).then(this.responseParser.parseGetBlockResponse)
                }
                async getBlockLatestAccepted() {
                    return this.fetchEndpoint("starknet_blockHashAndNumber")
                }
                async getBlockNumber() {
                    return this.fetchEndpoint("starknet_blockNumber")
                }
                async getBlockWithTxHashes(blockIdentifier=this.blockIdentifier) {
                    const block_id = new Block(blockIdentifier).identifier;
                    return this.fetchEndpoint("starknet_getBlockWithTxHashes", {
                        block_id
                    })
                }
                async getBlockWithTxs(blockIdentifier=this.blockIdentifier) {
                    const block_id = new Block(blockIdentifier).identifier;
                    return this.fetchEndpoint("starknet_getBlockWithTxs", {
                        block_id
                    })
                }
                async getBlockStateUpdate(blockIdentifier=this.blockIdentifier) {
                    const block_id = new Block(blockIdentifier).identifier;
                    return this.fetchEndpoint("starknet_getStateUpdate", {
                        block_id
                    })
                }
                async getBlockTransactionsTraces(blockIdentifier=this.blockIdentifier) {
                    const block_id = new Block(blockIdentifier).identifier;
                    return this.fetchEndpoint("starknet_traceBlockTransactions", {
                        block_id
                    })
                }
                async getBlockTransactionCount(blockIdentifier=this.blockIdentifier) {
                    const block_id = new Block(blockIdentifier).identifier;
                    return this.fetchEndpoint("starknet_getBlockTransactionCount", {
                        block_id
                    })
                }
                async getPendingTransactions() {
                    const {transactions} = await this.getBlock("pending");
                    return Promise.all(transactions.map((it=>this.getTransactionByHash(it))))
                }
                async getTransaction(txHash) {
                    return this.getTransactionByHash(txHash).then(this.responseParser.parseGetTransactionResponse)
                }
                async getTransactionByHash(txHash) {
                    const transaction_hash = toHex(txHash);
                    return this.fetchEndpoint("starknet_getTransactionByHash", {
                        transaction_hash
                    })
                }
                async getTransactionByBlockIdAndIndex(blockIdentifier, index) {
                    const block_id = new Block(blockIdentifier).identifier;
                    return this.fetchEndpoint("starknet_getTransactionByBlockIdAndIndex", {
                        block_id,
                        index
                    })
                }
                async getTransactionReceipt(txHash) {
                    const transaction_hash = toHex(txHash);
                    return this.fetchEndpoint("starknet_getTransactionReceipt", {
                        transaction_hash
                    })
                }
                async getTransactionTrace(txHash) {
                    const transaction_hash = toHex(txHash);
                    return this.fetchEndpoint("starknet_traceTransaction", {
                        transaction_hash
                    })
                }
                async getTransactionStatus(transactionHash) {
                    const transaction_hash = toHex(transactionHash);
                    return this.fetchEndpoint("starknet_getTransactionStatus", {
                        transaction_hash
                    })
                }
                async simulateTransaction(invocations, {blockIdentifier=this.blockIdentifier, skipValidate=!1, skipFeeCharge=!0}) {
                    const block_id = new Block(blockIdentifier).identifier
                      , simulationFlags = [];
                    return skipValidate && simulationFlags.push(rpc_exports.ESimulationFlag.SKIP_VALIDATE),
                    skipFeeCharge && simulationFlags.push(rpc_exports.ESimulationFlag.SKIP_FEE_CHARGE),
                    this.fetchEndpoint("starknet_simulateTransactions", {
                        block_id,
                        transactions: invocations.map((it=>this.buildTransaction(it))),
                        simulation_flags: simulationFlags
                    }).then(this.responseParser.parseSimulateTransactionResponse)
                }
                async waitForTransaction(txHash, options) {
                    const transactionHash = toHex(txHash);
                    let {retries} = this
                      , onchain = !1
                      , isErrorState = !1;
                    const retryInterval = options?.retryInterval ?? 5e3
                      , errorStates = options?.errorStates ?? [rpc_exports.ETransactionStatus.REJECTED]
                      , successStates = options?.successStates ?? [rpc_exports.ETransactionExecutionStatus.SUCCEEDED, rpc_exports.ETransactionStatus.ACCEPTED_ON_L2, rpc_exports.ETransactionStatus.ACCEPTED_ON_L1];
                    let txStatus;
                    for (; !onchain; ) {
                        await wait(retryInterval);
                        try {
                            txStatus = await this.getTransactionStatus(transactionHash);
                            const executionStatus = txStatus.execution_status
                              , finalityStatus = txStatus.finality_status;
                            if (!finalityStatus) {
                                throw new Error("waiting for transaction status")
                            }
                            if (errorStates.includes(executionStatus) || errorStates.includes(finalityStatus)) {
                                const message = `${executionStatus}: ${finalityStatus}`
                                  , error = new Error(message);
                                throw error.response = txStatus,
                                isErrorState = !0,
                                error
                            }
                            (successStates.includes(executionStatus) || successStates.includes(finalityStatus)) && (onchain = !0)
                        } catch (error) {
                            if (error instanceof Error && isErrorState)
                                throw error;
                            if (retries <= 0)
                                throw new Error(`waitForTransaction timed-out with retries ${this.retries}`)
                        }
                        retries -= 1
                    }
                    let txReceipt = null;
                    for (; null === txReceipt; ) {
                        try {
                            txReceipt = await this.getTransactionReceipt(transactionHash)
                        } catch (error) {
                            if (retries <= 0)
                                throw new Error(`waitForTransaction timed-out with retries ${this.retries}`)
                        }
                        retries -= 1,
                        await wait(retryInterval)
                    }
                    return txReceipt
                }
                async getStorageAt(contractAddress, key, blockIdentifier=this.blockIdentifier) {
                    const contract_address = toHex(contractAddress)
                      , parsedKey = toStorageKey(key)
                      , block_id = new Block(blockIdentifier).identifier;
                    return this.fetchEndpoint("starknet_getStorageAt", {
                        contract_address,
                        key: parsedKey,
                        block_id
                    })
                }
                async getClassHashAt(contractAddress, blockIdentifier=this.blockIdentifier) {
                    const contract_address = toHex(contractAddress)
                      , block_id = new Block(blockIdentifier).identifier;
                    return this.fetchEndpoint("starknet_getClassHashAt", {
                        block_id,
                        contract_address
                    })
                }
                async getClassByHash(classHash) {
                    return this.getClass(classHash)
                }
                async getClass(classHash, blockIdentifier=this.blockIdentifier) {
                    const class_hash = toHex(classHash)
                      , block_id = new Block(blockIdentifier).identifier;
                    return this.fetchEndpoint("starknet_getClass", {
                        class_hash,
                        block_id
                    }).then(this.responseParser.parseContractClassResponse)
                }
                async getClassAt(contractAddress, blockIdentifier=this.blockIdentifier) {
                    const contract_address = toHex(contractAddress)
                      , block_id = new Block(blockIdentifier).identifier;
                    return this.fetchEndpoint("starknet_getClassAt", {
                        block_id,
                        contract_address
                    }).then(this.responseParser.parseContractClassResponse)
                }
                async getCode(_contractAddress, _blockIdentifier) {
                    throw new Error("RPC does not implement getCode function")
                }
                async getContractVersion(contractAddress, classHash, {blockIdentifier=this.blockIdentifier, compiler=!0}={}) {
                    let contractClass;
                    if (contractAddress)
                        contractClass = await this.getClassAt(contractAddress, blockIdentifier);
                    else {
                        if (!classHash)
                            throw Error("getContractVersion require contractAddress or classHash");
                        contractClass = await this.getClass(classHash, blockIdentifier)
                    }
                    if (isSierra(contractClass)) {
                        if (compiler) {
                            return {
                                cairo: "1",
                                compiler: getAbiContractVersion(contractClass.abi).compiler
                            }
                        }
                        return {
                            cairo: "1",
                            compiler: void 0
                        }
                    }
                    return {
                        cairo: "0",
                        compiler: "0"
                    }
                }
                async getEstimateFee(invocation, invocationDetails, blockIdentifier=this.blockIdentifier) {
                    return this.getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier)
                }
                async getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier=this.blockIdentifier) {
                    const block_id = new Block(blockIdentifier).identifier
                      , transaction = this.buildTransaction({
                        type: "INVOKE_FUNCTION",
                        ...invocation,
                        ...invocationDetails
                    }, "fee");
                    return this.fetchEndpoint("starknet_estimateFee", {
                        request: [transaction],
                        block_id
                    }).then(this.responseParser.parseFeeEstimateResponse)
                }
                async getDeclareEstimateFee(invocation, details, blockIdentifier=this.blockIdentifier) {
                    const block_id = new Block(blockIdentifier).identifier
                      , transaction = this.buildTransaction({
                        type: "DECLARE",
                        ...invocation,
                        ...details
                    }, "fee");
                    return this.fetchEndpoint("starknet_estimateFee", {
                        request: [transaction],
                        block_id
                    }).then(this.responseParser.parseFeeEstimateResponse)
                }
                async getDeployAccountEstimateFee(invocation, details, blockIdentifier=this.blockIdentifier) {
                    const block_id = new Block(blockIdentifier).identifier
                      , transaction = this.buildTransaction({
                        type: "DEPLOY_ACCOUNT",
                        ...invocation,
                        ...details
                    }, "fee");
                    return this.fetchEndpoint("starknet_estimateFee", {
                        request: [transaction],
                        block_id
                    }).then(this.responseParser.parseFeeEstimateResponse)
                }
                async getEstimateFeeBulk(invocations, {blockIdentifier=this.blockIdentifier, skipValidate=!1}) {
                    const block_id = new Block(blockIdentifier).identifier;
                    return this.fetchEndpoint("starknet_estimateFee", {
                        request: invocations.map((it=>this.buildTransaction(it, "fee"))),
                        block_id
                    }).then(this.responseParser.parseFeeEstimateBulkResponse)
                }
                async invokeFunction(functionInvocation, details) {
                    return this.fetchEndpoint("starknet_addInvokeTransaction", {
                        invoke_transaction: {
                            sender_address: functionInvocation.contractAddress,
                            calldata: CallData.toHex(functionInvocation.calldata),
                            type: rpc_exports.ETransactionType.INVOKE,
                            max_fee: toHex(details.maxFee || 0),
                            version: "0x1",
                            signature: signatureToHexArray(functionInvocation.signature),
                            nonce: toHex(details.nonce)
                        }
                    })
                }
                async declareContract({contract, signature, senderAddress, compiledClassHash}, details) {
                    return isSierra(contract) ? this.fetchEndpoint("starknet_addDeclareTransaction", {
                        declare_transaction: {
                            type: rpc_exports.ETransactionType.DECLARE,
                            contract_class: {
                                sierra_program: decompressProgram(contract.sierra_program),
                                contract_class_version: contract.contract_class_version,
                                entry_points_by_type: contract.entry_points_by_type,
                                abi: contract.abi
                            },
                            compiled_class_hash: compiledClassHash || "",
                            version: HEX_STR_TRANSACTION_VERSION_2,
                            max_fee: toHex(details.maxFee || 0),
                            signature: signatureToHexArray(signature),
                            sender_address: senderAddress,
                            nonce: toHex(details.nonce)
                        }
                    }) : this.fetchEndpoint("starknet_addDeclareTransaction", {
                        declare_transaction: {
                            type: rpc_exports.ETransactionType.DECLARE,
                            contract_class: {
                                program: contract.program,
                                entry_points_by_type: contract.entry_points_by_type,
                                abi: contract.abi
                            },
                            version: HEX_STR_TRANSACTION_VERSION_1,
                            max_fee: toHex(details.maxFee || 0),
                            signature: signatureToHexArray(signature),
                            sender_address: senderAddress,
                            nonce: toHex(details.nonce)
                        }
                    })
                }
                async deployAccountContract({classHash, constructorCalldata, addressSalt, signature}, details) {
                    return this.fetchEndpoint("starknet_addDeployAccountTransaction", {
                        deploy_account_transaction: {
                            constructor_calldata: CallData.toHex(constructorCalldata || []),
                            class_hash: toHex(classHash),
                            contract_address_salt: toHex(addressSalt || 0),
                            type: rpc_exports.ETransactionType.DEPLOY_ACCOUNT,
                            max_fee: toHex(details.maxFee || 0),
                            version: toHex(details.version || 0),
                            signature: signatureToHexArray(signature),
                            nonce: toHex(details.nonce)
                        }
                    })
                }
                async callContract(call, blockIdentifier=this.blockIdentifier) {
                    const block_id = new Block(blockIdentifier).identifier
                      , result = await this.fetchEndpoint("starknet_call", {
                        request: {
                            contract_address: call.contractAddress,
                            entry_point_selector: getSelectorFromName(call.entrypoint),
                            calldata: CallData.toHex(call.calldata)
                        },
                        block_id
                    });
                    return this.responseParser.parseCallContractResponse(result)
                }
                async estimateMessageFee(message, blockIdentifier=this.blockIdentifier) {
                    const {from_address, to_address, entry_point_selector, payload} = message
                      , formattedMessage = {
                        from_address: toHex(from_address),
                        to_address: toHex(to_address),
                        entry_point_selector: getSelector(entry_point_selector),
                        payload: getHexStringArray(payload)
                    }
                      , block_id = new Block(blockIdentifier).identifier;
                    return this.fetchEndpoint("starknet_estimateMessageFee", {
                        message: formattedMessage,
                        block_id
                    })
                }
                async getSyncingStats() {
                    return this.fetchEndpoint("starknet_syncing")
                }
                async getEvents(eventFilter) {
                    return this.fetchEndpoint("starknet_getEvents", {
                        filter: eventFilter
                    })
                }
                async getStarkName(address, StarknetIdContract2) {
                    return getStarkName(this, address, StarknetIdContract2)
                }
                async getAddressFromStarkName(name, StarknetIdContract2) {
                    return getAddressFromStarkName(this, name, StarknetIdContract2)
                }
                buildTransaction(invocation, versionType) {
                    const defaultVersions = getVersionsByType(versionType)
                      , details = {
                        signature: signatureToHexArray(invocation.signature),
                        nonce: toHex(invocation.nonce),
                        max_fee: toHex(invocation.maxFee || 0)
                    };
                    if ("INVOKE_FUNCTION" === invocation.type)
                        return {
                            type: rpc_exports.ETransactionType.INVOKE,
                            sender_address: invocation.contractAddress,
                            calldata: CallData.toHex(invocation.calldata),
                            version: toHex(invocation.version || defaultVersions.v1),
                            ...details
                        };
                    if ("DECLARE" === invocation.type)
                        return isSierra(invocation.contract) ? {
                            type: invocation.type,
                            contract_class: {
                                ...invocation.contract,
                                sierra_program: decompressProgram(invocation.contract.sierra_program)
                            },
                            compiled_class_hash: invocation.compiledClassHash || "",
                            sender_address: invocation.senderAddress,
                            version: toHex(invocation.version || defaultVersions.v2),
                            ...details
                        } : {
                            type: invocation.type,
                            contract_class: invocation.contract,
                            sender_address: invocation.senderAddress,
                            version: toHex(invocation.version || defaultVersions.v1),
                            ...details
                        };
                    if ("DEPLOY_ACCOUNT" === invocation.type)
                        return {
                            type: invocation.type,
                            constructor_calldata: CallData.toHex(invocation.constructorCalldata || []),
                            class_hash: toHex(invocation.classHash),
                            contract_address_salt: toHex(invocation.addressSalt || 0),
                            version: toHex(invocation.version || defaultVersions.v1),
                            ...details
                        };
                    throw Error("RPC buildTransaction received unknown TransactionType")
                }
            }
              , import_url_join2 = __toESM(__webpack_require__(34078))
              , ResponseParser = class {
            }
              , SequencerAPIResponseParser = class extends ResponseParser {
                parseGetBlockResponse(res) {
                    return {
                        ...res,
                        new_root: res.state_root,
                        parent_hash: res.parent_block_hash,
                        transactions: Object.values(res.transactions).map((value=>"transaction_hash"in value && value.transaction_hash)).filter(Boolean)
                    }
                }
                parseGetTransactionResponse(res) {
                    if ("NOT_RECEIVED" === res.status && "NOT_RECEIVED" === res.finality_status)
                        throw new LibraryError;
                    return {
                        ...res,
                        calldata: "calldata"in res.transaction ? res.transaction.calldata : [],
                        contract_class: "contract_class"in res.transaction ? res.transaction.contract_class : void 0,
                        entry_point_selector: "entry_point_selector"in res.transaction ? res.transaction.entry_point_selector : void 0,
                        max_fee: "max_fee"in res.transaction ? res.transaction.max_fee : void 0,
                        nonce: res.transaction.nonce,
                        sender_address: "sender_address"in res.transaction ? res.transaction.sender_address : void 0,
                        signature: "signature"in res.transaction ? res.transaction.signature : void 0,
                        transaction_hash: "transaction_hash"in res.transaction ? res.transaction.transaction_hash : void 0,
                        version: "version"in res.transaction ? res.transaction.version : void 0
                    }
                }
                parseGetTransactionReceiptResponse(res) {
                    return {
                        ...res,
                        messages_sent: res.l2_to_l1_messages,
                        ..."revert_error"in res && {
                            revert_reason: res.revert_error
                        }
                    }
                }
                parseFeeEstimateResponse(res) {
                    if ("overall_fee"in res) {
                        let gasInfo = {};
                        try {
                            gasInfo = {
                                gas_consumed: toBigInt(res.gas_usage),
                                gas_price: toBigInt(res.gas_price)
                            }
                        } catch {}
                        return {
                            overall_fee: toBigInt(res.overall_fee),
                            ...gasInfo
                        }
                    }
                    return {
                        overall_fee: toBigInt(res.amount)
                    }
                }
                parseFeeEstimateBulkResponse(res) {
                    return [].concat(res).map((item=>{
                        if ("overall_fee"in item) {
                            let gasInfo = {};
                            try {
                                gasInfo = {
                                    gas_consumed: toBigInt(item.gas_usage),
                                    gas_price: toBigInt(item.gas_price)
                                }
                            } catch {}
                            return {
                                overall_fee: toBigInt(item.overall_fee),
                                ...gasInfo
                            }
                        }
                        return {
                            overall_fee: toBigInt(item.amount)
                        }
                    }
                    ))
                }
                parseSimulateTransactionResponse(res) {
                    const suggestedMaxFee = "overall_fee"in res.fee_estimation ? res.fee_estimation.overall_fee : res.fee_estimation.amount;
                    return [{
                        transaction_trace: res.trace,
                        fee_estimation: res.fee_estimation,
                        suggestedMaxFee: estimatedFeeToMaxFee(BigInt(suggestedMaxFee))
                    }]
                }
                parseCallContractResponse(res) {
                    return {
                        result: res.result
                    }
                }
                parseInvokeFunctionResponse(res) {
                    return {
                        transaction_hash: res.transaction_hash
                    }
                }
                parseDeployContractResponse(res) {
                    return {
                        transaction_hash: res.transaction_hash,
                        contract_address: res.address
                    }
                }
                parseDeclareContractResponse(res) {
                    return {
                        transaction_hash: res.transaction_hash,
                        class_hash: res.class_hash
                    }
                }
                parseGetStateUpdateResponse(res) {
                    const nonces = Object.entries(res.state_diff.nonces).map((([contract_address,nonce])=>({
                        contract_address,
                        nonce
                    })))
                      , storage_diffs = Object.entries(res.state_diff.storage_diffs).map((([address,storage_entries])=>({
                        address,
                        storage_entries
                    })));
                    return {
                        ...res,
                        state_diff: {
                            ...res.state_diff,
                            storage_diffs,
                            nonces
                        }
                    }
                }
                parseContractClassResponse(res) {
                    const response = isSierra(res) ? res : parseContract(res);
                    return {
                        ...response,
                        abi: "string" == typeof response.abi ? JSON.parse(response.abi) : response.abi
                    }
                }
            }
              , import_url_join = __toESM(__webpack_require__(34078))
              , protocolAndDomainRE = /^(?:\w+:)?\/\/(\S+)$/
              , localhostDomainRE = /^localhost[:?\d]*(?:[^:?\d]\S*)?$/
              , nonLocalhostDomainRE = /^[^\s.]+\.\S{2,}$/;
            function isUrl(s) {
                if (!s)
                    return !1;
                if ("string" != typeof s)
                    return !1;
                const match = s.match(protocolAndDomainRE);
                if (!match)
                    return !1;
                const everythingAfterProtocol = match[1];
                return !!everythingAfterProtocol && !(!localhostDomainRE.test(everythingAfterProtocol) && !nonLocalhostDomainRE.test(everythingAfterProtocol))
            }
            function buildUrl(baseUrl, defaultPath, urlOrPath) {
                return isUrl(urlOrPath) ? urlOrPath : (0,
                import_url_join.default)(baseUrl, urlOrPath ?? defaultPath)
            }
            var defaultOptions2 = {
                network: "SN_GOERLI",
                blockIdentifier: "pending"
            }
              , SequencerProvider = class {
                constructor(optionsOrProvider=defaultOptions2) {
                    this.responseParser = new SequencerAPIResponseParser,
                    "network"in optionsOrProvider ? (this.baseUrl = SequencerProvider.getNetworkFromName(optionsOrProvider.network),
                    this.feederGatewayUrl = buildUrl(this.baseUrl, "feeder_gateway"),
                    this.gatewayUrl = buildUrl(this.baseUrl, "gateway")) : (this.baseUrl = optionsOrProvider.baseUrl,
                    this.feederGatewayUrl = buildUrl(this.baseUrl, "feeder_gateway", optionsOrProvider.feederGatewayUrl),
                    this.gatewayUrl = buildUrl(this.baseUrl, "gateway", optionsOrProvider.gatewayUrl)),
                    this.chainId = optionsOrProvider?.chainId ?? SequencerProvider.getChainIdFromBaseUrl(this.baseUrl),
                    this.headers = optionsOrProvider.headers,
                    this.blockIdentifier = optionsOrProvider?.blockIdentifier || defaultOptions2.blockIdentifier
                }
                static getNetworkFromName(name) {
                    switch (name) {
                    case "SN_MAIN":
                    case "0x534e5f4d41494e":
                        return "https://alpha-mainnet.starknet.io";
                    case "SN_GOERLI":
                    case "0x534e5f474f45524c49":
                        return "https://alpha4.starknet.io";
                    default:
                        throw new Error("Could not detect base url from NetworkName")
                    }
                }
                static getChainIdFromBaseUrl(baseUrl) {
                    try {
                        return new URL(baseUrl).host.includes("mainnet.starknet.io") ? "0x534e5f4d41494e" : "0x534e5f474f45524c49"
                    } catch {
                        return "0x534e5f474f45524c49"
                    }
                }
                getFetchUrl(endpoint) {
                    return ["add_transaction"].includes(endpoint) ? this.gatewayUrl : this.feederGatewayUrl
                }
                getFetchMethod(endpoint) {
                    return ["add_transaction", "call_contract", "estimate_fee", "estimate_message_fee", "estimate_fee_bulk", "simulate_transaction"].includes(endpoint) ? "POST" : "GET"
                }
                getQueryString(query) {
                    if (void 0 === (obj = query) || 0 === Object.keys(obj).length || 1 === Object.keys(obj).length && Object.entries(obj).every((([k,v])=>"blockIdentifier" === k && null === v)))
                        return "";
                    var obj;
                    return `?${Object.entries(query).map((([key,value])=>{
                        if ("blockIdentifier" === key) {
                            return `${new Block(value).queryIdentifier}`
                        }
                        return `${key}=${value}`
                    }
                    )).join("&")}`
                }
                getHeaders(method) {
                    return "POST" === method ? {
                        "Content-Type": "application/json",
                        ...this.headers
                    } : this.headers
                }
                async fetchEndpoint(endpoint, ...[query,request]) {
                    const baseUrl = this.getFetchUrl(endpoint)
                      , method = this.getFetchMethod(endpoint)
                      , queryString = this.getQueryString(query)
                      , url = (0,
                    import_url_join2.default)(baseUrl, endpoint, queryString);
                    return this.fetch(url, {
                        method,
                        body: request
                    })
                }
                async fetch(endpoint, options) {
                    const url = buildUrl(this.baseUrl, "", endpoint)
                      , method = options?.method ?? "GET"
                      , headers = this.getHeaders(method)
                      , body = stringify2(options?.body);
                    try {
                        const response = await fetchPonyfill_default(url, {
                            method,
                            body,
                            headers
                        })
                          , textResponse = await response.text();
                        if (!response.ok) {
                            let responseBody;
                            try {
                                responseBody = parse2(textResponse)
                            } catch {
                                throw new HttpError(response.statusText,response.status)
                            }
                            throw new GatewayError(responseBody.message,responseBody.code)
                        }
                        return (options?.parseAlwaysAsBigInt ? parseAlwaysAsBig : parse2)(textResponse)
                    } catch (error) {
                        if (error instanceof Error && !(error instanceof LibraryError))
                            throw Error(`Could not ${method} from endpoint \`${url}\`: ${error.message}`);
                        throw error
                    }
                }
                async getChainId() {
                    return Promise.resolve(this.chainId)
                }
                async callContract({contractAddress, entrypoint: entryPointSelector, calldata=[]}, blockIdentifier=this.blockIdentifier) {
                    return this.fetchEndpoint("call_contract", {
                        blockIdentifier
                    }, {
                        contract_address: contractAddress,
                        entry_point_selector: getSelectorFromName(entryPointSelector),
                        calldata: CallData.compile(calldata)
                    }).then(this.responseParser.parseCallContractResponse)
                }
                async getBlock(blockIdentifier=this.blockIdentifier) {
                    return this.fetchEndpoint("get_block", {
                        blockIdentifier
                    }).then(this.responseParser.parseGetBlockResponse)
                }
                async getNonceForAddress(contractAddress, blockIdentifier=this.blockIdentifier) {
                    return this.fetchEndpoint("get_nonce", {
                        contractAddress,
                        blockIdentifier
                    })
                }
                async getStorageAt(contractAddress, key, blockIdentifier=this.blockIdentifier) {
                    const parsedKey = toBigInt(key).toString(10);
                    return this.fetchEndpoint("get_storage_at", {
                        blockIdentifier,
                        contractAddress,
                        key: parsedKey
                    })
                }
                async getTransaction(txHash) {
                    const txHashHex = toHex(txHash);
                    return this.fetchEndpoint("get_transaction", {
                        transactionHash: txHashHex
                    }).then((result=>{
                        if (1 === Object.values(result).length)
                            throw new LibraryError(result.status);
                        return this.responseParser.parseGetTransactionResponse(result)
                    }
                    ))
                }
                async getTransactionReceipt(txHash) {
                    const txHashHex = toHex(txHash);
                    return this.fetchEndpoint("get_transaction_receipt", {
                        transactionHash: txHashHex
                    }).then(this.responseParser.parseGetTransactionReceiptResponse)
                }
                async getClassAt(contractAddress, blockIdentifier=this.blockIdentifier) {
                    return this.fetchEndpoint("get_full_contract", {
                        blockIdentifier,
                        contractAddress
                    }).then(this.responseParser.parseContractClassResponse)
                }
                async getClassHashAt(contractAddress, blockIdentifier=this.blockIdentifier) {
                    return this.fetchEndpoint("get_class_hash_at", {
                        blockIdentifier,
                        contractAddress
                    })
                }
                async getClassByHash(classHash, blockIdentifier=this.blockIdentifier) {
                    return this.fetchEndpoint("get_class_by_hash", {
                        classHash,
                        blockIdentifier
                    }).then(this.responseParser.parseContractClassResponse)
                }
                async getCompiledClassByClassHash(classHash, blockIdentifier=this.blockIdentifier) {
                    return this.fetchEndpoint("get_compiled_class_by_class_hash", {
                        classHash,
                        blockIdentifier
                    })
                }
                async getContractVersion(contractAddress, classHash, {blockIdentifier=this.blockIdentifier, compiler=!0}={}) {
                    let contractClass;
                    if (contractAddress)
                        contractClass = await this.getClassAt(contractAddress, blockIdentifier);
                    else {
                        if (!classHash)
                            throw Error("getContractVersion require contractAddress or classHash");
                        contractClass = await this.getClassByHash(classHash, blockIdentifier)
                    }
                    if (isSierra(contractClass)) {
                        if (compiler) {
                            return {
                                cairo: "1",
                                compiler: getAbiContractVersion(contractClass.abi).compiler
                            }
                        }
                        return {
                            cairo: "1",
                            compiler: void 0
                        }
                    }
                    return {
                        cairo: "0",
                        compiler: "0"
                    }
                }
                async invokeFunction(functionInvocation, details) {
                    return this.fetchEndpoint("add_transaction", void 0, {
                        type: "INVOKE_FUNCTION",
                        sender_address: functionInvocation.contractAddress,
                        calldata: CallData.compile(functionInvocation.calldata ?? []),
                        signature: signatureToDecimalArray(functionInvocation.signature),
                        nonce: toHex(details.nonce),
                        max_fee: toHex(details.maxFee || 0),
                        version: "0x1"
                    }).then(this.responseParser.parseInvokeFunctionResponse)
                }
                async deployAccountContract({classHash, constructorCalldata, addressSalt, signature}, details) {
                    return this.fetchEndpoint("add_transaction", void 0, {
                        type: "DEPLOY_ACCOUNT",
                        contract_address_salt: addressSalt ?? randomAddress(),
                        constructor_calldata: CallData.compile(constructorCalldata ?? []),
                        class_hash: toHex(classHash),
                        max_fee: toHex(details.maxFee || 0),
                        version: toHex(details.version || 0),
                        nonce: toHex(details.nonce),
                        signature: signatureToDecimalArray(signature)
                    }).then(this.responseParser.parseDeployContractResponse)
                }
                async declareContract({senderAddress, contract, signature, compiledClassHash}, details) {
                    return isSierra(contract) ? this.fetchEndpoint("add_transaction", void 0, {
                        type: "DECLARE",
                        sender_address: senderAddress,
                        compiled_class_hash: compiledClassHash,
                        contract_class: contract,
                        nonce: toHex(details.nonce),
                        signature: signatureToDecimalArray(signature),
                        max_fee: toHex(details.maxFee || 0),
                        version: toHex(transactionVersion_2)
                    }).then(this.responseParser.parseDeclareContractResponse) : this.fetchEndpoint("add_transaction", void 0, {
                        type: "DECLARE",
                        contract_class: contract,
                        nonce: toHex(details.nonce),
                        signature: signatureToDecimalArray(signature),
                        sender_address: senderAddress,
                        max_fee: toHex(details.maxFee || 0),
                        version: toHex(transactionVersion)
                    }).then(this.responseParser.parseDeclareContractResponse)
                }
                async getEstimateFee(invocation, invocationDetails, blockIdentifier=this.blockIdentifier, skipValidate=!1) {
                    return this.getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier, skipValidate)
                }
                async getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier=this.blockIdentifier, skipValidate=!1) {
                    const transaction = this.buildTransaction({
                        type: "INVOKE_FUNCTION",
                        ...invocation,
                        ...invocationDetails
                    }, "fee");
                    return this.fetchEndpoint("estimate_fee", {
                        blockIdentifier,
                        skipValidate
                    }, transaction).then(this.responseParser.parseFeeEstimateResponse)
                }
                async getDeclareEstimateFee(invocation, details, blockIdentifier=this.blockIdentifier, skipValidate=!1) {
                    const transaction = this.buildTransaction({
                        type: "DECLARE",
                        ...invocation,
                        ...details
                    }, "fee");
                    return this.fetchEndpoint("estimate_fee", {
                        blockIdentifier,
                        skipValidate
                    }, transaction).then(this.responseParser.parseFeeEstimateResponse)
                }
                async getDeployAccountEstimateFee(invocation, details, blockIdentifier=this.blockIdentifier, skipValidate=!1) {
                    const transaction = this.buildTransaction({
                        type: "DEPLOY_ACCOUNT",
                        ...invocation,
                        ...details
                    }, "fee");
                    return this.fetchEndpoint("estimate_fee", {
                        blockIdentifier,
                        skipValidate
                    }, transaction).then(this.responseParser.parseFeeEstimateResponse)
                }
                async getEstimateFeeBulk(invocations, {blockIdentifier=this.blockIdentifier, skipValidate=!1}) {
                    const transactions = invocations.map((it=>this.buildTransaction(it, "fee")));
                    return this.fetchEndpoint("estimate_fee_bulk", {
                        blockIdentifier,
                        skipValidate
                    }, transactions).then(this.responseParser.parseFeeEstimateBulkResponse)
                }
                async getCode(contractAddress, blockIdentifier=this.blockIdentifier) {
                    return this.fetchEndpoint("get_code", {
                        contractAddress,
                        blockIdentifier
                    })
                }
                async waitForTransaction(txHash, options) {
                    let res, completed = !1, retries = 0;
                    const retryInterval = options?.retryInterval ?? 5e3
                      , errorStates = options?.errorStates ?? ["REJECTED", "NOT_RECEIVED", "REVERTED"]
                      , successStates = options?.successStates ?? ["SUCCEEDED", "ACCEPTED_ON_L1", "ACCEPTED_ON_L2"];
                    for (; !completed; )
                        if (await wait(retryInterval),
                        res = await this.getTransactionStatus(txHash),
                        "NOT_RECEIVED" === res.finality_status && retries < 3)
                            retries += 1;
                        else if (successStates.includes(res.finality_status) || successStates.includes(res.execution_status))
                            completed = !0;
                        else if (errorStates.includes(res.finality_status) || errorStates.includes(res.execution_status)) {
                            let message;
                            message = res.tx_failure_reason ? `${res.tx_status}: ${res.tx_failure_reason.code}\n${res.tx_failure_reason.error_message}` : res.tx_revert_reason ? `${res.tx_status}: ${res.tx_revert_reason}` : res.tx_status;
                            const error = new Error(message);
                            throw error.response = res,
                            error
                        }
                    return await this.getTransactionReceipt(txHash)
                }
                async getTransactionStatus(txHash) {
                    const txHashHex = toHex(txHash);
                    return this.fetchEndpoint("get_transaction_status", {
                        transactionHash: txHashHex
                    })
                }
                async getContractAddresses() {
                    return this.fetchEndpoint("get_contract_addresses")
                }
                async getTransactionTrace(txHash) {
                    const txHashHex = toHex(txHash);
                    return this.fetchEndpoint("get_transaction_trace", {
                        transactionHash: txHashHex
                    })
                }
                async estimateMessageFee({from_address, to_address, entry_point_selector, payload}, blockIdentifier=this.blockIdentifier) {
                    const validCallL1Handler = {
                        from_address: getDecimalString(from_address),
                        to_address: getHexString(to_address),
                        entry_point_selector: getSelector(entry_point_selector),
                        payload: getHexStringArray(payload)
                    };
                    return this.fetchEndpoint("estimate_message_fee", {
                        blockIdentifier
                    }, validCallL1Handler)
                }
                async getSimulateTransaction(invocations, {blockIdentifier=this.blockIdentifier, skipValidate=!1, skipExecute=!1}) {
                    invocations.length;
                    const transaction = this.buildTransaction(invocations[0]);
                    return this.fetchEndpoint("simulate_transaction", {
                        blockIdentifier,
                        skipValidate: skipValidate ?? !1
                    }, transaction).then(this.responseParser.parseSimulateTransactionResponse)
                }
                async getStateUpdate(blockIdentifier=this.blockIdentifier) {
                    const args = new Block(blockIdentifier).sequencerIdentifier;
                    return this.fetchEndpoint("get_state_update", {
                        ...args
                    }).then(this.responseParser.parseGetStateUpdateResponse)
                }
                async getBlockTraces(blockIdentifier=this.blockIdentifier) {
                    const args = new Block(blockIdentifier).sequencerIdentifier;
                    return this.fetchEndpoint("get_block_traces", {
                        ...args
                    })
                }
                async getStarkName(address, StarknetIdContract2) {
                    return getStarkName(this, address, StarknetIdContract2)
                }
                async getAddressFromStarkName(name, StarknetIdContract2) {
                    return getAddressFromStarkName(this, name, StarknetIdContract2)
                }
                buildTransaction(invocation, versionType) {
                    const defaultVersions = getVersionsByType(versionType)
                      , details = {
                        signature: signatureToDecimalArray(invocation.signature),
                        nonce: toHex(invocation.nonce)
                    };
                    if ("INVOKE_FUNCTION" === invocation.type)
                        return {
                            type: invocation.type,
                            sender_address: invocation.contractAddress,
                            calldata: CallData.compile(invocation.calldata ?? []),
                            version: toHex(invocation.version || defaultVersions.v1),
                            ...details
                        };
                    if ("DECLARE" === invocation.type)
                        return isSierra(invocation.contract) ? {
                            type: invocation.type,
                            contract_class: invocation.contract,
                            compiled_class_hash: invocation.compiledClassHash,
                            sender_address: invocation.senderAddress,
                            version: toHex(invocation.version || defaultVersions.v2),
                            ...details
                        } : {
                            type: invocation.type,
                            contract_class: invocation.contract,
                            sender_address: invocation.senderAddress,
                            version: toHex(invocation.version || defaultVersions.v1),
                            ...details
                        };
                    if ("DEPLOY_ACCOUNT" === invocation.type)
                        return {
                            type: invocation.type,
                            constructor_calldata: CallData.compile(invocation.constructorCalldata || []),
                            class_hash: toHex(invocation.classHash),
                            contract_address_salt: toHex(invocation.addressSalt || 0),
                            version: toHex(invocation.version || defaultVersions.v1),
                            ...details
                        };
                    throw Error("Sequencer buildTransaction received unknown TransactionType")
                }
            }
              , Provider = class {
                constructor(providerOrOptions) {
                    this.provider = providerOrOptions instanceof Provider ? providerOrOptions.provider : providerOrOptions instanceof RpcProvider || providerOrOptions instanceof SequencerProvider ? providerOrOptions : providerOrOptions && "rpc"in providerOrOptions ? new RpcProvider(providerOrOptions.rpc) : providerOrOptions && "sequencer"in providerOrOptions ? new SequencerProvider(providerOrOptions.sequencer) : new RpcProvider
                }
                async getChainId() {
                    return this.provider.getChainId()
                }
                async getBlock(blockIdentifier) {
                    return this.provider.getBlock(blockIdentifier)
                }
                async getClassAt(contractAddress, blockIdentifier) {
                    return this.provider.getClassAt(contractAddress, blockIdentifier)
                }
                async getClassHashAt(contractAddress, blockIdentifier) {
                    return this.provider.getClassHashAt(contractAddress, blockIdentifier)
                }
                getClassByHash(classHash) {
                    return this.provider.getClassByHash(classHash)
                }
                async getEstimateFee(invocationWithTxType, invocationDetails, blockIdentifier) {
                    return this.provider.getEstimateFee(invocationWithTxType, invocationDetails, blockIdentifier)
                }
                async getInvokeEstimateFee(invocationWithTxType, invocationDetails, blockIdentifier, skipValidate) {
                    return this.provider.getInvokeEstimateFee(invocationWithTxType, invocationDetails, blockIdentifier, skipValidate)
                }
                async getEstimateFeeBulk(invocations, options) {
                    return this.provider.getEstimateFeeBulk(invocations, options)
                }
                async getNonceForAddress(contractAddress, blockIdentifier) {
                    return this.provider.getNonceForAddress(contractAddress, blockIdentifier)
                }
                async getStorageAt(contractAddress, key, blockIdentifier) {
                    return this.provider.getStorageAt(contractAddress, key, blockIdentifier)
                }
                async getTransaction(txHash) {
                    return this.provider.getTransaction(txHash)
                }
                async getTransactionReceipt(txHash) {
                    return this.provider.getTransactionReceipt(txHash)
                }
                async callContract(request, blockIdentifier) {
                    return this.provider.callContract(request, blockIdentifier)
                }
                async invokeFunction(functionInvocation, details) {
                    return this.provider.invokeFunction(functionInvocation, details)
                }
                async deployAccountContract(payload, details) {
                    return this.provider.deployAccountContract(payload, details)
                }
                async declareContract(transaction, details) {
                    return this.provider.declareContract(transaction, details)
                }
                async getDeclareEstimateFee(transaction, details, blockIdentifier, skipValidate) {
                    return this.provider.getDeclareEstimateFee(transaction, details, blockIdentifier, skipValidate)
                }
                getDeployAccountEstimateFee(transaction, details, blockIdentifier, skipValidate) {
                    return this.provider.getDeployAccountEstimateFee(transaction, details, blockIdentifier, skipValidate)
                }
                async getCode(contractAddress, blockIdentifier) {
                    return this.provider.getCode(contractAddress, blockIdentifier)
                }
                async waitForTransaction(txHash, options) {
                    return this.provider.waitForTransaction(txHash, options)
                }
                async getSimulateTransaction(invocations, options) {
                    return this.provider.getSimulateTransaction(invocations, options)
                }
                async getStateUpdate(blockIdentifier) {
                    return this.provider.getStateUpdate(blockIdentifier)
                }
                async getStarkName(address, StarknetIdContract2) {
                    return getStarkName(this, address, StarknetIdContract2)
                }
                async getAddressFromStarkName(name, StarknetIdContract2) {
                    return getAddressFromStarkName(this, name, StarknetIdContract2)
                }
                async getContractVersion(contractAddress, classHash, options) {
                    return this.provider.getContractVersion(contractAddress, classHash, options)
                }
            }
              , SignerInterface = class {
            }
              , transaction_exports = {};
            __export(transaction_exports, {
                fromCallsToExecuteCalldata: ()=>fromCallsToExecuteCalldata,
                fromCallsToExecuteCalldataWithNonce: ()=>fromCallsToExecuteCalldataWithNonce,
                fromCallsToExecuteCalldata_cairo1: ()=>fromCallsToExecuteCalldata_cairo1,
                getExecuteCalldata: ()=>getExecuteCalldata,
                transformCallsToMulticallArrays: ()=>transformCallsToMulticallArrays,
                transformCallsToMulticallArrays_cairo1: ()=>transformCallsToMulticallArrays_cairo1
            });
            var transformCallsToMulticallArrays = calls=>{
                const callArray = []
                  , calldata = [];
                return calls.forEach((call=>{
                    const data = CallData.compile(call.calldata || []);
                    callArray.push({
                        to: toBigInt(call.contractAddress).toString(10),
                        selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),
                        data_offset: calldata.length.toString(),
                        data_len: data.length.toString()
                    }),
                    calldata.push(...data)
                }
                )),
                {
                    callArray,
                    calldata: CallData.compile({
                        calldata
                    })
                }
            }
              , fromCallsToExecuteCalldata = calls=>{
                const {callArray, calldata} = transformCallsToMulticallArrays(calls);
                return [...CallData.compile({
                    callArray
                }), ...calldata]
            }
              , fromCallsToExecuteCalldataWithNonce = (calls,nonce)=>[...fromCallsToExecuteCalldata(calls), toBigInt(nonce).toString()]
              , transformCallsToMulticallArrays_cairo1 = calls=>calls.map((call=>({
                to: toBigInt(call.contractAddress).toString(10),
                selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),
                calldata: CallData.compile(call.calldata || [])
            })))
              , fromCallsToExecuteCalldata_cairo1 = calls=>{
                const orderCalls = calls.map((call=>({
                    contractAddress: call.contractAddress,
                    entrypoint: call.entrypoint,
                    calldata: Array.isArray(call.calldata) && "__compiled__"in call.calldata ? call.calldata : CallData.compile(call.calldata)
                })));
                return CallData.compile({
                    orderCalls
                })
            }
              , getExecuteCalldata = (calls,cairoVersion="0")=>"1" === cairoVersion ? fromCallsToExecuteCalldata_cairo1(calls) : fromCallsToExecuteCalldata(calls)
              , typedData_exports = {};
            __export(typedData_exports, {
                encodeData: ()=>encodeData,
                encodeType: ()=>encodeType,
                encodeValue: ()=>encodeValue,
                getDependencies: ()=>getDependencies,
                getMessageHash: ()=>getMessageHash,
                getStructHash: ()=>getStructHash,
                getTypeHash: ()=>getTypeHash,
                isMerkleTreeType: ()=>isMerkleTreeType,
                prepareSelector: ()=>prepareSelector
            });
            var merkle_exports = {};
            __export(merkle_exports, {
                MerkleTree: ()=>MerkleTree,
                proofMerklePath: ()=>proofMerklePath
            });
            var MerkleTree = class {
                constructor(leafHashes) {
                    this.branches = [],
                    this.leaves = leafHashes,
                    this.root = this.build(leafHashes)
                }
                build(leaves) {
                    if (1 === leaves.length)
                        return leaves[0];
                    leaves.length !== this.leaves.length && this.branches.push(leaves);
                    const newLeaves = [];
                    for (let i = 0; i < leaves.length; i += 2)
                        i + 1 === leaves.length ? newLeaves.push(MerkleTree.hash(leaves[i], "0x0")) : newLeaves.push(MerkleTree.hash(leaves[i], leaves[i + 1]));
                    return this.build(newLeaves)
                }
                static hash(a, b) {
                    const [aSorted,bSorted] = [toBigInt(a), toBigInt(b)].sort(((x,y)=>x >= y ? 1 : -1));
                    return starkCurve.pedersen(aSorted, bSorted)
                }
                getProof(leaf, branch=this.leaves, hashPath=[]) {
                    const index = branch.indexOf(leaf);
                    if (-1 === index)
                        throw new Error("leaf not found");
                    if (1 === branch.length)
                        return hashPath;
                    const isLeft = index % 2 == 0
                      , neededBranch = (isLeft ? branch[index + 1] : branch[index - 1]) ?? "0x0"
                      , newHashPath = [...hashPath, neededBranch]
                      , currentBranchLevelIndex = this.leaves.length === branch.length ? -1 : this.branches.findIndex((b=>b.length === branch.length))
                      , nextBranch = this.branches[currentBranchLevelIndex + 1] ?? [this.root];
                    return this.getProof(MerkleTree.hash(isLeft ? leaf : neededBranch, isLeft ? neededBranch : leaf), nextBranch, newHashPath)
                }
            }
            ;
            function proofMerklePath(root, leaf, path) {
                if (0 === path.length)
                    return root === leaf;
                const [next,...rest] = path;
                return proofMerklePath(root, MerkleTree.hash(leaf, next), rest)
            }
            function getHex(value) {
                try {
                    return toHex(value)
                } catch (e) {
                    if ("string" == typeof value)
                        return toHex(encodeShortString(value));
                    throw new Error(`Invalid BigNumberish: ${value}`)
                }
            }
            function prepareSelector(selector) {
                return isHex(selector) ? selector : getSelectorFromName(selector)
            }
            function isMerkleTreeType(type) {
                return "merkletree" === type.type
            }
            var getDependencies = (types,type,dependencies=[])=>("*" === type[type.length - 1] && (type = type.slice(0, -1)),
            dependencies.includes(type) ? dependencies : types[type] ? [type, ...types[type].reduce(((previous,t)=>[...previous, ...getDependencies(types, t.type, previous).filter((dependency=>!previous.includes(dependency)))]), [])] : dependencies);
            var encodeType = (types,type)=>{
                const [primary,...dependencies] = getDependencies(types, type);
                return (primary ? [primary, ...dependencies.sort()] : []).map((dependency=>`${dependency}(${types[dependency].map((t=>`${t.name}:${t.type}`))})`)).join("")
            }
              , getTypeHash = (types,type)=>getSelectorFromName(encodeType(types, type))
              , encodeValue = (types,type,data,ctx={})=>{
                if (types[type])
                    return [type, getStructHash(types, type, data)];
                if (Object.keys(types).map((x=>`${x}*`)).includes(type)) {
                    const structHashes = data.map((struct=>getStructHash(types, type.slice(0, -1), struct)));
                    return [type, computeHashOnElements(structHashes)]
                }
                if ("merkletree" === type) {
                    const merkleTreeType = function(types, ctx) {
                        if (ctx.parent && ctx.key) {
                            const merkleType = types[ctx.parent].find((t=>t.name === ctx.key));
                            if (!isMerkleTreeType(merkleType))
                                throw new Error(`${ctx.key} is not a merkle tree`);
                            if (merkleType.contains.endsWith("*"))
                                throw new Error(`Merkle tree contain property must not be an array but was given ${ctx.key}`);
                            return merkleType.contains
                        }
                        return "raw"
                    }(types, ctx)
                      , structHashes = data.map((struct=>encodeValue(types, merkleTreeType, struct)[1]))
                      , {root} = new MerkleTree(structHashes);
                    return ["felt", root]
                }
                return "felt*" === type ? ["felt*", computeHashOnElements(data)] : "selector" === type ? ["felt", prepareSelector(data)] : [type, getHex(data)]
            }
              , encodeData = (types,type,data)=>{
                const [returnTypes,values] = types[type].reduce((([ts,vs],field)=>{
                    if (void 0 === data[field.name] || null === data[field.name])
                        throw new Error(`Cannot encode data: missing data for '${field.name}'`);
                    const value = data[field.name]
                      , [t,encodedValue] = encodeValue(types, field.type, value, {
                        parent: type,
                        key: field.name
                    });
                    return [[...ts, t], [...vs, encodedValue]]
                }
                ), [["felt"], [getTypeHash(types, type)]]);
                return [returnTypes, values]
            }
              , getStructHash = (types,type,data)=>computeHashOnElements(encodeData(types, type, data)[1])
              , getMessageHash = (typedData,account)=>{
                if (!(data=>{
                    const typedData = data;
                    return Boolean(typedData.types && typedData.primaryType && typedData.message)
                }
                )(typedData))
                    throw new Error("Typed data does not match JSON schema");
                return computeHashOnElements([encodeShortString("StarkNet Message"), getStructHash(typedData.types, "StarkNetDomain", typedData.domain), account, getStructHash(typedData.types, typedData.primaryType, typedData.message)])
            }
              , Signer = class {
                constructor(pk=starkCurve.utils.randomPrivateKey()) {
                    this.pk = pk instanceof Uint8Array ? buf2hex(pk) : toHex(pk)
                }
                async getPubKey() {
                    return starkCurve.getStarkKey(this.pk)
                }
                async signMessage(typedData, accountAddress) {
                    const msgHash = getMessageHash(typedData, accountAddress);
                    return starkCurve.sign(msgHash, this.pk)
                }
                async signTransaction(transactions, transactionsDetail, abis) {
                    if (abis && abis.length !== transactions.length)
                        throw new Error("ABI must be provided for each transaction or no transaction");
                    const calldata = getExecuteCalldata(transactions, transactionsDetail.cairoVersion)
                      , msgHash = calculateTransactionHash(transactionsDetail.walletAddress, transactionsDetail.version, calldata, transactionsDetail.maxFee, transactionsDetail.chainId, transactionsDetail.nonce);
                    return starkCurve.sign(msgHash, this.pk)
                }
                async signDeployAccountTransaction({classHash, contractAddress, constructorCalldata, addressSalt, maxFee, version, chainId, nonce}) {
                    const msgHash = calculateDeployAccountTransactionHash(contractAddress, classHash, CallData.compile(constructorCalldata), addressSalt, version, maxFee, chainId, nonce);
                    return starkCurve.sign(msgHash, this.pk)
                }
                async signDeclareTransaction({classHash, senderAddress, chainId, maxFee, version, nonce, compiledClassHash}) {
                    const msgHash = calculateDeclareTransactionHash(classHash, senderAddress, version, maxFee, chainId, nonce, compiledClassHash);
                    return starkCurve.sign(msgHash, this.pk)
                }
            }
            ;
            function parseUDCEvent(txReceipt) {
                if (!txReceipt.events)
                    throw new Error("UDC emitted event is empty");
                const event = txReceipt.events.find((it=>cleanHex(it.from_address) === cleanHex(UDC.ADDRESS))) || {
                    data: []
                };
                return {
                    transaction_hash: txReceipt.transaction_hash,
                    contract_address: event.data[0],
                    address: event.data[0],
                    deployer: event.data[1],
                    unique: event.data[2],
                    classHash: event.data[3],
                    calldata_len: event.data[4],
                    calldata: event.data.slice(5, 5 + parseInt(event.data[4], 16)),
                    salt: event.data[event.data.length - 1]
                }
            }
            var Account = class extends Provider {
                constructor(providerOrOptions, address, pkOrSigner, cairoVersion) {
                    super(providerOrOptions),
                    this.deploySelf = this.deployAccount,
                    this.address = address.toLowerCase(),
                    this.signer = "string" == typeof pkOrSigner || pkOrSigner instanceof Uint8Array ? new Signer(pkOrSigner) : pkOrSigner,
                    cairoVersion && (this.cairoVersion = cairoVersion.toString())
                }
                async getNonce(blockIdentifier) {
                    return super.getNonceForAddress(this.address, blockIdentifier)
                }
                async getNonceSafe(nonce) {
                    try {
                        return toBigInt(nonce ?? await this.getNonce())
                    } catch (error) {
                        return 0n
                    }
                }
                async getCairoVersion(classHash) {
                    if (!this.cairoVersion) {
                        const {cairo} = classHash ? await super.getContractVersion(void 0, classHash) : await super.getContractVersion(this.address);
                        this.cairoVersion = cairo
                    }
                    return this.cairoVersion
                }
                async estimateFee(calls, estimateFeeDetails) {
                    return this.estimateInvokeFee(calls, estimateFeeDetails)
                }
                async estimateInvokeFee(calls, {nonce: providedNonce, blockIdentifier, skipValidate}={}) {
                    const transactions = Array.isArray(calls) ? calls : [calls]
                      , nonce = toBigInt(providedNonce ?? await this.getNonce())
                      , version = toBigInt(feeTransactionVersion)
                      , chainId = await this.getChainId()
                      , signerDetails = {
                        walletAddress: this.address,
                        nonce,
                        maxFee: ZERO,
                        version,
                        chainId,
                        cairoVersion: await this.getCairoVersion()
                    }
                      , invocation = await this.buildInvocation(transactions, signerDetails)
                      , response = await super.getInvokeEstimateFee({
                        ...invocation
                    }, {
                        version,
                        nonce
                    }, blockIdentifier, skipValidate)
                      , suggestedMaxFee = estimatedFeeToMaxFee(response.overall_fee);
                    return {
                        ...response,
                        suggestedMaxFee
                    }
                }
                async estimateDeclareFee({contract, classHash: providedClassHash, casm, compiledClassHash}, {blockIdentifier, nonce: providedNonce, skipValidate}={}) {
                    const nonce = toBigInt(providedNonce ?? await this.getNonce())
                      , version = isSierra(contract) ? feeTransactionVersion_2 : feeTransactionVersion
                      , chainId = await this.getChainId()
                      , declareContractTransaction = await this.buildDeclarePayload({
                        classHash: providedClassHash,
                        contract,
                        casm,
                        compiledClassHash
                    }, {
                        nonce,
                        chainId,
                        version,
                        walletAddress: this.address,
                        maxFee: ZERO,
                        cairoVersion: void 0
                    })
                      , response = await super.getDeclareEstimateFee(declareContractTransaction, {
                        version,
                        nonce
                    }, blockIdentifier, skipValidate)
                      , suggestedMaxFee = estimatedFeeToMaxFee(response.overall_fee);
                    return {
                        ...response,
                        suggestedMaxFee
                    }
                }
                async estimateAccountDeployFee({classHash, addressSalt=0, constructorCalldata=[], contractAddress: providedContractAddress}, {blockIdentifier, skipValidate}={}) {
                    const version = toBigInt(feeTransactionVersion)
                      , nonce = ZERO
                      , chainId = await this.getChainId()
                      , payload = await this.buildAccountDeployPayload({
                        classHash,
                        addressSalt,
                        constructorCalldata,
                        contractAddress: providedContractAddress
                    }, {
                        nonce,
                        chainId,
                        version,
                        walletAddress: this.address,
                        maxFee: ZERO,
                        cairoVersion: void 0
                    })
                      , response = await super.getDeployAccountEstimateFee({
                        ...payload
                    }, {
                        version,
                        nonce
                    }, blockIdentifier, skipValidate)
                      , suggestedMaxFee = estimatedFeeToMaxFee(response.overall_fee);
                    return {
                        ...response,
                        suggestedMaxFee
                    }
                }
                async estimateDeployFee(payload, transactionsDetail) {
                    const calls = this.buildUDCContractPayload(payload);
                    return this.estimateInvokeFee(calls, transactionsDetail)
                }
                async estimateFeeBulk(invocations, {nonce, blockIdentifier, skipValidate}={}) {
                    const accountInvocations = await this.accountInvocationsFactory(invocations, {
                        versions: [feeTransactionVersion, feeTransactionVersion_2],
                        nonce,
                        blockIdentifier
                    })
                      , response = await super.getEstimateFeeBulk(accountInvocations, {
                        blockIdentifier,
                        skipValidate
                    });
                    return [].concat(response).map((elem=>{
                        const suggestedMaxFee = estimatedFeeToMaxFee(elem.overall_fee);
                        return {
                            ...elem,
                            suggestedMaxFee
                        }
                    }
                    ))
                }
                async buildInvocation(call, signerDetails) {
                    const calldata = getExecuteCalldata(call, await this.getCairoVersion())
                      , signature = await this.signer.signTransaction(call, signerDetails);
                    return {
                        contractAddress: this.address,
                        calldata,
                        signature
                    }
                }
                async execute(calls, abis=undefined, transactionsDetail={}) {
                    const transactions = Array.isArray(calls) ? calls : [calls]
                      , nonce = toBigInt(transactionsDetail.nonce ?? await this.getNonce())
                      , maxFee = transactionsDetail.maxFee ?? await this.getSuggestedMaxFee({
                        type: "INVOKE_FUNCTION",
                        payload: calls
                    }, transactionsDetail)
                      , version = toBigInt(transactionVersion)
                      , chainId = await this.getChainId()
                      , signerDetails = {
                        walletAddress: this.address,
                        nonce,
                        maxFee,
                        version,
                        chainId,
                        cairoVersion: await this.getCairoVersion()
                    }
                      , signature = await this.signer.signTransaction(transactions, signerDetails, abis)
                      , calldata = getExecuteCalldata(transactions, await this.getCairoVersion());
                    return this.invokeFunction({
                        contractAddress: this.address,
                        calldata,
                        signature
                    }, {
                        nonce,
                        maxFee,
                        version
                    })
                }
                async declareIfNot(payload, transactionsDetail={}) {
                    const declareContractPayload = extractContractHashes(payload);
                    try {
                        await this.getClassByHash(declareContractPayload.classHash)
                    } catch (error) {
                        return this.declare(payload, transactionsDetail)
                    }
                    return {
                        transaction_hash: "",
                        class_hash: declareContractPayload.classHash
                    }
                }
                async declare(payload, transactionsDetail={}) {
                    const declareContractPayload = extractContractHashes(payload)
                      , details = {};
                    details.nonce = toBigInt(transactionsDetail.nonce ?? await this.getNonce()),
                    details.maxFee = transactionsDetail.maxFee ?? await this.getSuggestedMaxFee({
                        type: "DECLARE",
                        payload: declareContractPayload
                    }, transactionsDetail),
                    details.version = isSierra(payload.contract) ? transactionVersion_2 : transactionVersion,
                    details.chainId = await this.getChainId();
                    const declareContractTransaction = await this.buildDeclarePayload(declareContractPayload, {
                        ...details,
                        walletAddress: this.address,
                        cairoVersion: void 0
                    });
                    return this.declareContract(declareContractTransaction, details)
                }
                async deploy(payload, details) {
                    const params = [].concat(payload).map((it=>{
                        const {classHash, salt, unique=!0, constructorCalldata=[]} = it
                          , compiledConstructorCallData = CallData.compile(constructorCalldata)
                          , deploySalt = salt ?? randomAddress();
                        return {
                            call: {
                                contractAddress: UDC.ADDRESS,
                                entrypoint: UDC.ENTRYPOINT,
                                calldata: [classHash, deploySalt, toCairoBool(unique), compiledConstructorCallData.length, ...compiledConstructorCallData]
                            },
                            address: calculateContractAddressFromHash(unique ? starkCurve.pedersen(this.address, deploySalt) : deploySalt, classHash, compiledConstructorCallData, unique ? UDC.ADDRESS : 0)
                        }
                    }
                    ))
                      , calls = params.map((it=>it.call))
                      , addresses = params.map((it=>it.address));
                    return {
                        ...await this.execute(calls, void 0, details),
                        contract_address: addresses
                    }
                }
                async deployContract(payload, details) {
                    const deployTx = await this.deploy(payload, details);
                    return parseUDCEvent(await this.waitForTransaction(deployTx.transaction_hash))
                }
                async declareAndDeploy(payload, details) {
                    const {constructorCalldata, salt, unique} = payload;
                    let declare = await this.declareIfNot(payload, details);
                    if ("" !== declare.transaction_hash) {
                        const tx = await this.waitForTransaction(declare.transaction_hash);
                        declare = {
                            ...declare,
                            ...tx
                        }
                    }
                    const deploy = await this.deployContract({
                        classHash: declare.class_hash,
                        salt,
                        unique,
                        constructorCalldata
                    }, details);
                    return {
                        declare: {
                            ...declare
                        },
                        deploy
                    }
                }
                async deployAccount({classHash, constructorCalldata=[], addressSalt=0, contractAddress: providedContractAddress}, transactionsDetail={}) {
                    const version = toBigInt(transactionVersion)
                      , nonce = ZERO
                      , chainId = await this.getChainId()
                      , compiledCalldata = CallData.compile(constructorCalldata)
                      , contractAddress = providedContractAddress ?? calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0)
                      , maxFee = transactionsDetail.maxFee ?? await this.getSuggestedMaxFee({
                        type: "DEPLOY_ACCOUNT",
                        payload: {
                            classHash,
                            constructorCalldata: compiledCalldata,
                            addressSalt,
                            contractAddress
                        }
                    }, transactionsDetail)
                      , signature = await this.signer.signDeployAccountTransaction({
                        classHash,
                        constructorCalldata: compiledCalldata,
                        contractAddress,
                        addressSalt,
                        chainId,
                        maxFee,
                        version,
                        nonce
                    });
                    return this.deployAccountContract({
                        classHash,
                        addressSalt,
                        constructorCalldata,
                        signature
                    }, {
                        nonce,
                        maxFee,
                        version
                    })
                }
                async signMessage(typedData) {
                    return this.signer.signMessage(typedData, this.address)
                }
                async hashMessage(typedData) {
                    return getMessageHash(typedData, this.address)
                }
                async verifyMessageHash(hash, signature) {
                    try {
                        return await this.callContract({
                            contractAddress: this.address,
                            entrypoint: "isValidSignature",
                            calldata: CallData.compile({
                                hash: toBigInt(hash).toString(),
                                signature: formatSignature(signature)
                            })
                        }),
                        !0
                    } catch {
                        return !1
                    }
                }
                async verifyMessage(typedData, signature) {
                    const hash = await this.hashMessage(typedData);
                    return this.verifyMessageHash(hash, signature)
                }
                async getSuggestedMaxFee({type, payload}, details) {
                    let feeEstimate;
                    switch (type) {
                    case "INVOKE_FUNCTION":
                        feeEstimate = await this.estimateInvokeFee(payload, details);
                        break;
                    case "DECLARE":
                        feeEstimate = await this.estimateDeclareFee(payload, details);
                        break;
                    case "DEPLOY_ACCOUNT":
                        feeEstimate = await this.estimateAccountDeployFee(payload, details);
                        break;
                    case "DEPLOY":
                        feeEstimate = await this.estimateDeployFee(payload, details);
                        break;
                    default:
                        feeEstimate = {
                            suggestedMaxFee: ZERO,
                            overall_fee: ZERO
                        }
                    }
                    return feeEstimate.suggestedMaxFee
                }
                async buildDeclarePayload(payload, {nonce, chainId, version, walletAddress, maxFee}) {
                    const {classHash, contract, compiledClassHash} = extractContractHashes(payload)
                      , compressedCompiledContract = parseContract(contract);
                    return {
                        senderAddress: walletAddress,
                        signature: await this.signer.signDeclareTransaction({
                            classHash,
                            compiledClassHash,
                            senderAddress: walletAddress,
                            chainId,
                            maxFee,
                            version,
                            nonce
                        }),
                        contract: compressedCompiledContract,
                        compiledClassHash
                    }
                }
                async buildAccountDeployPayload({classHash, addressSalt=0, constructorCalldata=[], contractAddress: providedContractAddress}, {nonce, chainId, version, maxFee}) {
                    const compiledCalldata = CallData.compile(constructorCalldata)
                      , contractAddress = providedContractAddress ?? calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);
                    return {
                        classHash,
                        addressSalt,
                        constructorCalldata: compiledCalldata,
                        signature: await this.signer.signDeployAccountTransaction({
                            classHash,
                            contractAddress,
                            chainId,
                            maxFee,
                            version,
                            nonce,
                            addressSalt,
                            constructorCalldata: compiledCalldata
                        })
                    }
                }
                buildUDCContractPayload(payload) {
                    return [].concat(payload).map((it=>{
                        const {classHash, salt="0", unique=!0, constructorCalldata=[]} = it
                          , compiledConstructorCallData = CallData.compile(constructorCalldata);
                        return {
                            contractAddress: UDC.ADDRESS,
                            entrypoint: UDC.ENTRYPOINT,
                            calldata: [classHash, salt, toCairoBool(unique), compiledConstructorCallData.length, ...compiledConstructorCallData]
                        }
                    }
                    ))
                }
                async simulateTransaction(invocations, {nonce, blockIdentifier, skipValidate, skipExecute}={}) {
                    const accountInvocations = await this.accountInvocationsFactory(invocations, {
                        versions: [transactionVersion, transactionVersion_2],
                        nonce,
                        blockIdentifier
                    });
                    return super.getSimulateTransaction(accountInvocations, {
                        blockIdentifier,
                        skipValidate,
                        skipExecute
                    })
                }
                async accountInvocationsFactory(invocations, {versions, nonce, blockIdentifier}) {
                    const version = versions[0]
                      , safeNonce = await this.getNonceSafe(nonce)
                      , chainId = await this.getChainId()
                      , tx0Payload = "payload"in invocations[0] ? invocations[0].payload : invocations[0]
                      , cairoVersion = "DEPLOY_ACCOUNT" === invocations[0].type ? await this.getCairoVersion(tx0Payload.classHash) : await this.getCairoVersion();
                    return Promise.all([].concat(invocations).map((async(transaction,index)=>{
                        const txPayload = "payload"in transaction ? transaction.payload : transaction
                          , signerDetails = {
                            walletAddress: this.address,
                            nonce: toBigInt(Number(safeNonce) + index),
                            maxFee: ZERO,
                            version,
                            chainId,
                            cairoVersion
                        }
                          , common = {
                            type: transaction.type,
                            version,
                            nonce: toBigInt(Number(safeNonce) + index),
                            blockIdentifier
                        };
                        if ("INVOKE_FUNCTION" === transaction.type) {
                            const payload = await this.buildInvocation([].concat(txPayload), signerDetails);
                            return {
                                ...common,
                                ...payload
                            }
                        }
                        if ("DECLARE" === transaction.type) {
                            signerDetails.version = isSierra(txPayload.contract) ? toBigInt(versions[1]) : toBigInt(versions[0]);
                            const payload = await this.buildDeclarePayload(txPayload, signerDetails);
                            return {
                                ...common,
                                ...payload,
                                version: signerDetails.version
                            }
                        }
                        if ("DEPLOY_ACCOUNT" === transaction.type) {
                            const payload = await this.buildAccountDeployPayload(txPayload, signerDetails);
                            return {
                                ...common,
                                ...payload
                            }
                        }
                        if ("DEPLOY" === transaction.type) {
                            const calls = this.buildUDCContractPayload(txPayload)
                              , payload = await this.buildInvocation(calls, signerDetails);
                            return {
                                ...common,
                                ...payload,
                                type: "INVOKE_FUNCTION"
                            }
                        }
                        throw Error(`accountInvocationsFactory: unsupported transaction type: ${transaction}`)
                    }
                    )))
                }
                async getStarkName(address=this.address, StarknetIdContract2) {
                    return super.getStarkName(address, StarknetIdContract2)
                }
            }
              , ProviderInterface = class {
            }
              , defaultProvider = new Provider({
                rpc: {
                    default: !0
                }
            })
              , AccountInterface = class extends ProviderInterface {
            }
              , events_exports = {};
            function getAbiEvents(abi) {
                return abi.filter((abiEntry=>"event" === abiEntry.type && (abiEntry.size || "enum" !== abiEntry.kind))).reduce(((acc,abiEntry)=>{
                    const entryName = abiEntry.name.slice(abiEntry.name.lastIndexOf(":") + 1)
                      , abiEntryMod = {
                        ...abiEntry
                    };
                    return abiEntryMod.name = entryName,
                    {
                        ...acc,
                        [addHexPrefix(starkCurve.keccak(utf8ToArray(entryName)).toString(16))]: abiEntryMod
                    }
                }
                ), {})
            }
            function parseEvents(providerReceivedEvents, abiEvents, abiStructs, abiEnums) {
                return providerReceivedEvents.flat().reduce(((acc,recEvent)=>{
                    const abiEvent = abiEvents[recEvent.keys[0]];
                    if (!abiEvent)
                        return acc;
                    const parsedEvent = {};
                    parsedEvent[abiEvent.name] = {},
                    recEvent.keys.shift();
                    const keysIter = recEvent.keys[Symbol.iterator]()
                      , dataIter = recEvent.data[Symbol.iterator]()
                      , abiEventKeys = abiEvent.members?.filter((it=>"key" === it.kind)) || abiEvent.keys
                      , abiEventData = abiEvent.members?.filter((it=>"data" === it.kind)) || abiEvent.data;
                    return abiEventKeys.forEach((key=>{
                        parsedEvent[abiEvent.name][key.name] = responseParser(keysIter, key, abiStructs, abiEnums, parsedEvent[abiEvent.name])
                    }
                    )),
                    abiEventData.forEach((data=>{
                        parsedEvent[abiEvent.name][data.name] = responseParser(dataIter, data, abiStructs, abiEnums, parsedEvent[abiEvent.name])
                    }
                    )),
                    acc.push(parsedEvent),
                    acc
                }
                ), [])
            }
            __export(events_exports, {
                getAbiEvents: ()=>getAbiEvents,
                parseEvents: ()=>parseEvents
            });
            var splitArgsAndOptions = args=>{
                const lastArg = args[args.length - 1];
                return "object" == typeof lastArg && ["blockIdentifier", "parseRequest", "parseResponse", "formatResponse", "maxFee", "nonce", "signature", "addressSalt"].some((x=>x in lastArg)) ? {
                    args,
                    options: args.pop()
                } : {
                    args
                }
            }
            ;
            function buildCall(contract, functionAbi) {
                return async function(...args) {
                    const params = splitArgsAndOptions(args);
                    return contract.call(functionAbi.name, params.args, {
                        parseRequest: !0,
                        parseResponse: !0,
                        ...params.options
                    })
                }
            }
            function buildDefault(contract, functionAbi) {
                return "view" === functionAbi.stateMutability || "view" === functionAbi.state_mutability ? buildCall(contract, functionAbi) : function(contract, functionAbi) {
                    return async function(...args) {
                        const params = splitArgsAndOptions(args);
                        return contract.invoke(functionAbi.name, params.args, {
                            parseRequest: !0,
                            ...params.options
                        })
                    }
                }(contract, functionAbi)
            }
            function buildEstimate(contract, functionAbi) {
                return function(...args) {
                    return contract.estimate(functionAbi.name, args)
                }
            }
            function getCalldata(args, callback) {
                return Array.isArray(args) && "__compiled__"in args ? args : Array.isArray(args) && Array.isArray(args[0]) && "__compiled__"in args[0] ? args[0] : callback()
            }
            var Contract = class {
                constructor(abi, address, providerOrAccount=defaultProvider) {
                    this.address = address && address.toLowerCase(),
                    this.providerOrAccount = providerOrAccount,
                    this.callData = new CallData(abi),
                    this.structs = CallData.getAbiStruct(abi),
                    this.events = getAbiEvents(abi);
                    const parser = createAbiParser(abi);
                    this.abi = parser.getLegacyFormat();
                    const options = {
                        enumerable: !0,
                        value: {},
                        writable: !1
                    };
                    Object.defineProperties(this, {
                        functions: {
                            enumerable: !0,
                            value: {},
                            writable: !1
                        },
                        callStatic: {
                            enumerable: !0,
                            value: {},
                            writable: !1
                        },
                        populateTransaction: {
                            enumerable: !0,
                            value: {},
                            writable: !1
                        },
                        estimateFee: {
                            enumerable: !0,
                            value: {},
                            writable: !1
                        }
                    }),
                    this.abi.forEach((abiElement=>{
                        if ("function" !== abiElement.type)
                            return;
                        const signature = abiElement.name;
                        var contract, functionAbi;
                        this[signature] || Object.defineProperty(this, signature, {
                            ...options,
                            value: buildDefault(this, abiElement)
                        }),
                        this.functions[signature] || Object.defineProperty(this.functions, signature, {
                            ...options,
                            value: buildDefault(this, abiElement)
                        }),
                        this.callStatic[signature] || Object.defineProperty(this.callStatic, signature, {
                            ...options,
                            value: buildCall(this, abiElement)
                        }),
                        this.populateTransaction[signature] || Object.defineProperty(this.populateTransaction, signature, {
                            ...options,
                            value: (contract = this,
                            functionAbi = abiElement,
                            function(...args) {
                                return contract.populate(functionAbi.name, args)
                            }
                            )
                        }),
                        this.estimateFee[signature] || Object.defineProperty(this.estimateFee, signature, {
                            ...options,
                            value: buildEstimate(this, abiElement)
                        })
                    }
                    ))
                }
                attach(address) {
                    this.address = address
                }
                connect(providerOrAccount) {
                    this.providerOrAccount = providerOrAccount
                }
                async deployed() {
                    return this.deployTransactionHash && (await this.providerOrAccount.waitForTransaction(this.deployTransactionHash),
                    this.deployTransactionHash = void 0),
                    this
                }
                async call(method, args=[], {parseRequest=!0, parseResponse=!0, formatResponse, blockIdentifier}={}) {
                    assert(null !== this.address, "contract is not connected to an address");
                    const calldata = getCalldata(args, (()=>parseRequest ? (this.callData.validate("CALL", method, args),
                    this.callData.compile(method, args)) : args));
                    return this.providerOrAccount.callContract({
                        contractAddress: this.address,
                        calldata,
                        entrypoint: method
                    }, blockIdentifier).then((x=>parseResponse ? formatResponse ? this.callData.format(method, x.result, formatResponse) : this.callData.parse(method, x.result) : x.result))
                }
                invoke(method, args=[], {parseRequest=!0, maxFee, nonce, signature}={}) {
                    assert(null !== this.address, "contract is not connected to an address");
                    const calldata = getCalldata(args, (()=>parseRequest ? (this.callData.validate("INVOKE", method, args),
                    this.callData.compile(method, args)) : args))
                      , invocation = {
                        contractAddress: this.address,
                        calldata,
                        entrypoint: method
                    };
                    if ("execute"in this.providerOrAccount)
                        return this.providerOrAccount.execute(invocation, void 0, {
                            maxFee,
                            nonce
                        });
                    if (!nonce)
                        throw new Error("Nonce is required when invoking a function without an account");
                    return this.providerOrAccount.invokeFunction({
                        ...invocation,
                        signature
                    }, {
                        nonce
                    })
                }
                async estimate(method, args=[]) {
                    assert(null !== this.address, "contract is not connected to an address"),
                    getCalldata(args, (()=>!1)) || this.callData.validate("INVOKE", method, args);
                    const invocation = this.populate(method, args);
                    if ("estimateInvokeFee"in this.providerOrAccount)
                        return this.providerOrAccount.estimateInvokeFee(invocation);
                    throw Error("Contract must be connected to the account contract to estimate")
                }
                populate(method, args=[]) {
                    const calldata = getCalldata(args, (()=>this.callData.compile(method, args)));
                    return {
                        contractAddress: this.address,
                        entrypoint: method,
                        calldata
                    }
                }
                parseEvents(receipt) {
                    return parseEvents(receipt.events?.filter((event=>cleanHex(event.from_address) === cleanHex(this.address)), []) || [], this.events, this.structs, CallData.getAbiEnum(this.abi))
                }
                isCairo1() {
                    return cairo_exports.isCairo1Abi(this.abi)
                }
                async getVersion() {
                    return this.providerOrAccount.getContractVersion(this.address)
                }
                typed(tAbi) {
                    return this
                }
            }
              , ContractInterface = class {
            }
              , ContractFactory = class {
                constructor(params) {
                    this.compiledContract = params.compiledContract,
                    this.account = params.account,
                    this.casm = params.casm,
                    this.abi = params.abi ?? params.compiledContract.abi,
                    this.classHash = params.classHash,
                    this.compiledClassHash = params.compiledClassHash,
                    this.CallData = new CallData(this.abi)
                }
                async deploy(...args) {
                    const {args: param, options={
                        parseRequest: !0
                    }} = splitArgsAndOptions(args)
                      , constructorCalldata = getCalldata(param, (()=>options.parseRequest ? (this.CallData.validate("DEPLOY", "constructor", param),
                    this.CallData.compile("constructor", param)) : param))
                      , {deploy: {contract_address, transaction_hash}} = await this.account.declareAndDeploy({
                        contract: this.compiledContract,
                        casm: this.casm,
                        classHash: this.classHash,
                        compiledClassHash: this.compiledClassHash,
                        constructorCalldata,
                        salt: options.addressSalt
                    });
                    assert(Boolean(contract_address), "Deployment of the contract failed");
                    const contractInstance = new Contract(this.compiledContract.abi,contract_address,this.account);
                    return contractInstance.deployTransactionHash = transaction_hash,
                    contractInstance
                }
                connect(account) {
                    return this.account = account,
                    this
                }
                attach(address) {
                    return new Contract(this.abi,address,this.account)
                }
            }
              , import_utils4 = __webpack_require__(40219);
            function addAddressPadding(address) {
                return addHexPrefix(removeHexPrefix(toHex(address)).padStart(64, "0"))
            }
            function validateAndParseAddress(address) {
                assertInRange(address, ZERO, ADDR_BOUND - 1n, "Starknet Address");
                const result = addAddressPadding(address);
                if (!result.match(/^(0x)?[0-9a-fA-F]{64}$/))
                    throw new Error("Invalid Address Format");
                return result
            }
            function getChecksumAddress(address) {
                const chars = removeHexPrefix(validateAndParseAddress(address)).toLowerCase().split("")
                  , hex = removeHexPrefix(keccakBn(address))
                  , hashed = (0,
                import_utils4.hexToBytes)(hex.padStart(64, "0"));
                for (let i = 0; i < chars.length; i += 2)
                    hashed[i >> 1] >> 4 >= 8 && (chars[i] = chars[i].toUpperCase()),
                    (15 & hashed[i >> 1]) >= 8 && (chars[i + 1] = chars[i + 1].toUpperCase());
                return addHexPrefix(chars.join(""))
            }
            function validateChecksumAddress(address) {
                return getChecksumAddress(address) === address
            }
            var number = num_exports
        }
        ,
        79667: (__unused_webpack_module,exports)=>{
            "use strict";
            function assertNumber(n) {
                if (!Number.isSafeInteger(n))
                    throw new Error(`Wrong integer: ${n}`)
            }
            function isBytes(a) {
                return a instanceof Uint8Array || null != a && "object" == typeof a && "Uint8Array" === a.constructor.name
            }
            function chain(...args) {
                const id = a=>a
                  , wrap = (a,b)=>c=>a(b(c));
                return {
                    encode: args.map((x=>x.encode)).reduceRight(wrap, id),
                    decode: args.map((x=>x.decode)).reduce(wrap, id)
                }
            }
            function alphabet(alphabet) {
                return {
                    encode: digits=>{
                        if (!Array.isArray(digits) || digits.length && "number" != typeof digits[0])
                            throw new Error("alphabet.encode input should be an array of numbers");
                        return digits.map((i=>{
                            if (assertNumber(i),
                            i < 0 || i >= alphabet.length)
                                throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);
                            return alphabet[i]
                        }
                        ))
                    }
                    ,
                    decode: input=>{
                        if (!Array.isArray(input) || input.length && "string" != typeof input[0])
                            throw new Error("alphabet.decode input should be array of strings");
                        return input.map((letter=>{
                            if ("string" != typeof letter)
                                throw new Error(`alphabet.decode: not string element=${letter}`);
                            const index = alphabet.indexOf(letter);
                            if (-1 === index)
                                throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet}`);
                            return index
                        }
                        ))
                    }
                }
            }
            function join(separator="") {
                if ("string" != typeof separator)
                    throw new Error("join separator should be string");
                return {
                    encode: from=>{
                        if (!Array.isArray(from) || from.length && "string" != typeof from[0])
                            throw new Error("join.encode input should be array of strings");
                        for (let i of from)
                            if ("string" != typeof i)
                                throw new Error(`join.encode: non-string input=${i}`);
                        return from.join(separator)
                    }
                    ,
                    decode: to=>{
                        if ("string" != typeof to)
                            throw new Error("join.decode input should be string");
                        return to.split(separator)
                    }
                }
            }
            function padding(bits, chr="=") {
                if (assertNumber(bits),
                "string" != typeof chr)
                    throw new Error("padding chr should be string");
                return {
                    encode(data) {
                        if (!Array.isArray(data) || data.length && "string" != typeof data[0])
                            throw new Error("padding.encode input should be array of strings");
                        for (let i of data)
                            if ("string" != typeof i)
                                throw new Error(`padding.encode: non-string input=${i}`);
                        for (; data.length * bits % 8; )
                            data.push(chr);
                        return data
                    },
                    decode(input) {
                        if (!Array.isArray(input) || input.length && "string" != typeof input[0])
                            throw new Error("padding.encode input should be array of strings");
                        for (let i of input)
                            if ("string" != typeof i)
                                throw new Error(`padding.decode: non-string input=${i}`);
                        let end = input.length;
                        if (end * bits % 8)
                            throw new Error("Invalid padding: string should have whole number of bytes");
                        for (; end > 0 && input[end - 1] === chr; end--)
                            if (!((end - 1) * bits % 8))
                                throw new Error("Invalid padding: string has too much padding");
                        return input.slice(0, end)
                    }
                }
            }
            function normalize(fn) {
                if ("function" != typeof fn)
                    throw new Error("normalize fn should be function");
                return {
                    encode: from=>from,
                    decode: to=>fn(to)
                }
            }
            function convertRadix(data, from, to) {
                if (from < 2)
                    throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);
                if (to < 2)
                    throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
                if (!Array.isArray(data))
                    throw new Error("convertRadix: data should be array");
                if (!data.length)
                    return [];
                let pos = 0;
                const res = []
                  , digits = Array.from(data);
                for (digits.forEach((d=>{
                    if (assertNumber(d),
                    d < 0 || d >= from)
                        throw new Error(`Wrong integer: ${d}`)
                }
                )); ; ) {
                    let carry = 0
                      , done = !0;
                    for (let i = pos; i < digits.length; i++) {
                        const digit = digits[i]
                          , digitBase = from * carry + digit;
                        if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit != from * carry)
                            throw new Error("convertRadix: carry overflow");
                        carry = digitBase % to;
                        const rounded = Math.floor(digitBase / to);
                        if (digits[i] = rounded,
                        !Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
                            throw new Error("convertRadix: carry overflow");
                        done && (rounded ? done = !1 : pos = i)
                    }
                    if (res.push(carry),
                    done)
                        break
                }
                for (let i = 0; i < data.length - 1 && 0 === data[i]; i++)
                    res.push(0);
                return res.reverse()
            }
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.createBase58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64urlnopad = exports.base64url = exports.base64 = exports.base32crockford = exports.base32hex = exports.base32 = exports.base16 = exports.utils = exports.assertNumber = void 0,
            exports.assertNumber = assertNumber;
            const gcd = (a,b)=>b ? gcd(b, a % b) : a
              , radix2carry = (from,to)=>from + (to - gcd(from, to));
            function convertRadix2(data, from, to, padding) {
                if (!Array.isArray(data))
                    throw new Error("convertRadix2: data should be array");
                if (from <= 0 || from > 32)
                    throw new Error(`convertRadix2: wrong from=${from}`);
                if (to <= 0 || to > 32)
                    throw new Error(`convertRadix2: wrong to=${to}`);
                if (radix2carry(from, to) > 32)
                    throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
                let carry = 0
                  , pos = 0;
                const mask = 2 ** to - 1
                  , res = [];
                for (const n of data) {
                    if (assertNumber(n),
                    n >= 2 ** from)
                        throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
                    if (carry = carry << from | n,
                    pos + from > 32)
                        throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
                    for (pos += from; pos >= to; pos -= to)
                        res.push((carry >> pos - to & mask) >>> 0);
                    carry &= 2 ** pos - 1
                }
                if (carry = carry << to - pos & mask,
                !padding && pos >= from)
                    throw new Error("Excess padding");
                if (!padding && carry)
                    throw new Error(`Non-zero padding: ${carry}`);
                return padding && pos > 0 && res.push(carry >>> 0),
                res
            }
            function radix(num) {
                return assertNumber(num),
                {
                    encode: bytes=>{
                        if (!isBytes(bytes))
                            throw new Error("radix.encode input should be Uint8Array");
                        return convertRadix(Array.from(bytes), 256, num)
                    }
                    ,
                    decode: digits=>{
                        if (!Array.isArray(digits) || digits.length && "number" != typeof digits[0])
                            throw new Error("radix.decode input should be array of numbers");
                        return Uint8Array.from(convertRadix(digits, num, 256))
                    }
                }
            }
            function radix2(bits, revPadding=!1) {
                if (assertNumber(bits),
                bits <= 0 || bits > 32)
                    throw new Error("radix2: bits should be in (0..32]");
                if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
                    throw new Error("radix2: carry overflow");
                return {
                    encode: bytes=>{
                        if (!isBytes(bytes))
                            throw new Error("radix2.encode input should be Uint8Array");
                        return convertRadix2(Array.from(bytes), 8, bits, !revPadding)
                    }
                    ,
                    decode: digits=>{
                        if (!Array.isArray(digits) || digits.length && "number" != typeof digits[0])
                            throw new Error("radix2.decode input should be array of numbers");
                        return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding))
                    }
                }
            }
            function unsafeWrapper(fn) {
                if ("function" != typeof fn)
                    throw new Error("unsafeWrapper fn should be function");
                return function(...args) {
                    try {
                        return fn.apply(null, args)
                    } catch (e) {}
                }
            }
            function checksum(len, fn) {
                if (assertNumber(len),
                "function" != typeof fn)
                    throw new Error("checksum fn should be function");
                return {
                    encode(data) {
                        if (!isBytes(data))
                            throw new Error("checksum.encode: input should be Uint8Array");
                        const checksum = fn(data).slice(0, len)
                          , res = new Uint8Array(data.length + len);
                        return res.set(data),
                        res.set(checksum, data.length),
                        res
                    },
                    decode(data) {
                        if (!isBytes(data))
                            throw new Error("checksum.decode: input should be Uint8Array");
                        const payload = data.slice(0, -len)
                          , newChecksum = fn(payload).slice(0, len)
                          , oldChecksum = data.slice(-len);
                        for (let i = 0; i < len; i++)
                            if (newChecksum[i] !== oldChecksum[i])
                                throw new Error("Invalid checksum");
                        return payload
                    }
                }
            }
            exports.utils = {
                alphabet,
                chain,
                checksum,
                convertRadix,
                convertRadix2,
                radix,
                radix2,
                join,
                padding
            },
            exports.base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join("")),
            exports.base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join("")),
            exports.base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join("")),
            exports.base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize((s=>s.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")))),
            exports.base64 = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join("")),
            exports.base64url = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join("")),
            exports.base64urlnopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), join(""));
            const genBase58 = abc=>chain(radix(58), alphabet(abc), join(""));
            exports.base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),
            exports.base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"),
            exports.base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
            const XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];
            exports.base58xmr = {
                encode(data) {
                    let res = "";
                    for (let i = 0; i < data.length; i += 8) {
                        const block = data.subarray(i, i + 8);
                        res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], "1")
                    }
                    return res
                },
                decode(str) {
                    let res = [];
                    for (let i = 0; i < str.length; i += 11) {
                        const slice = str.slice(i, i + 11)
                          , blockLen = XMR_BLOCK_LEN.indexOf(slice.length)
                          , block = exports.base58.decode(slice);
                        for (let j = 0; j < block.length - blockLen; j++)
                            if (0 !== block[j])
                                throw new Error("base58xmr: wrong padding");
                        res = res.concat(Array.from(block.slice(block.length - blockLen)))
                    }
                    return Uint8Array.from(res)
                }
            };
            exports.createBase58check = sha256=>chain(checksum(4, (data=>sha256(sha256(data)))), exports.base58),
            exports.base58check = exports.createBase58check;
            const BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""))
              , POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
            function bech32Polymod(pre) {
                const b = pre >> 25;
                let chk = (33554431 & pre) << 5;
                for (let i = 0; i < POLYMOD_GENERATORS.length; i++)
                    1 == (b >> i & 1) && (chk ^= POLYMOD_GENERATORS[i]);
                return chk
            }
            function bechChecksum(prefix, words, encodingConst=1) {
                const len = prefix.length;
                let chk = 1;
                for (let i = 0; i < len; i++) {
                    const c = prefix.charCodeAt(i);
                    if (c < 33 || c > 126)
                        throw new Error(`Invalid prefix (${prefix})`);
                    chk = bech32Polymod(chk) ^ c >> 5
                }
                chk = bech32Polymod(chk);
                for (let i = 0; i < len; i++)
                    chk = bech32Polymod(chk) ^ 31 & prefix.charCodeAt(i);
                for (let v of words)
                    chk = bech32Polymod(chk) ^ v;
                for (let i = 0; i < 6; i++)
                    chk = bech32Polymod(chk);
                return chk ^= encodingConst,
                BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, !1))
            }
            function genBech32(encoding) {
                const ENCODING_CONST = "bech32" === encoding ? 1 : 734539939
                  , _words = radix2(5)
                  , fromWords = _words.decode
                  , toWords = _words.encode
                  , fromWordsUnsafe = unsafeWrapper(fromWords);
                function decode(str, limit=90) {
                    if ("string" != typeof str)
                        throw new Error("bech32.decode input should be string, not " + typeof str);
                    if (str.length < 8 || !1 !== limit && str.length > limit)
                        throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);
                    const lowered = str.toLowerCase();
                    if (str !== lowered && str !== str.toUpperCase())
                        throw new Error("String must be lowercase or uppercase");
                    const sepIndex = (str = lowered).lastIndexOf("1");
                    if (0 === sepIndex || -1 === sepIndex)
                        throw new Error('Letter "1" must be present between prefix and data only');
                    const prefix = str.slice(0, sepIndex)
                      , _words = str.slice(sepIndex + 1);
                    if (_words.length < 6)
                        throw new Error("Data must be at least 6 characters long");
                    const words = BECH_ALPHABET.decode(_words).slice(0, -6)
                      , sum = bechChecksum(prefix, words, ENCODING_CONST);
                    if (!_words.endsWith(sum))
                        throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
                    return {
                        prefix,
                        words
                    }
                }
                return {
                    encode: function(prefix, words, limit=90) {
                        if ("string" != typeof prefix)
                            throw new Error("bech32.encode prefix should be string, not " + typeof prefix);
                        if (!Array.isArray(words) || words.length && "number" != typeof words[0])
                            throw new Error("bech32.encode words should be array of numbers, not " + typeof words);
                        const actualLength = prefix.length + 7 + words.length;
                        if (!1 !== limit && actualLength > limit)
                            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
                        const lowered = prefix.toLowerCase()
                          , sum = bechChecksum(lowered, words, ENCODING_CONST);
                        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`
                    },
                    decode,
                    decodeToBytes: function(str) {
                        const {prefix, words} = decode(str, !1);
                        return {
                            prefix,
                            words,
                            bytes: fromWords(words)
                        }
                    },
                    decodeUnsafe: unsafeWrapper(decode),
                    fromWords,
                    fromWordsUnsafe,
                    toWords
                }
            }
            exports.bech32 = genBech32("bech32"),
            exports.bech32m = genBech32("bech32m"),
            exports.utf8 = {
                encode: data=>(new TextDecoder).decode(data),
                decode: str=>(new TextEncoder).encode(str)
            },
            exports.hex = chain(radix2(4), alphabet("0123456789abcdef"), join(""), normalize((s=>{
                if ("string" != typeof s || s.length % 2)
                    throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
                return s.toLowerCase()
            }
            )));
            const CODERS = {
                utf8: exports.utf8,
                hex: exports.hex,
                base16: exports.base16,
                base32: exports.base32,
                base64: exports.base64,
                base64url: exports.base64url,
                base58: exports.base58,
                base58xmr: exports.base58xmr
            }
              , coderTypeError = "Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr";
            exports.bytesToString = (type,bytes)=>{
                if ("string" != typeof type || !CODERS.hasOwnProperty(type))
                    throw new TypeError(coderTypeError);
                if (!isBytes(bytes))
                    throw new TypeError("bytesToString() expects Uint8Array");
                return CODERS[type].encode(bytes)
            }
            ,
            exports.str = exports.bytesToString;
            exports.stringToBytes = (type,str)=>{
                if (!CODERS.hasOwnProperty(type))
                    throw new TypeError(coderTypeError);
                if ("string" != typeof str)
                    throw new TypeError("stringToBytes() expects string");
                return CODERS[type].decode(str)
            }
            ,
            exports.bytes = exports.stringToBytes
        }
        ,
        68660: (module,__unused_webpack_exports,__webpack_require__)=>{
            "use strict";
            const {Deflate, deflate, deflateRaw, gzip} = __webpack_require__(55498)
              , {Inflate, inflate, inflateRaw, ungzip} = __webpack_require__(10034)
              , constants = __webpack_require__(13991);
            module.exports.Deflate = Deflate,
            module.exports.deflate = deflate,
            module.exports.deflateRaw = deflateRaw,
            module.exports.gzip = gzip,
            module.exports.Inflate = Inflate,
            module.exports.inflate = inflate,
            module.exports.inflateRaw = inflateRaw,
            module.exports.ungzip = ungzip,
            module.exports.constants = constants
        }
        ,
        55498: (module,__unused_webpack_exports,__webpack_require__)=>{
            "use strict";
            const zlib_deflate = __webpack_require__(95486)
              , utils = __webpack_require__(7698)
              , strings = __webpack_require__(50052)
              , msg = __webpack_require__(18521)
              , ZStream = __webpack_require__(90971)
              , toString = Object.prototype.toString
              , {Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH, Z_OK, Z_STREAM_END, Z_DEFAULT_COMPRESSION, Z_DEFAULT_STRATEGY, Z_DEFLATED} = __webpack_require__(13991);
            function Deflate(options) {
                this.options = utils.assign({
                    level: Z_DEFAULT_COMPRESSION,
                    method: Z_DEFLATED,
                    chunkSize: 16384,
                    windowBits: 15,
                    memLevel: 8,
                    strategy: Z_DEFAULT_STRATEGY
                }, options || {});
                let opt = this.options;
                opt.raw && opt.windowBits > 0 ? opt.windowBits = -opt.windowBits : opt.gzip && opt.windowBits > 0 && opt.windowBits < 16 && (opt.windowBits += 16),
                this.err = 0,
                this.msg = "",
                this.ended = !1,
                this.chunks = [],
                this.strm = new ZStream,
                this.strm.avail_out = 0;
                let status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
                if (status !== Z_OK)
                    throw new Error(msg[status]);
                if (opt.header && zlib_deflate.deflateSetHeader(this.strm, opt.header),
                opt.dictionary) {
                    let dict;
                    if (dict = "string" == typeof opt.dictionary ? strings.string2buf(opt.dictionary) : "[object ArrayBuffer]" === toString.call(opt.dictionary) ? new Uint8Array(opt.dictionary) : opt.dictionary,
                    status = zlib_deflate.deflateSetDictionary(this.strm, dict),
                    status !== Z_OK)
                        throw new Error(msg[status]);
                    this._dict_set = !0
                }
            }
            function deflate(input, options) {
                const deflator = new Deflate(options);
                if (deflator.push(input, !0),
                deflator.err)
                    throw deflator.msg || msg[deflator.err];
                return deflator.result
            }
            Deflate.prototype.push = function(data, flush_mode) {
                const strm = this.strm
                  , chunkSize = this.options.chunkSize;
                let status, _flush_mode;
                if (this.ended)
                    return !1;
                for (_flush_mode = flush_mode === ~~flush_mode ? flush_mode : !0 === flush_mode ? Z_FINISH : Z_NO_FLUSH,
                "string" == typeof data ? strm.input = strings.string2buf(data) : "[object ArrayBuffer]" === toString.call(data) ? strm.input = new Uint8Array(data) : strm.input = data,
                strm.next_in = 0,
                strm.avail_in = strm.input.length; ; )
                    if (0 === strm.avail_out && (strm.output = new Uint8Array(chunkSize),
                    strm.next_out = 0,
                    strm.avail_out = chunkSize),
                    (_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6)
                        this.onData(strm.output.subarray(0, strm.next_out)),
                        strm.avail_out = 0;
                    else {
                        if (status = zlib_deflate.deflate(strm, _flush_mode),
                        status === Z_STREAM_END)
                            return strm.next_out > 0 && this.onData(strm.output.subarray(0, strm.next_out)),
                            status = zlib_deflate.deflateEnd(this.strm),
                            this.onEnd(status),
                            this.ended = !0,
                            status === Z_OK;
                        if (0 !== strm.avail_out) {
                            if (_flush_mode > 0 && strm.next_out > 0)
                                this.onData(strm.output.subarray(0, strm.next_out)),
                                strm.avail_out = 0;
                            else if (0 === strm.avail_in)
                                break
                        } else
                            this.onData(strm.output)
                    }
                return !0
            }
            ,
            Deflate.prototype.onData = function(chunk) {
                this.chunks.push(chunk)
            }
            ,
            Deflate.prototype.onEnd = function(status) {
                status === Z_OK && (this.result = utils.flattenChunks(this.chunks)),
                this.chunks = [],
                this.err = status,
                this.msg = this.strm.msg
            }
            ,
            module.exports.Deflate = Deflate,
            module.exports.deflate = deflate,
            module.exports.deflateRaw = function(input, options) {
                return (options = options || {}).raw = !0,
                deflate(input, options)
            }
            ,
            module.exports.gzip = function(input, options) {
                return (options = options || {}).gzip = !0,
                deflate(input, options)
            }
            ,
            module.exports.constants = __webpack_require__(13991)
        }
        ,
        10034: (module,__unused_webpack_exports,__webpack_require__)=>{
            "use strict";
            const zlib_inflate = __webpack_require__(39823)
              , utils = __webpack_require__(7698)
              , strings = __webpack_require__(50052)
              , msg = __webpack_require__(18521)
              , ZStream = __webpack_require__(90971)
              , GZheader = __webpack_require__(68524)
              , toString = Object.prototype.toString
              , {Z_NO_FLUSH, Z_FINISH, Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR} = __webpack_require__(13991);
            function Inflate(options) {
                this.options = utils.assign({
                    chunkSize: 65536,
                    windowBits: 15,
                    to: ""
                }, options || {});
                const opt = this.options;
                opt.raw && opt.windowBits >= 0 && opt.windowBits < 16 && (opt.windowBits = -opt.windowBits,
                0 === opt.windowBits && (opt.windowBits = -15)),
                !(opt.windowBits >= 0 && opt.windowBits < 16) || options && options.windowBits || (opt.windowBits += 32),
                opt.windowBits > 15 && opt.windowBits < 48 && 0 == (15 & opt.windowBits) && (opt.windowBits |= 15),
                this.err = 0,
                this.msg = "",
                this.ended = !1,
                this.chunks = [],
                this.strm = new ZStream,
                this.strm.avail_out = 0;
                let status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
                if (status !== Z_OK)
                    throw new Error(msg[status]);
                if (this.header = new GZheader,
                zlib_inflate.inflateGetHeader(this.strm, this.header),
                opt.dictionary && ("string" == typeof opt.dictionary ? opt.dictionary = strings.string2buf(opt.dictionary) : "[object ArrayBuffer]" === toString.call(opt.dictionary) && (opt.dictionary = new Uint8Array(opt.dictionary)),
                opt.raw && (status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary),
                status !== Z_OK)))
                    throw new Error(msg[status])
            }
            function inflate(input, options) {
                const inflator = new Inflate(options);
                if (inflator.push(input),
                inflator.err)
                    throw inflator.msg || msg[inflator.err];
                return inflator.result
            }
            Inflate.prototype.push = function(data, flush_mode) {
                const strm = this.strm
                  , chunkSize = this.options.chunkSize
                  , dictionary = this.options.dictionary;
                let status, _flush_mode, last_avail_out;
                if (this.ended)
                    return !1;
                for (_flush_mode = flush_mode === ~~flush_mode ? flush_mode : !0 === flush_mode ? Z_FINISH : Z_NO_FLUSH,
                "[object ArrayBuffer]" === toString.call(data) ? strm.input = new Uint8Array(data) : strm.input = data,
                strm.next_in = 0,
                strm.avail_in = strm.input.length; ; ) {
                    for (0 === strm.avail_out && (strm.output = new Uint8Array(chunkSize),
                    strm.next_out = 0,
                    strm.avail_out = chunkSize),
                    status = zlib_inflate.inflate(strm, _flush_mode),
                    status === Z_NEED_DICT && dictionary && (status = zlib_inflate.inflateSetDictionary(strm, dictionary),
                    status === Z_OK ? status = zlib_inflate.inflate(strm, _flush_mode) : status === Z_DATA_ERROR && (status = Z_NEED_DICT)); strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && 0 !== data[strm.next_in]; )
                        zlib_inflate.inflateReset(strm),
                        status = zlib_inflate.inflate(strm, _flush_mode);
                    switch (status) {
                    case Z_STREAM_ERROR:
                    case Z_DATA_ERROR:
                    case Z_NEED_DICT:
                    case Z_MEM_ERROR:
                        return this.onEnd(status),
                        this.ended = !0,
                        !1
                    }
                    if (last_avail_out = strm.avail_out,
                    strm.next_out && (0 === strm.avail_out || status === Z_STREAM_END))
                        if ("string" === this.options.to) {
                            let next_out_utf8 = strings.utf8border(strm.output, strm.next_out)
                              , tail = strm.next_out - next_out_utf8
                              , utf8str = strings.buf2string(strm.output, next_out_utf8);
                            strm.next_out = tail,
                            strm.avail_out = chunkSize - tail,
                            tail && strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0),
                            this.onData(utf8str)
                        } else
                            this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
                    if (status !== Z_OK || 0 !== last_avail_out) {
                        if (status === Z_STREAM_END)
                            return status = zlib_inflate.inflateEnd(this.strm),
                            this.onEnd(status),
                            this.ended = !0,
                            !0;
                        if (0 === strm.avail_in)
                            break
                    }
                }
                return !0
            }
            ,
            Inflate.prototype.onData = function(chunk) {
                this.chunks.push(chunk)
            }
            ,
            Inflate.prototype.onEnd = function(status) {
                status === Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = utils.flattenChunks(this.chunks)),
                this.chunks = [],
                this.err = status,
                this.msg = this.strm.msg
            }
            ,
            module.exports.Inflate = Inflate,
            module.exports.inflate = inflate,
            module.exports.inflateRaw = function(input, options) {
                return (options = options || {}).raw = !0,
                inflate(input, options)
            }
            ,
            module.exports.ungzip = inflate,
            module.exports.constants = __webpack_require__(13991)
        }
        ,
        7698: module=>{
            "use strict";
            const _has = (obj,key)=>Object.prototype.hasOwnProperty.call(obj, key);
            module.exports.assign = function(obj) {
                const sources = Array.prototype.slice.call(arguments, 1);
                for (; sources.length; ) {
                    const source = sources.shift();
                    if (source) {
                        if ("object" != typeof source)
                            throw new TypeError(source + "must be non-object");
                        for (const p in source)
                            _has(source, p) && (obj[p] = source[p])
                    }
                }
                return obj
            }
            ,
            module.exports.flattenChunks = chunks=>{
                let len = 0;
                for (let i = 0, l = chunks.length; i < l; i++)
                    len += chunks[i].length;
                const result = new Uint8Array(len);
                for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
                    let chunk = chunks[i];
                    result.set(chunk, pos),
                    pos += chunk.length
                }
                return result
            }
        }
        ,
        50052: module=>{
            "use strict";
            let STR_APPLY_UIA_OK = !0;
            try {
                String.fromCharCode.apply(null, new Uint8Array(1))
            } catch (__) {
                STR_APPLY_UIA_OK = !1
            }
            const _utf8len = new Uint8Array(256);
            for (let q = 0; q < 256; q++)
                _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
            _utf8len[254] = _utf8len[254] = 1,
            module.exports.string2buf = str=>{
                if ("function" == typeof TextEncoder && TextEncoder.prototype.encode)
                    return (new TextEncoder).encode(str);
                let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
                for (m_pos = 0; m_pos < str_len; m_pos++)
                    c = str.charCodeAt(m_pos),
                    55296 == (64512 & c) && m_pos + 1 < str_len && (c2 = str.charCodeAt(m_pos + 1),
                    56320 == (64512 & c2) && (c = 65536 + (c - 55296 << 10) + (c2 - 56320),
                    m_pos++)),
                    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
                for (buf = new Uint8Array(buf_len),
                i = 0,
                m_pos = 0; i < buf_len; m_pos++)
                    c = str.charCodeAt(m_pos),
                    55296 == (64512 & c) && m_pos + 1 < str_len && (c2 = str.charCodeAt(m_pos + 1),
                    56320 == (64512 & c2) && (c = 65536 + (c - 55296 << 10) + (c2 - 56320),
                    m_pos++)),
                    c < 128 ? buf[i++] = c : c < 2048 ? (buf[i++] = 192 | c >>> 6,
                    buf[i++] = 128 | 63 & c) : c < 65536 ? (buf[i++] = 224 | c >>> 12,
                    buf[i++] = 128 | c >>> 6 & 63,
                    buf[i++] = 128 | 63 & c) : (buf[i++] = 240 | c >>> 18,
                    buf[i++] = 128 | c >>> 12 & 63,
                    buf[i++] = 128 | c >>> 6 & 63,
                    buf[i++] = 128 | 63 & c);
                return buf
            }
            ;
            module.exports.buf2string = (buf,max)=>{
                const len = max || buf.length;
                if ("function" == typeof TextDecoder && TextDecoder.prototype.decode)
                    return (new TextDecoder).decode(buf.subarray(0, max));
                let i, out;
                const utf16buf = new Array(2 * len);
                for (out = 0,
                i = 0; i < len; ) {
                    let c = buf[i++];
                    if (c < 128) {
                        utf16buf[out++] = c;
                        continue
                    }
                    let c_len = _utf8len[c];
                    if (c_len > 4)
                        utf16buf[out++] = 65533,
                        i += c_len - 1;
                    else {
                        for (c &= 2 === c_len ? 31 : 3 === c_len ? 15 : 7; c_len > 1 && i < len; )
                            c = c << 6 | 63 & buf[i++],
                            c_len--;
                        c_len > 1 ? utf16buf[out++] = 65533 : c < 65536 ? utf16buf[out++] = c : (c -= 65536,
                        utf16buf[out++] = 55296 | c >> 10 & 1023,
                        utf16buf[out++] = 56320 | 1023 & c)
                    }
                }
                return ((buf,len)=>{
                    if (len < 65534 && buf.subarray && STR_APPLY_UIA_OK)
                        return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
                    let result = "";
                    for (let i = 0; i < len; i++)
                        result += String.fromCharCode(buf[i]);
                    return result
                }
                )(utf16buf, out)
            }
            ,
            module.exports.utf8border = (buf,max)=>{
                (max = max || buf.length) > buf.length && (max = buf.length);
                let pos = max - 1;
                for (; pos >= 0 && 128 == (192 & buf[pos]); )
                    pos--;
                return pos < 0 || 0 === pos ? max : pos + _utf8len[buf[pos]] > max ? pos : max
            }
        }
        ,
        94541: module=>{
            "use strict";
            module.exports = (adler,buf,len,pos)=>{
                let s1 = 65535 & adler | 0
                  , s2 = adler >>> 16 & 65535 | 0
                  , n = 0;
                for (; 0 !== len; ) {
                    n = len > 2e3 ? 2e3 : len,
                    len -= n;
                    do {
                        s1 = s1 + buf[pos++] | 0,
                        s2 = s2 + s1 | 0
                    } while (--n);
                    s1 %= 65521,
                    s2 %= 65521
                }
                return s1 | s2 << 16 | 0
            }
        }
        ,
        13991: module=>{
            "use strict";
            module.exports = {
                Z_NO_FLUSH: 0,
                Z_PARTIAL_FLUSH: 1,
                Z_SYNC_FLUSH: 2,
                Z_FULL_FLUSH: 3,
                Z_FINISH: 4,
                Z_BLOCK: 5,
                Z_TREES: 6,
                Z_OK: 0,
                Z_STREAM_END: 1,
                Z_NEED_DICT: 2,
                Z_ERRNO: -1,
                Z_STREAM_ERROR: -2,
                Z_DATA_ERROR: -3,
                Z_MEM_ERROR: -4,
                Z_BUF_ERROR: -5,
                Z_NO_COMPRESSION: 0,
                Z_BEST_SPEED: 1,
                Z_BEST_COMPRESSION: 9,
                Z_DEFAULT_COMPRESSION: -1,
                Z_FILTERED: 1,
                Z_HUFFMAN_ONLY: 2,
                Z_RLE: 3,
                Z_FIXED: 4,
                Z_DEFAULT_STRATEGY: 0,
                Z_BINARY: 0,
                Z_TEXT: 1,
                Z_UNKNOWN: 2,
                Z_DEFLATED: 8
            }
        }
        ,
        84270: module=>{
            "use strict";
            const crcTable = new Uint32Array((()=>{
                let c, table = [];
                for (var n = 0; n < 256; n++) {
                    c = n;
                    for (var k = 0; k < 8; k++)
                        c = 1 & c ? 3988292384 ^ c >>> 1 : c >>> 1;
                    table[n] = c
                }
                return table
            }
            )());
            module.exports = (crc,buf,len,pos)=>{
                const t = crcTable
                  , end = pos + len;
                crc ^= -1;
                for (let i = pos; i < end; i++)
                    crc = crc >>> 8 ^ t[255 & (crc ^ buf[i])];
                return -1 ^ crc
            }
        }
        ,
        95486: (module,__unused_webpack_exports,__webpack_require__)=>{
            "use strict";
            const {_tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align} = __webpack_require__(22416)
              , adler32 = __webpack_require__(94541)
              , crc32 = __webpack_require__(84270)
              , msg = __webpack_require__(18521)
              , {Z_NO_FLUSH, Z_PARTIAL_FLUSH, Z_FULL_FLUSH, Z_FINISH, Z_BLOCK, Z_OK, Z_STREAM_END, Z_STREAM_ERROR, Z_DATA_ERROR, Z_BUF_ERROR, Z_DEFAULT_COMPRESSION, Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY, Z_UNKNOWN, Z_DEFLATED} = __webpack_require__(13991)
              , err = (strm,errorCode)=>(strm.msg = msg[errorCode],
            errorCode)
              , rank = f=>2 * f - (f > 4 ? 9 : 0)
              , zero = buf=>{
                let len = buf.length;
                for (; --len >= 0; )
                    buf[len] = 0
            }
              , slide_hash = s=>{
                let n, m, p, wsize = s.w_size;
                n = s.hash_size,
                p = n;
                do {
                    m = s.head[--p],
                    s.head[p] = m >= wsize ? m - wsize : 0
                } while (--n);
                n = wsize,
                p = n;
                do {
                    m = s.prev[--p],
                    s.prev[p] = m >= wsize ? m - wsize : 0
                } while (--n)
            }
            ;
            let HASH = (s,prev,data)=>(prev << s.hash_shift ^ data) & s.hash_mask;
            const flush_pending = strm=>{
                const s = strm.state;
                let len = s.pending;
                len > strm.avail_out && (len = strm.avail_out),
                0 !== len && (strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out),
                strm.next_out += len,
                s.pending_out += len,
                strm.total_out += len,
                strm.avail_out -= len,
                s.pending -= len,
                0 === s.pending && (s.pending_out = 0))
            }
              , flush_block_only = (s,last)=>{
                _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last),
                s.block_start = s.strstart,
                flush_pending(s.strm)
            }
              , put_byte = (s,b)=>{
                s.pending_buf[s.pending++] = b
            }
              , putShortMSB = (s,b)=>{
                s.pending_buf[s.pending++] = b >>> 8 & 255,
                s.pending_buf[s.pending++] = 255 & b
            }
              , read_buf = (strm,buf,start,size)=>{
                let len = strm.avail_in;
                return len > size && (len = size),
                0 === len ? 0 : (strm.avail_in -= len,
                buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start),
                1 === strm.state.wrap ? strm.adler = adler32(strm.adler, buf, len, start) : 2 === strm.state.wrap && (strm.adler = crc32(strm.adler, buf, len, start)),
                strm.next_in += len,
                strm.total_in += len,
                len)
            }
              , longest_match = (s,cur_match)=>{
                let match, len, chain_length = s.max_chain_length, scan = s.strstart, best_len = s.prev_length, nice_match = s.nice_match;
                const limit = s.strstart > s.w_size - 262 ? s.strstart - (s.w_size - 262) : 0
                  , _win = s.window
                  , wmask = s.w_mask
                  , prev = s.prev
                  , strend = s.strstart + 258;
                let scan_end1 = _win[scan + best_len - 1]
                  , scan_end = _win[scan + best_len];
                s.prev_length >= s.good_match && (chain_length >>= 2),
                nice_match > s.lookahead && (nice_match = s.lookahead);
                do {
                    if (match = cur_match,
                    _win[match + best_len] === scan_end && _win[match + best_len - 1] === scan_end1 && _win[match] === _win[scan] && _win[++match] === _win[scan + 1]) {
                        scan += 2,
                        match++;
                        do {} while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
                        if (len = 258 - (strend - scan),
                        scan = strend - 258,
                        len > best_len) {
                            if (s.match_start = cur_match,
                            best_len = len,
                            len >= nice_match)
                                break;
                            scan_end1 = _win[scan + best_len - 1],
                            scan_end = _win[scan + best_len]
                        }
                    }
                } while ((cur_match = prev[cur_match & wmask]) > limit && 0 != --chain_length);
                return best_len <= s.lookahead ? best_len : s.lookahead
            }
              , fill_window = s=>{
                const _w_size = s.w_size;
                let n, more, str;
                do {
                    if (more = s.window_size - s.lookahead - s.strstart,
                    s.strstart >= _w_size + (_w_size - 262) && (s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0),
                    s.match_start -= _w_size,
                    s.strstart -= _w_size,
                    s.block_start -= _w_size,
                    s.insert > s.strstart && (s.insert = s.strstart),
                    slide_hash(s),
                    more += _w_size),
                    0 === s.strm.avail_in)
                        break;
                    if (n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more),
                    s.lookahead += n,
                    s.lookahead + s.insert >= 3)
                        for (str = s.strstart - s.insert,
                        s.ins_h = s.window[str],
                        s.ins_h = HASH(s, s.ins_h, s.window[str + 1]); s.insert && (s.ins_h = HASH(s, s.ins_h, s.window[str + 3 - 1]),
                        s.prev[str & s.w_mask] = s.head[s.ins_h],
                        s.head[s.ins_h] = str,
                        str++,
                        s.insert--,
                        !(s.lookahead + s.insert < 3)); )
                            ;
                } while (s.lookahead < 262 && 0 !== s.strm.avail_in)
            }
              , deflate_stored = (s,flush)=>{
                let len, left, have, min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5, last = 0, used = s.strm.avail_in;
                do {
                    if (len = 65535,
                    have = s.bi_valid + 42 >> 3,
                    s.strm.avail_out < have)
                        break;
                    if (have = s.strm.avail_out - have,
                    left = s.strstart - s.block_start,
                    len > left + s.strm.avail_in && (len = left + s.strm.avail_in),
                    len > have && (len = have),
                    len < min_block && (0 === len && flush !== Z_FINISH || flush === Z_NO_FLUSH || len !== left + s.strm.avail_in))
                        break;
                    last = flush === Z_FINISH && len === left + s.strm.avail_in ? 1 : 0,
                    _tr_stored_block(s, 0, 0, last),
                    s.pending_buf[s.pending - 4] = len,
                    s.pending_buf[s.pending - 3] = len >> 8,
                    s.pending_buf[s.pending - 2] = ~len,
                    s.pending_buf[s.pending - 1] = ~len >> 8,
                    flush_pending(s.strm),
                    left && (left > len && (left = len),
                    s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out),
                    s.strm.next_out += left,
                    s.strm.avail_out -= left,
                    s.strm.total_out += left,
                    s.block_start += left,
                    len -= left),
                    len && (read_buf(s.strm, s.strm.output, s.strm.next_out, len),
                    s.strm.next_out += len,
                    s.strm.avail_out -= len,
                    s.strm.total_out += len)
                } while (0 === last);
                return used -= s.strm.avail_in,
                used && (used >= s.w_size ? (s.matches = 2,
                s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0),
                s.strstart = s.w_size,
                s.insert = s.strstart) : (s.window_size - s.strstart <= used && (s.strstart -= s.w_size,
                s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0),
                s.matches < 2 && s.matches++,
                s.insert > s.strstart && (s.insert = s.strstart)),
                s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart),
                s.strstart += used,
                s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used),
                s.block_start = s.strstart),
                s.high_water < s.strstart && (s.high_water = s.strstart),
                last ? 4 : flush !== Z_NO_FLUSH && flush !== Z_FINISH && 0 === s.strm.avail_in && s.strstart === s.block_start ? 2 : (have = s.window_size - s.strstart,
                s.strm.avail_in > have && s.block_start >= s.w_size && (s.block_start -= s.w_size,
                s.strstart -= s.w_size,
                s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0),
                s.matches < 2 && s.matches++,
                have += s.w_size,
                s.insert > s.strstart && (s.insert = s.strstart)),
                have > s.strm.avail_in && (have = s.strm.avail_in),
                have && (read_buf(s.strm, s.window, s.strstart, have),
                s.strstart += have,
                s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have),
                s.high_water < s.strstart && (s.high_water = s.strstart),
                have = s.bi_valid + 42 >> 3,
                have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have,
                min_block = have > s.w_size ? s.w_size : have,
                left = s.strstart - s.block_start,
                (left >= min_block || (left || flush === Z_FINISH) && flush !== Z_NO_FLUSH && 0 === s.strm.avail_in && left <= have) && (len = left > have ? have : left,
                last = flush === Z_FINISH && 0 === s.strm.avail_in && len === left ? 1 : 0,
                _tr_stored_block(s, s.block_start, len, last),
                s.block_start += len,
                flush_pending(s.strm)),
                last ? 3 : 1)
            }
              , deflate_fast = (s,flush)=>{
                let hash_head, bflush;
                for (; ; ) {
                    if (s.lookahead < 262) {
                        if (fill_window(s),
                        s.lookahead < 262 && flush === Z_NO_FLUSH)
                            return 1;
                        if (0 === s.lookahead)
                            break
                    }
                    if (hash_head = 0,
                    s.lookahead >= 3 && (s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 3 - 1]),
                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h],
                    s.head[s.ins_h] = s.strstart),
                    0 !== hash_head && s.strstart - hash_head <= s.w_size - 262 && (s.match_length = longest_match(s, hash_head)),
                    s.match_length >= 3)
                        if (bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - 3),
                        s.lookahead -= s.match_length,
                        s.match_length <= s.max_lazy_match && s.lookahead >= 3) {
                            s.match_length--;
                            do {
                                s.strstart++,
                                s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 3 - 1]),
                                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h],
                                s.head[s.ins_h] = s.strstart
                            } while (0 != --s.match_length);
                            s.strstart++
                        } else
                            s.strstart += s.match_length,
                            s.match_length = 0,
                            s.ins_h = s.window[s.strstart],
                            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
                    else
                        bflush = _tr_tally(s, 0, s.window[s.strstart]),
                        s.lookahead--,
                        s.strstart++;
                    if (bflush && (flush_block_only(s, !1),
                    0 === s.strm.avail_out))
                        return 1
                }
                return s.insert = s.strstart < 2 ? s.strstart : 2,
                flush === Z_FINISH ? (flush_block_only(s, !0),
                0 === s.strm.avail_out ? 3 : 4) : s.sym_next && (flush_block_only(s, !1),
                0 === s.strm.avail_out) ? 1 : 2
            }
              , deflate_slow = (s,flush)=>{
                let hash_head, bflush, max_insert;
                for (; ; ) {
                    if (s.lookahead < 262) {
                        if (fill_window(s),
                        s.lookahead < 262 && flush === Z_NO_FLUSH)
                            return 1;
                        if (0 === s.lookahead)
                            break
                    }
                    if (hash_head = 0,
                    s.lookahead >= 3 && (s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 3 - 1]),
                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h],
                    s.head[s.ins_h] = s.strstart),
                    s.prev_length = s.match_length,
                    s.prev_match = s.match_start,
                    s.match_length = 2,
                    0 !== hash_head && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - 262 && (s.match_length = longest_match(s, hash_head),
                    s.match_length <= 5 && (s.strategy === Z_FILTERED || 3 === s.match_length && s.strstart - s.match_start > 4096) && (s.match_length = 2)),
                    s.prev_length >= 3 && s.match_length <= s.prev_length) {
                        max_insert = s.strstart + s.lookahead - 3,
                        bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - 3),
                        s.lookahead -= s.prev_length - 1,
                        s.prev_length -= 2;
                        do {
                            ++s.strstart <= max_insert && (s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 3 - 1]),
                            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h],
                            s.head[s.ins_h] = s.strstart)
                        } while (0 != --s.prev_length);
                        if (s.match_available = 0,
                        s.match_length = 2,
                        s.strstart++,
                        bflush && (flush_block_only(s, !1),
                        0 === s.strm.avail_out))
                            return 1
                    } else if (s.match_available) {
                        if (bflush = _tr_tally(s, 0, s.window[s.strstart - 1]),
                        bflush && flush_block_only(s, !1),
                        s.strstart++,
                        s.lookahead--,
                        0 === s.strm.avail_out)
                            return 1
                    } else
                        s.match_available = 1,
                        s.strstart++,
                        s.lookahead--
                }
                return s.match_available && (bflush = _tr_tally(s, 0, s.window[s.strstart - 1]),
                s.match_available = 0),
                s.insert = s.strstart < 2 ? s.strstart : 2,
                flush === Z_FINISH ? (flush_block_only(s, !0),
                0 === s.strm.avail_out ? 3 : 4) : s.sym_next && (flush_block_only(s, !1),
                0 === s.strm.avail_out) ? 1 : 2
            }
            ;
            function Config(good_length, max_lazy, nice_length, max_chain, func) {
                this.good_length = good_length,
                this.max_lazy = max_lazy,
                this.nice_length = nice_length,
                this.max_chain = max_chain,
                this.func = func
            }
            const configuration_table = [new Config(0,0,0,0,deflate_stored), new Config(4,4,8,4,deflate_fast), new Config(4,5,16,8,deflate_fast), new Config(4,6,32,32,deflate_fast), new Config(4,4,16,16,deflate_slow), new Config(8,16,32,32,deflate_slow), new Config(8,16,128,128,deflate_slow), new Config(8,32,128,256,deflate_slow), new Config(32,128,258,1024,deflate_slow), new Config(32,258,258,4096,deflate_slow)];
            function DeflateState() {
                this.strm = null,
                this.status = 0,
                this.pending_buf = null,
                this.pending_buf_size = 0,
                this.pending_out = 0,
                this.pending = 0,
                this.wrap = 0,
                this.gzhead = null,
                this.gzindex = 0,
                this.method = Z_DEFLATED,
                this.last_flush = -1,
                this.w_size = 0,
                this.w_bits = 0,
                this.w_mask = 0,
                this.window = null,
                this.window_size = 0,
                this.prev = null,
                this.head = null,
                this.ins_h = 0,
                this.hash_size = 0,
                this.hash_bits = 0,
                this.hash_mask = 0,
                this.hash_shift = 0,
                this.block_start = 0,
                this.match_length = 0,
                this.prev_match = 0,
                this.match_available = 0,
                this.strstart = 0,
                this.match_start = 0,
                this.lookahead = 0,
                this.prev_length = 0,
                this.max_chain_length = 0,
                this.max_lazy_match = 0,
                this.level = 0,
                this.strategy = 0,
                this.good_match = 0,
                this.nice_match = 0,
                this.dyn_ltree = new Uint16Array(1146),
                this.dyn_dtree = new Uint16Array(122),
                this.bl_tree = new Uint16Array(78),
                zero(this.dyn_ltree),
                zero(this.dyn_dtree),
                zero(this.bl_tree),
                this.l_desc = null,
                this.d_desc = null,
                this.bl_desc = null,
                this.bl_count = new Uint16Array(16),
                this.heap = new Uint16Array(573),
                zero(this.heap),
                this.heap_len = 0,
                this.heap_max = 0,
                this.depth = new Uint16Array(573),
                zero(this.depth),
                this.sym_buf = 0,
                this.lit_bufsize = 0,
                this.sym_next = 0,
                this.sym_end = 0,
                this.opt_len = 0,
                this.static_len = 0,
                this.matches = 0,
                this.insert = 0,
                this.bi_buf = 0,
                this.bi_valid = 0
            }
            const deflateStateCheck = strm=>{
                if (!strm)
                    return 1;
                const s = strm.state;
                return !s || s.strm !== strm || 42 !== s.status && 57 !== s.status && 69 !== s.status && 73 !== s.status && 91 !== s.status && 103 !== s.status && 113 !== s.status && 666 !== s.status ? 1 : 0
            }
              , deflateResetKeep = strm=>{
                if (deflateStateCheck(strm))
                    return err(strm, Z_STREAM_ERROR);
                strm.total_in = strm.total_out = 0,
                strm.data_type = Z_UNKNOWN;
                const s = strm.state;
                return s.pending = 0,
                s.pending_out = 0,
                s.wrap < 0 && (s.wrap = -s.wrap),
                s.status = 2 === s.wrap ? 57 : s.wrap ? 42 : 113,
                strm.adler = 2 === s.wrap ? 0 : 1,
                s.last_flush = -2,
                _tr_init(s),
                Z_OK
            }
              , deflateReset = strm=>{
                const ret = deflateResetKeep(strm);
                var s;
                return ret === Z_OK && ((s = strm.state).window_size = 2 * s.w_size,
                zero(s.head),
                s.max_lazy_match = configuration_table[s.level].max_lazy,
                s.good_match = configuration_table[s.level].good_length,
                s.nice_match = configuration_table[s.level].nice_length,
                s.max_chain_length = configuration_table[s.level].max_chain,
                s.strstart = 0,
                s.block_start = 0,
                s.lookahead = 0,
                s.insert = 0,
                s.match_length = s.prev_length = 2,
                s.match_available = 0,
                s.ins_h = 0),
                ret
            }
              , deflateInit2 = (strm,level,method,windowBits,memLevel,strategy)=>{
                if (!strm)
                    return Z_STREAM_ERROR;
                let wrap = 1;
                if (level === Z_DEFAULT_COMPRESSION && (level = 6),
                windowBits < 0 ? (wrap = 0,
                windowBits = -windowBits) : windowBits > 15 && (wrap = 2,
                windowBits -= 16),
                memLevel < 1 || memLevel > 9 || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || 8 === windowBits && 1 !== wrap)
                    return err(strm, Z_STREAM_ERROR);
                8 === windowBits && (windowBits = 9);
                const s = new DeflateState;
                return strm.state = s,
                s.strm = strm,
                s.status = 42,
                s.wrap = wrap,
                s.gzhead = null,
                s.w_bits = windowBits,
                s.w_size = 1 << s.w_bits,
                s.w_mask = s.w_size - 1,
                s.hash_bits = memLevel + 7,
                s.hash_size = 1 << s.hash_bits,
                s.hash_mask = s.hash_size - 1,
                s.hash_shift = ~~((s.hash_bits + 3 - 1) / 3),
                s.window = new Uint8Array(2 * s.w_size),
                s.head = new Uint16Array(s.hash_size),
                s.prev = new Uint16Array(s.w_size),
                s.lit_bufsize = 1 << memLevel + 6,
                s.pending_buf_size = 4 * s.lit_bufsize,
                s.pending_buf = new Uint8Array(s.pending_buf_size),
                s.sym_buf = s.lit_bufsize,
                s.sym_end = 3 * (s.lit_bufsize - 1),
                s.level = level,
                s.strategy = strategy,
                s.method = method,
                deflateReset(strm)
            }
            ;
            module.exports.deflateInit = (strm,level)=>deflateInit2(strm, level, Z_DEFLATED, 15, 8, Z_DEFAULT_STRATEGY),
            module.exports.deflateInit2 = deflateInit2,
            module.exports.deflateReset = deflateReset,
            module.exports.deflateResetKeep = deflateResetKeep,
            module.exports.deflateSetHeader = (strm,head)=>deflateStateCheck(strm) || 2 !== strm.state.wrap ? Z_STREAM_ERROR : (strm.state.gzhead = head,
            Z_OK),
            module.exports.deflate = (strm,flush)=>{
                if (deflateStateCheck(strm) || flush > Z_BLOCK || flush < 0)
                    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
                const s = strm.state;
                if (!strm.output || 0 !== strm.avail_in && !strm.input || 666 === s.status && flush !== Z_FINISH)
                    return err(strm, 0 === strm.avail_out ? Z_BUF_ERROR : Z_STREAM_ERROR);
                const old_flush = s.last_flush;
                if (s.last_flush = flush,
                0 !== s.pending) {
                    if (flush_pending(strm),
                    0 === strm.avail_out)
                        return s.last_flush = -1,
                        Z_OK
                } else if (0 === strm.avail_in && rank(flush) <= rank(old_flush) && flush !== Z_FINISH)
                    return err(strm, Z_BUF_ERROR);
                if (666 === s.status && 0 !== strm.avail_in)
                    return err(strm, Z_BUF_ERROR);
                if (42 === s.status && 0 === s.wrap && (s.status = 113),
                42 === s.status) {
                    let header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8
                      , level_flags = -1;
                    if (level_flags = s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 0 : s.level < 6 ? 1 : 6 === s.level ? 2 : 3,
                    header |= level_flags << 6,
                    0 !== s.strstart && (header |= 32),
                    header += 31 - header % 31,
                    putShortMSB(s, header),
                    0 !== s.strstart && (putShortMSB(s, strm.adler >>> 16),
                    putShortMSB(s, 65535 & strm.adler)),
                    strm.adler = 1,
                    s.status = 113,
                    flush_pending(strm),
                    0 !== s.pending)
                        return s.last_flush = -1,
                        Z_OK
                }
                if (57 === s.status)
                    if (strm.adler = 0,
                    put_byte(s, 31),
                    put_byte(s, 139),
                    put_byte(s, 8),
                    s.gzhead)
                        put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (s.gzhead.extra ? 4 : 0) + (s.gzhead.name ? 8 : 0) + (s.gzhead.comment ? 16 : 0)),
                        put_byte(s, 255 & s.gzhead.time),
                        put_byte(s, s.gzhead.time >> 8 & 255),
                        put_byte(s, s.gzhead.time >> 16 & 255),
                        put_byte(s, s.gzhead.time >> 24 & 255),
                        put_byte(s, 9 === s.level ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0),
                        put_byte(s, 255 & s.gzhead.os),
                        s.gzhead.extra && s.gzhead.extra.length && (put_byte(s, 255 & s.gzhead.extra.length),
                        put_byte(s, s.gzhead.extra.length >> 8 & 255)),
                        s.gzhead.hcrc && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0)),
                        s.gzindex = 0,
                        s.status = 69;
                    else if (put_byte(s, 0),
                    put_byte(s, 0),
                    put_byte(s, 0),
                    put_byte(s, 0),
                    put_byte(s, 0),
                    put_byte(s, 9 === s.level ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0),
                    put_byte(s, 3),
                    s.status = 113,
                    flush_pending(strm),
                    0 !== s.pending)
                        return s.last_flush = -1,
                        Z_OK;
                if (69 === s.status) {
                    if (s.gzhead.extra) {
                        let beg = s.pending
                          , left = (65535 & s.gzhead.extra.length) - s.gzindex;
                        for (; s.pending + left > s.pending_buf_size; ) {
                            let copy = s.pending_buf_size - s.pending;
                            if (s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending),
                            s.pending = s.pending_buf_size,
                            s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)),
                            s.gzindex += copy,
                            flush_pending(strm),
                            0 !== s.pending)
                                return s.last_flush = -1,
                                Z_OK;
                            beg = 0,
                            left -= copy
                        }
                        let gzhead_extra = new Uint8Array(s.gzhead.extra);
                        s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending),
                        s.pending += left,
                        s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)),
                        s.gzindex = 0
                    }
                    s.status = 73
                }
                if (73 === s.status) {
                    if (s.gzhead.name) {
                        let val, beg = s.pending;
                        do {
                            if (s.pending === s.pending_buf_size) {
                                if (s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)),
                                flush_pending(strm),
                                0 !== s.pending)
                                    return s.last_flush = -1,
                                    Z_OK;
                                beg = 0
                            }
                            val = s.gzindex < s.gzhead.name.length ? 255 & s.gzhead.name.charCodeAt(s.gzindex++) : 0,
                            put_byte(s, val)
                        } while (0 !== val);
                        s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)),
                        s.gzindex = 0
                    }
                    s.status = 91
                }
                if (91 === s.status) {
                    if (s.gzhead.comment) {
                        let val, beg = s.pending;
                        do {
                            if (s.pending === s.pending_buf_size) {
                                if (s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)),
                                flush_pending(strm),
                                0 !== s.pending)
                                    return s.last_flush = -1,
                                    Z_OK;
                                beg = 0
                            }
                            val = s.gzindex < s.gzhead.comment.length ? 255 & s.gzhead.comment.charCodeAt(s.gzindex++) : 0,
                            put_byte(s, val)
                        } while (0 !== val);
                        s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg))
                    }
                    s.status = 103
                }
                if (103 === s.status) {
                    if (s.gzhead.hcrc) {
                        if (s.pending + 2 > s.pending_buf_size && (flush_pending(strm),
                        0 !== s.pending))
                            return s.last_flush = -1,
                            Z_OK;
                        put_byte(s, 255 & strm.adler),
                        put_byte(s, strm.adler >> 8 & 255),
                        strm.adler = 0
                    }
                    if (s.status = 113,
                    flush_pending(strm),
                    0 !== s.pending)
                        return s.last_flush = -1,
                        Z_OK
                }
                if (0 !== strm.avail_in || 0 !== s.lookahead || flush !== Z_NO_FLUSH && 666 !== s.status) {
                    let bstate = 0 === s.level ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? ((s,flush)=>{
                        let bflush;
                        for (; ; ) {
                            if (0 === s.lookahead && (fill_window(s),
                            0 === s.lookahead)) {
                                if (flush === Z_NO_FLUSH)
                                    return 1;
                                break
                            }
                            if (s.match_length = 0,
                            bflush = _tr_tally(s, 0, s.window[s.strstart]),
                            s.lookahead--,
                            s.strstart++,
                            bflush && (flush_block_only(s, !1),
                            0 === s.strm.avail_out))
                                return 1
                        }
                        return s.insert = 0,
                        flush === Z_FINISH ? (flush_block_only(s, !0),
                        0 === s.strm.avail_out ? 3 : 4) : s.sym_next && (flush_block_only(s, !1),
                        0 === s.strm.avail_out) ? 1 : 2
                    }
                    )(s, flush) : s.strategy === Z_RLE ? ((s,flush)=>{
                        let bflush, prev, scan, strend;
                        const _win = s.window;
                        for (; ; ) {
                            if (s.lookahead <= 258) {
                                if (fill_window(s),
                                s.lookahead <= 258 && flush === Z_NO_FLUSH)
                                    return 1;
                                if (0 === s.lookahead)
                                    break
                            }
                            if (s.match_length = 0,
                            s.lookahead >= 3 && s.strstart > 0 && (scan = s.strstart - 1,
                            prev = _win[scan],
                            prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan])) {
                                strend = s.strstart + 258;
                                do {} while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
                                s.match_length = 258 - (strend - scan),
                                s.match_length > s.lookahead && (s.match_length = s.lookahead)
                            }
                            if (s.match_length >= 3 ? (bflush = _tr_tally(s, 1, s.match_length - 3),
                            s.lookahead -= s.match_length,
                            s.strstart += s.match_length,
                            s.match_length = 0) : (bflush = _tr_tally(s, 0, s.window[s.strstart]),
                            s.lookahead--,
                            s.strstart++),
                            bflush && (flush_block_only(s, !1),
                            0 === s.strm.avail_out))
                                return 1
                        }
                        return s.insert = 0,
                        flush === Z_FINISH ? (flush_block_only(s, !0),
                        0 === s.strm.avail_out ? 3 : 4) : s.sym_next && (flush_block_only(s, !1),
                        0 === s.strm.avail_out) ? 1 : 2
                    }
                    )(s, flush) : configuration_table[s.level].func(s, flush);
                    if (3 !== bstate && 4 !== bstate || (s.status = 666),
                    1 === bstate || 3 === bstate)
                        return 0 === strm.avail_out && (s.last_flush = -1),
                        Z_OK;
                    if (2 === bstate && (flush === Z_PARTIAL_FLUSH ? _tr_align(s) : flush !== Z_BLOCK && (_tr_stored_block(s, 0, 0, !1),
                    flush === Z_FULL_FLUSH && (zero(s.head),
                    0 === s.lookahead && (s.strstart = 0,
                    s.block_start = 0,
                    s.insert = 0))),
                    flush_pending(strm),
                    0 === strm.avail_out))
                        return s.last_flush = -1,
                        Z_OK
                }
                return flush !== Z_FINISH ? Z_OK : s.wrap <= 0 ? Z_STREAM_END : (2 === s.wrap ? (put_byte(s, 255 & strm.adler),
                put_byte(s, strm.adler >> 8 & 255),
                put_byte(s, strm.adler >> 16 & 255),
                put_byte(s, strm.adler >> 24 & 255),
                put_byte(s, 255 & strm.total_in),
                put_byte(s, strm.total_in >> 8 & 255),
                put_byte(s, strm.total_in >> 16 & 255),
                put_byte(s, strm.total_in >> 24 & 255)) : (putShortMSB(s, strm.adler >>> 16),
                putShortMSB(s, 65535 & strm.adler)),
                flush_pending(strm),
                s.wrap > 0 && (s.wrap = -s.wrap),
                0 !== s.pending ? Z_OK : Z_STREAM_END)
            }
            ,
            module.exports.deflateEnd = strm=>{
                if (deflateStateCheck(strm))
                    return Z_STREAM_ERROR;
                const status = strm.state.status;
                return strm.state = null,
                113 === status ? err(strm, Z_DATA_ERROR) : Z_OK
            }
            ,
            module.exports.deflateSetDictionary = (strm,dictionary)=>{
                let dictLength = dictionary.length;
                if (deflateStateCheck(strm))
                    return Z_STREAM_ERROR;
                const s = strm.state
                  , wrap = s.wrap;
                if (2 === wrap || 1 === wrap && 42 !== s.status || s.lookahead)
                    return Z_STREAM_ERROR;
                if (1 === wrap && (strm.adler = adler32(strm.adler, dictionary, dictLength, 0)),
                s.wrap = 0,
                dictLength >= s.w_size) {
                    0 === wrap && (zero(s.head),
                    s.strstart = 0,
                    s.block_start = 0,
                    s.insert = 0);
                    let tmpDict = new Uint8Array(s.w_size);
                    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0),
                    dictionary = tmpDict,
                    dictLength = s.w_size
                }
                const avail = strm.avail_in
                  , next = strm.next_in
                  , input = strm.input;
                for (strm.avail_in = dictLength,
                strm.next_in = 0,
                strm.input = dictionary,
                fill_window(s); s.lookahead >= 3; ) {
                    let str = s.strstart
                      , n = s.lookahead - 2;
                    do {
                        s.ins_h = HASH(s, s.ins_h, s.window[str + 3 - 1]),
                        s.prev[str & s.w_mask] = s.head[s.ins_h],
                        s.head[s.ins_h] = str,
                        str++
                    } while (--n);
                    s.strstart = str,
                    s.lookahead = 2,
                    fill_window(s)
                }
                return s.strstart += s.lookahead,
                s.block_start = s.strstart,
                s.insert = s.lookahead,
                s.lookahead = 0,
                s.match_length = s.prev_length = 2,
                s.match_available = 0,
                strm.next_in = next,
                strm.input = input,
                strm.avail_in = avail,
                s.wrap = wrap,
                Z_OK
            }
            ,
            module.exports.deflateInfo = "pako deflate (from Nodeca project)"
        }
        ,
        68524: module=>{
            "use strict";
            module.exports = function() {
                this.text = 0,
                this.time = 0,
                this.xflags = 0,
                this.os = 0,
                this.extra = null,
                this.extra_len = 0,
                this.name = "",
                this.comment = "",
                this.hcrc = 0,
                this.done = !1
            }
        }
        ,
        79338: module=>{
            "use strict";
            module.exports = function(strm, start) {
                let _in, last, _out, beg, end, dmax, wsize, whave, wnext, s_window, hold, bits, lcode, dcode, lmask, dmask, here, op, len, dist, from, from_source, input, output;
                const state = strm.state;
                _in = strm.next_in,
                input = strm.input,
                last = _in + (strm.avail_in - 5),
                _out = strm.next_out,
                output = strm.output,
                beg = _out - (start - strm.avail_out),
                end = _out + (strm.avail_out - 257),
                dmax = state.dmax,
                wsize = state.wsize,
                whave = state.whave,
                wnext = state.wnext,
                s_window = state.window,
                hold = state.hold,
                bits = state.bits,
                lcode = state.lencode,
                dcode = state.distcode,
                lmask = (1 << state.lenbits) - 1,
                dmask = (1 << state.distbits) - 1;
                top: do {
                    bits < 15 && (hold += input[_in++] << bits,
                    bits += 8,
                    hold += input[_in++] << bits,
                    bits += 8),
                    here = lcode[hold & lmask];
                    dolen: for (; ; ) {
                        if (op = here >>> 24,
                        hold >>>= op,
                        bits -= op,
                        op = here >>> 16 & 255,
                        0 === op)
                            output[_out++] = 65535 & here;
                        else {
                            if (!(16 & op)) {
                                if (0 == (64 & op)) {
                                    here = lcode[(65535 & here) + (hold & (1 << op) - 1)];
                                    continue dolen
                                }
                                if (32 & op) {
                                    state.mode = 16191;
                                    break top
                                }
                                strm.msg = "invalid literal/length code",
                                state.mode = 16209;
                                break top
                            }
                            len = 65535 & here,
                            op &= 15,
                            op && (bits < op && (hold += input[_in++] << bits,
                            bits += 8),
                            len += hold & (1 << op) - 1,
                            hold >>>= op,
                            bits -= op),
                            bits < 15 && (hold += input[_in++] << bits,
                            bits += 8,
                            hold += input[_in++] << bits,
                            bits += 8),
                            here = dcode[hold & dmask];
                            dodist: for (; ; ) {
                                if (op = here >>> 24,
                                hold >>>= op,
                                bits -= op,
                                op = here >>> 16 & 255,
                                !(16 & op)) {
                                    if (0 == (64 & op)) {
                                        here = dcode[(65535 & here) + (hold & (1 << op) - 1)];
                                        continue dodist
                                    }
                                    strm.msg = "invalid distance code",
                                    state.mode = 16209;
                                    break top
                                }
                                if (dist = 65535 & here,
                                op &= 15,
                                bits < op && (hold += input[_in++] << bits,
                                bits += 8,
                                bits < op && (hold += input[_in++] << bits,
                                bits += 8)),
                                dist += hold & (1 << op) - 1,
                                dist > dmax) {
                                    strm.msg = "invalid distance too far back",
                                    state.mode = 16209;
                                    break top
                                }
                                if (hold >>>= op,
                                bits -= op,
                                op = _out - beg,
                                dist > op) {
                                    if (op = dist - op,
                                    op > whave && state.sane) {
                                        strm.msg = "invalid distance too far back",
                                        state.mode = 16209;
                                        break top
                                    }
                                    if (from = 0,
                                    from_source = s_window,
                                    0 === wnext) {
                                        if (from += wsize - op,
                                        op < len) {
                                            len -= op;
                                            do {
                                                output[_out++] = s_window[from++]
                                            } while (--op);
                                            from = _out - dist,
                                            from_source = output
                                        }
                                    } else if (wnext < op) {
                                        if (from += wsize + wnext - op,
                                        op -= wnext,
                                        op < len) {
                                            len -= op;
                                            do {
                                                output[_out++] = s_window[from++]
                                            } while (--op);
                                            if (from = 0,
                                            wnext < len) {
                                                op = wnext,
                                                len -= op;
                                                do {
                                                    output[_out++] = s_window[from++]
                                                } while (--op);
                                                from = _out - dist,
                                                from_source = output
                                            }
                                        }
                                    } else if (from += wnext - op,
                                    op < len) {
                                        len -= op;
                                        do {
                                            output[_out++] = s_window[from++]
                                        } while (--op);
                                        from = _out - dist,
                                        from_source = output
                                    }
                                    for (; len > 2; )
                                        output[_out++] = from_source[from++],
                                        output[_out++] = from_source[from++],
                                        output[_out++] = from_source[from++],
                                        len -= 3;
                                    len && (output[_out++] = from_source[from++],
                                    len > 1 && (output[_out++] = from_source[from++]))
                                } else {
                                    from = _out - dist;
                                    do {
                                        output[_out++] = output[from++],
                                        output[_out++] = output[from++],
                                        output[_out++] = output[from++],
                                        len -= 3
                                    } while (len > 2);
                                    len && (output[_out++] = output[from++],
                                    len > 1 && (output[_out++] = output[from++]))
                                }
                                break
                            }
                        }
                        break
                    }
                } while (_in < last && _out < end);
                len = bits >> 3,
                _in -= len,
                bits -= len << 3,
                hold &= (1 << bits) - 1,
                strm.next_in = _in,
                strm.next_out = _out,
                strm.avail_in = _in < last ? last - _in + 5 : 5 - (_in - last),
                strm.avail_out = _out < end ? end - _out + 257 : 257 - (_out - end),
                state.hold = hold,
                state.bits = bits
            }
        }
        ,
        39823: (module,__unused_webpack_exports,__webpack_require__)=>{
            "use strict";
            const adler32 = __webpack_require__(94541)
              , crc32 = __webpack_require__(84270)
              , inflate_fast = __webpack_require__(79338)
              , inflate_table = __webpack_require__(63645)
              , {Z_FINISH, Z_BLOCK, Z_TREES, Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR, Z_BUF_ERROR, Z_DEFLATED} = __webpack_require__(13991)
              , BAD = 16209
              , zswap32 = q=>(q >>> 24 & 255) + (q >>> 8 & 65280) + ((65280 & q) << 8) + ((255 & q) << 24);
            function InflateState() {
                this.strm = null,
                this.mode = 0,
                this.last = !1,
                this.wrap = 0,
                this.havedict = !1,
                this.flags = 0,
                this.dmax = 0,
                this.check = 0,
                this.total = 0,
                this.head = null,
                this.wbits = 0,
                this.wsize = 0,
                this.whave = 0,
                this.wnext = 0,
                this.window = null,
                this.hold = 0,
                this.bits = 0,
                this.length = 0,
                this.offset = 0,
                this.extra = 0,
                this.lencode = null,
                this.distcode = null,
                this.lenbits = 0,
                this.distbits = 0,
                this.ncode = 0,
                this.nlen = 0,
                this.ndist = 0,
                this.have = 0,
                this.next = null,
                this.lens = new Uint16Array(320),
                this.work = new Uint16Array(288),
                this.lendyn = null,
                this.distdyn = null,
                this.sane = 0,
                this.back = 0,
                this.was = 0
            }
            const inflateStateCheck = strm=>{
                if (!strm)
                    return 1;
                const state = strm.state;
                return !state || state.strm !== strm || state.mode < 16180 || state.mode > 16211 ? 1 : 0
            }
              , inflateResetKeep = strm=>{
                if (inflateStateCheck(strm))
                    return Z_STREAM_ERROR;
                const state = strm.state;
                return strm.total_in = strm.total_out = state.total = 0,
                strm.msg = "",
                state.wrap && (strm.adler = 1 & state.wrap),
                state.mode = 16180,
                state.last = 0,
                state.havedict = 0,
                state.flags = -1,
                state.dmax = 32768,
                state.head = null,
                state.hold = 0,
                state.bits = 0,
                state.lencode = state.lendyn = new Int32Array(852),
                state.distcode = state.distdyn = new Int32Array(592),
                state.sane = 1,
                state.back = -1,
                Z_OK
            }
              , inflateReset = strm=>{
                if (inflateStateCheck(strm))
                    return Z_STREAM_ERROR;
                const state = strm.state;
                return state.wsize = 0,
                state.whave = 0,
                state.wnext = 0,
                inflateResetKeep(strm)
            }
              , inflateReset2 = (strm,windowBits)=>{
                let wrap;
                if (inflateStateCheck(strm))
                    return Z_STREAM_ERROR;
                const state = strm.state;
                return windowBits < 0 ? (wrap = 0,
                windowBits = -windowBits) : (wrap = 5 + (windowBits >> 4),
                windowBits < 48 && (windowBits &= 15)),
                windowBits && (windowBits < 8 || windowBits > 15) ? Z_STREAM_ERROR : (null !== state.window && state.wbits !== windowBits && (state.window = null),
                state.wrap = wrap,
                state.wbits = windowBits,
                inflateReset(strm))
            }
              , inflateInit2 = (strm,windowBits)=>{
                if (!strm)
                    return Z_STREAM_ERROR;
                const state = new InflateState;
                strm.state = state,
                state.strm = strm,
                state.window = null,
                state.mode = 16180;
                const ret = inflateReset2(strm, windowBits);
                return ret !== Z_OK && (strm.state = null),
                ret
            }
            ;
            let lenfix, distfix, virgin = !0;
            const fixedtables = state=>{
                if (virgin) {
                    lenfix = new Int32Array(512),
                    distfix = new Int32Array(32);
                    let sym = 0;
                    for (; sym < 144; )
                        state.lens[sym++] = 8;
                    for (; sym < 256; )
                        state.lens[sym++] = 9;
                    for (; sym < 280; )
                        state.lens[sym++] = 7;
                    for (; sym < 288; )
                        state.lens[sym++] = 8;
                    for (inflate_table(1, state.lens, 0, 288, lenfix, 0, state.work, {
                        bits: 9
                    }),
                    sym = 0; sym < 32; )
                        state.lens[sym++] = 5;
                    inflate_table(2, state.lens, 0, 32, distfix, 0, state.work, {
                        bits: 5
                    }),
                    virgin = !1
                }
                state.lencode = lenfix,
                state.lenbits = 9,
                state.distcode = distfix,
                state.distbits = 5
            }
              , updatewindow = (strm,src,end,copy)=>{
                let dist;
                const state = strm.state;
                return null === state.window && (state.wsize = 1 << state.wbits,
                state.wnext = 0,
                state.whave = 0,
                state.window = new Uint8Array(state.wsize)),
                copy >= state.wsize ? (state.window.set(src.subarray(end - state.wsize, end), 0),
                state.wnext = 0,
                state.whave = state.wsize) : (dist = state.wsize - state.wnext,
                dist > copy && (dist = copy),
                state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext),
                (copy -= dist) ? (state.window.set(src.subarray(end - copy, end), 0),
                state.wnext = copy,
                state.whave = state.wsize) : (state.wnext += dist,
                state.wnext === state.wsize && (state.wnext = 0),
                state.whave < state.wsize && (state.whave += dist))),
                0
            }
            ;
            module.exports.inflateReset = inflateReset,
            module.exports.inflateReset2 = inflateReset2,
            module.exports.inflateResetKeep = inflateResetKeep,
            module.exports.inflateInit = strm=>inflateInit2(strm, 15),
            module.exports.inflateInit2 = inflateInit2,
            module.exports.inflate = (strm,flush)=>{
                let state, input, output, next, put, have, left, hold, bits, _in, _out, copy, from, from_source, here_bits, here_op, here_val, last_bits, last_op, last_val, len, ret, here = 0;
                const hbuf = new Uint8Array(4);
                let opts, n;
                const order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
                if (inflateStateCheck(strm) || !strm.output || !strm.input && 0 !== strm.avail_in)
                    return Z_STREAM_ERROR;
                state = strm.state,
                16191 === state.mode && (state.mode = 16192),
                put = strm.next_out,
                output = strm.output,
                left = strm.avail_out,
                next = strm.next_in,
                input = strm.input,
                have = strm.avail_in,
                hold = state.hold,
                bits = state.bits,
                _in = have,
                _out = left,
                ret = Z_OK;
                inf_leave: for (; ; )
                    switch (state.mode) {
                    case 16180:
                        if (0 === state.wrap) {
                            state.mode = 16192;
                            break
                        }
                        for (; bits < 16; ) {
                            if (0 === have)
                                break inf_leave;
                            have--,
                            hold += input[next++] << bits,
                            bits += 8
                        }
                        if (2 & state.wrap && 35615 === hold) {
                            0 === state.wbits && (state.wbits = 15),
                            state.check = 0,
                            hbuf[0] = 255 & hold,
                            hbuf[1] = hold >>> 8 & 255,
                            state.check = crc32(state.check, hbuf, 2, 0),
                            hold = 0,
                            bits = 0,
                            state.mode = 16181;
                            break
                        }
                        if (state.head && (state.head.done = !1),
                        !(1 & state.wrap) || (((255 & hold) << 8) + (hold >> 8)) % 31) {
                            strm.msg = "incorrect header check",
                            state.mode = BAD;
                            break
                        }
                        if ((15 & hold) !== Z_DEFLATED) {
                            strm.msg = "unknown compression method",
                            state.mode = BAD;
                            break
                        }
                        if (hold >>>= 4,
                        bits -= 4,
                        len = 8 + (15 & hold),
                        0 === state.wbits && (state.wbits = len),
                        len > 15 || len > state.wbits) {
                            strm.msg = "invalid window size",
                            state.mode = BAD;
                            break
                        }
                        state.dmax = 1 << state.wbits,
                        state.flags = 0,
                        strm.adler = state.check = 1,
                        state.mode = 512 & hold ? 16189 : 16191,
                        hold = 0,
                        bits = 0;
                        break;
                    case 16181:
                        for (; bits < 16; ) {
                            if (0 === have)
                                break inf_leave;
                            have--,
                            hold += input[next++] << bits,
                            bits += 8
                        }
                        if (state.flags = hold,
                        (255 & state.flags) !== Z_DEFLATED) {
                            strm.msg = "unknown compression method",
                            state.mode = BAD;
                            break
                        }
                        if (57344 & state.flags) {
                            strm.msg = "unknown header flags set",
                            state.mode = BAD;
                            break
                        }
                        state.head && (state.head.text = hold >> 8 & 1),
                        512 & state.flags && 4 & state.wrap && (hbuf[0] = 255 & hold,
                        hbuf[1] = hold >>> 8 & 255,
                        state.check = crc32(state.check, hbuf, 2, 0)),
                        hold = 0,
                        bits = 0,
                        state.mode = 16182;
                    case 16182:
                        for (; bits < 32; ) {
                            if (0 === have)
                                break inf_leave;
                            have--,
                            hold += input[next++] << bits,
                            bits += 8
                        }
                        state.head && (state.head.time = hold),
                        512 & state.flags && 4 & state.wrap && (hbuf[0] = 255 & hold,
                        hbuf[1] = hold >>> 8 & 255,
                        hbuf[2] = hold >>> 16 & 255,
                        hbuf[3] = hold >>> 24 & 255,
                        state.check = crc32(state.check, hbuf, 4, 0)),
                        hold = 0,
                        bits = 0,
                        state.mode = 16183;
                    case 16183:
                        for (; bits < 16; ) {
                            if (0 === have)
                                break inf_leave;
                            have--,
                            hold += input[next++] << bits,
                            bits += 8
                        }
                        state.head && (state.head.xflags = 255 & hold,
                        state.head.os = hold >> 8),
                        512 & state.flags && 4 & state.wrap && (hbuf[0] = 255 & hold,
                        hbuf[1] = hold >>> 8 & 255,
                        state.check = crc32(state.check, hbuf, 2, 0)),
                        hold = 0,
                        bits = 0,
                        state.mode = 16184;
                    case 16184:
                        if (1024 & state.flags) {
                            for (; bits < 16; ) {
                                if (0 === have)
                                    break inf_leave;
                                have--,
                                hold += input[next++] << bits,
                                bits += 8
                            }
                            state.length = hold,
                            state.head && (state.head.extra_len = hold),
                            512 & state.flags && 4 & state.wrap && (hbuf[0] = 255 & hold,
                            hbuf[1] = hold >>> 8 & 255,
                            state.check = crc32(state.check, hbuf, 2, 0)),
                            hold = 0,
                            bits = 0
                        } else
                            state.head && (state.head.extra = null);
                        state.mode = 16185;
                    case 16185:
                        if (1024 & state.flags && (copy = state.length,
                        copy > have && (copy = have),
                        copy && (state.head && (len = state.head.extra_len - state.length,
                        state.head.extra || (state.head.extra = new Uint8Array(state.head.extra_len)),
                        state.head.extra.set(input.subarray(next, next + copy), len)),
                        512 & state.flags && 4 & state.wrap && (state.check = crc32(state.check, input, copy, next)),
                        have -= copy,
                        next += copy,
                        state.length -= copy),
                        state.length))
                            break inf_leave;
                        state.length = 0,
                        state.mode = 16186;
                    case 16186:
                        if (2048 & state.flags) {
                            if (0 === have)
                                break inf_leave;
                            copy = 0;
                            do {
                                len = input[next + copy++],
                                state.head && len && state.length < 65536 && (state.head.name += String.fromCharCode(len))
                            } while (len && copy < have);
                            if (512 & state.flags && 4 & state.wrap && (state.check = crc32(state.check, input, copy, next)),
                            have -= copy,
                            next += copy,
                            len)
                                break inf_leave
                        } else
                            state.head && (state.head.name = null);
                        state.length = 0,
                        state.mode = 16187;
                    case 16187:
                        if (4096 & state.flags) {
                            if (0 === have)
                                break inf_leave;
                            copy = 0;
                            do {
                                len = input[next + copy++],
                                state.head && len && state.length < 65536 && (state.head.comment += String.fromCharCode(len))
                            } while (len && copy < have);
                            if (512 & state.flags && 4 & state.wrap && (state.check = crc32(state.check, input, copy, next)),
                            have -= copy,
                            next += copy,
                            len)
                                break inf_leave
                        } else
                            state.head && (state.head.comment = null);
                        state.mode = 16188;
                    case 16188:
                        if (512 & state.flags) {
                            for (; bits < 16; ) {
                                if (0 === have)
                                    break inf_leave;
                                have--,
                                hold += input[next++] << bits,
                                bits += 8
                            }
                            if (4 & state.wrap && hold !== (65535 & state.check)) {
                                strm.msg = "header crc mismatch",
                                state.mode = BAD;
                                break
                            }
                            hold = 0,
                            bits = 0
                        }
                        state.head && (state.head.hcrc = state.flags >> 9 & 1,
                        state.head.done = !0),
                        strm.adler = state.check = 0,
                        state.mode = 16191;
                        break;
                    case 16189:
                        for (; bits < 32; ) {
                            if (0 === have)
                                break inf_leave;
                            have--,
                            hold += input[next++] << bits,
                            bits += 8
                        }
                        strm.adler = state.check = zswap32(hold),
                        hold = 0,
                        bits = 0,
                        state.mode = 16190;
                    case 16190:
                        if (0 === state.havedict)
                            return strm.next_out = put,
                            strm.avail_out = left,
                            strm.next_in = next,
                            strm.avail_in = have,
                            state.hold = hold,
                            state.bits = bits,
                            Z_NEED_DICT;
                        strm.adler = state.check = 1,
                        state.mode = 16191;
                    case 16191:
                        if (flush === Z_BLOCK || flush === Z_TREES)
                            break inf_leave;
                    case 16192:
                        if (state.last) {
                            hold >>>= 7 & bits,
                            bits -= 7 & bits,
                            state.mode = 16206;
                            break
                        }
                        for (; bits < 3; ) {
                            if (0 === have)
                                break inf_leave;
                            have--,
                            hold += input[next++] << bits,
                            bits += 8
                        }
                        switch (state.last = 1 & hold,
                        hold >>>= 1,
                        bits -= 1,
                        3 & hold) {
                        case 0:
                            state.mode = 16193;
                            break;
                        case 1:
                            if (fixedtables(state),
                            state.mode = 16199,
                            flush === Z_TREES) {
                                hold >>>= 2,
                                bits -= 2;
                                break inf_leave
                            }
                            break;
                        case 2:
                            state.mode = 16196;
                            break;
                        case 3:
                            strm.msg = "invalid block type",
                            state.mode = BAD
                        }
                        hold >>>= 2,
                        bits -= 2;
                        break;
                    case 16193:
                        for (hold >>>= 7 & bits,
                        bits -= 7 & bits; bits < 32; ) {
                            if (0 === have)
                                break inf_leave;
                            have--,
                            hold += input[next++] << bits,
                            bits += 8
                        }
                        if ((65535 & hold) != (hold >>> 16 ^ 65535)) {
                            strm.msg = "invalid stored block lengths",
                            state.mode = BAD;
                            break
                        }
                        if (state.length = 65535 & hold,
                        hold = 0,
                        bits = 0,
                        state.mode = 16194,
                        flush === Z_TREES)
                            break inf_leave;
                    case 16194:
                        state.mode = 16195;
                    case 16195:
                        if (copy = state.length,
                        copy) {
                            if (copy > have && (copy = have),
                            copy > left && (copy = left),
                            0 === copy)
                                break inf_leave;
                            output.set(input.subarray(next, next + copy), put),
                            have -= copy,
                            next += copy,
                            left -= copy,
                            put += copy,
                            state.length -= copy;
                            break
                        }
                        state.mode = 16191;
                        break;
                    case 16196:
                        for (; bits < 14; ) {
                            if (0 === have)
                                break inf_leave;
                            have--,
                            hold += input[next++] << bits,
                            bits += 8
                        }
                        if (state.nlen = 257 + (31 & hold),
                        hold >>>= 5,
                        bits -= 5,
                        state.ndist = 1 + (31 & hold),
                        hold >>>= 5,
                        bits -= 5,
                        state.ncode = 4 + (15 & hold),
                        hold >>>= 4,
                        bits -= 4,
                        state.nlen > 286 || state.ndist > 30) {
                            strm.msg = "too many length or distance symbols",
                            state.mode = BAD;
                            break
                        }
                        state.have = 0,
                        state.mode = 16197;
                    case 16197:
                        for (; state.have < state.ncode; ) {
                            for (; bits < 3; ) {
                                if (0 === have)
                                    break inf_leave;
                                have--,
                                hold += input[next++] << bits,
                                bits += 8
                            }
                            state.lens[order[state.have++]] = 7 & hold,
                            hold >>>= 3,
                            bits -= 3
                        }
                        for (; state.have < 19; )
                            state.lens[order[state.have++]] = 0;
                        if (state.lencode = state.lendyn,
                        state.lenbits = 7,
                        opts = {
                            bits: state.lenbits
                        },
                        ret = inflate_table(0, state.lens, 0, 19, state.lencode, 0, state.work, opts),
                        state.lenbits = opts.bits,
                        ret) {
                            strm.msg = "invalid code lengths set",
                            state.mode = BAD;
                            break
                        }
                        state.have = 0,
                        state.mode = 16198;
                    case 16198:
                        for (; state.have < state.nlen + state.ndist; ) {
                            for (; here = state.lencode[hold & (1 << state.lenbits) - 1],
                            here_bits = here >>> 24,
                            here_op = here >>> 16 & 255,
                            here_val = 65535 & here,
                            !(here_bits <= bits); ) {
                                if (0 === have)
                                    break inf_leave;
                                have--,
                                hold += input[next++] << bits,
                                bits += 8
                            }
                            if (here_val < 16)
                                hold >>>= here_bits,
                                bits -= here_bits,
                                state.lens[state.have++] = here_val;
                            else {
                                if (16 === here_val) {
                                    for (n = here_bits + 2; bits < n; ) {
                                        if (0 === have)
                                            break inf_leave;
                                        have--,
                                        hold += input[next++] << bits,
                                        bits += 8
                                    }
                                    if (hold >>>= here_bits,
                                    bits -= here_bits,
                                    0 === state.have) {
                                        strm.msg = "invalid bit length repeat",
                                        state.mode = BAD;
                                        break
                                    }
                                    len = state.lens[state.have - 1],
                                    copy = 3 + (3 & hold),
                                    hold >>>= 2,
                                    bits -= 2
                                } else if (17 === here_val) {
                                    for (n = here_bits + 3; bits < n; ) {
                                        if (0 === have)
                                            break inf_leave;
                                        have--,
                                        hold += input[next++] << bits,
                                        bits += 8
                                    }
                                    hold >>>= here_bits,
                                    bits -= here_bits,
                                    len = 0,
                                    copy = 3 + (7 & hold),
                                    hold >>>= 3,
                                    bits -= 3
                                } else {
                                    for (n = here_bits + 7; bits < n; ) {
                                        if (0 === have)
                                            break inf_leave;
                                        have--,
                                        hold += input[next++] << bits,
                                        bits += 8
                                    }
                                    hold >>>= here_bits,
                                    bits -= here_bits,
                                    len = 0,
                                    copy = 11 + (127 & hold),
                                    hold >>>= 7,
                                    bits -= 7
                                }
                                if (state.have + copy > state.nlen + state.ndist) {
                                    strm.msg = "invalid bit length repeat",
                                    state.mode = BAD;
                                    break
                                }
                                for (; copy--; )
                                    state.lens[state.have++] = len
                            }
                        }
                        if (state.mode === BAD)
                            break;
                        if (0 === state.lens[256]) {
                            strm.msg = "invalid code -- missing end-of-block",
                            state.mode = BAD;
                            break
                        }
                        if (state.lenbits = 9,
                        opts = {
                            bits: state.lenbits
                        },
                        ret = inflate_table(1, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts),
                        state.lenbits = opts.bits,
                        ret) {
                            strm.msg = "invalid literal/lengths set",
                            state.mode = BAD;
                            break
                        }
                        if (state.distbits = 6,
                        state.distcode = state.distdyn,
                        opts = {
                            bits: state.distbits
                        },
                        ret = inflate_table(2, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts),
                        state.distbits = opts.bits,
                        ret) {
                            strm.msg = "invalid distances set",
                            state.mode = BAD;
                            break
                        }
                        if (state.mode = 16199,
                        flush === Z_TREES)
                            break inf_leave;
                    case 16199:
                        state.mode = 16200;
                    case 16200:
                        if (have >= 6 && left >= 258) {
                            strm.next_out = put,
                            strm.avail_out = left,
                            strm.next_in = next,
                            strm.avail_in = have,
                            state.hold = hold,
                            state.bits = bits,
                            inflate_fast(strm, _out),
                            put = strm.next_out,
                            output = strm.output,
                            left = strm.avail_out,
                            next = strm.next_in,
                            input = strm.input,
                            have = strm.avail_in,
                            hold = state.hold,
                            bits = state.bits,
                            16191 === state.mode && (state.back = -1);
                            break
                        }
                        for (state.back = 0; here = state.lencode[hold & (1 << state.lenbits) - 1],
                        here_bits = here >>> 24,
                        here_op = here >>> 16 & 255,
                        here_val = 65535 & here,
                        !(here_bits <= bits); ) {
                            if (0 === have)
                                break inf_leave;
                            have--,
                            hold += input[next++] << bits,
                            bits += 8
                        }
                        if (here_op && 0 == (240 & here_op)) {
                            for (last_bits = here_bits,
                            last_op = here_op,
                            last_val = here_val; here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)],
                            here_bits = here >>> 24,
                            here_op = here >>> 16 & 255,
                            here_val = 65535 & here,
                            !(last_bits + here_bits <= bits); ) {
                                if (0 === have)
                                    break inf_leave;
                                have--,
                                hold += input[next++] << bits,
                                bits += 8
                            }
                            hold >>>= last_bits,
                            bits -= last_bits,
                            state.back += last_bits
                        }
                        if (hold >>>= here_bits,
                        bits -= here_bits,
                        state.back += here_bits,
                        state.length = here_val,
                        0 === here_op) {
                            state.mode = 16205;
                            break
                        }
                        if (32 & here_op) {
                            state.back = -1,
                            state.mode = 16191;
                            break
                        }
                        if (64 & here_op) {
                            strm.msg = "invalid literal/length code",
                            state.mode = BAD;
                            break
                        }
                        state.extra = 15 & here_op,
                        state.mode = 16201;
                    case 16201:
                        if (state.extra) {
                            for (n = state.extra; bits < n; ) {
                                if (0 === have)
                                    break inf_leave;
                                have--,
                                hold += input[next++] << bits,
                                bits += 8
                            }
                            state.length += hold & (1 << state.extra) - 1,
                            hold >>>= state.extra,
                            bits -= state.extra,
                            state.back += state.extra
                        }
                        state.was = state.length,
                        state.mode = 16202;
                    case 16202:
                        for (; here = state.distcode[hold & (1 << state.distbits) - 1],
                        here_bits = here >>> 24,
                        here_op = here >>> 16 & 255,
                        here_val = 65535 & here,
                        !(here_bits <= bits); ) {
                            if (0 === have)
                                break inf_leave;
                            have--,
                            hold += input[next++] << bits,
                            bits += 8
                        }
                        if (0 == (240 & here_op)) {
                            for (last_bits = here_bits,
                            last_op = here_op,
                            last_val = here_val; here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)],
                            here_bits = here >>> 24,
                            here_op = here >>> 16 & 255,
                            here_val = 65535 & here,
                            !(last_bits + here_bits <= bits); ) {
                                if (0 === have)
                                    break inf_leave;
                                have--,
                                hold += input[next++] << bits,
                                bits += 8
                            }
                            hold >>>= last_bits,
                            bits -= last_bits,
                            state.back += last_bits
                        }
                        if (hold >>>= here_bits,
                        bits -= here_bits,
                        state.back += here_bits,
                        64 & here_op) {
                            strm.msg = "invalid distance code",
                            state.mode = BAD;
                            break
                        }
                        state.offset = here_val,
                        state.extra = 15 & here_op,
                        state.mode = 16203;
                    case 16203:
                        if (state.extra) {
                            for (n = state.extra; bits < n; ) {
                                if (0 === have)
                                    break inf_leave;
                                have--,
                                hold += input[next++] << bits,
                                bits += 8
                            }
                            state.offset += hold & (1 << state.extra) - 1,
                            hold >>>= state.extra,
                            bits -= state.extra,
                            state.back += state.extra
                        }
                        if (state.offset > state.dmax) {
                            strm.msg = "invalid distance too far back",
                            state.mode = BAD;
                            break
                        }
                        state.mode = 16204;
                    case 16204:
                        if (0 === left)
                            break inf_leave;
                        if (copy = _out - left,
                        state.offset > copy) {
                            if (copy = state.offset - copy,
                            copy > state.whave && state.sane) {
                                strm.msg = "invalid distance too far back",
                                state.mode = BAD;
                                break
                            }
                            copy > state.wnext ? (copy -= state.wnext,
                            from = state.wsize - copy) : from = state.wnext - copy,
                            copy > state.length && (copy = state.length),
                            from_source = state.window
                        } else
                            from_source = output,
                            from = put - state.offset,
                            copy = state.length;
                        copy > left && (copy = left),
                        left -= copy,
                        state.length -= copy;
                        do {
                            output[put++] = from_source[from++]
                        } while (--copy);
                        0 === state.length && (state.mode = 16200);
                        break;
                    case 16205:
                        if (0 === left)
                            break inf_leave;
                        output[put++] = state.length,
                        left--,
                        state.mode = 16200;
                        break;
                    case 16206:
                        if (state.wrap) {
                            for (; bits < 32; ) {
                                if (0 === have)
                                    break inf_leave;
                                have--,
                                hold |= input[next++] << bits,
                                bits += 8
                            }
                            if (_out -= left,
                            strm.total_out += _out,
                            state.total += _out,
                            4 & state.wrap && _out && (strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out)),
                            _out = left,
                            4 & state.wrap && (state.flags ? hold : zswap32(hold)) !== state.check) {
                                strm.msg = "incorrect data check",
                                state.mode = BAD;
                                break
                            }
                            hold = 0,
                            bits = 0
                        }
                        state.mode = 16207;
                    case 16207:
                        if (state.wrap && state.flags) {
                            for (; bits < 32; ) {
                                if (0 === have)
                                    break inf_leave;
                                have--,
                                hold += input[next++] << bits,
                                bits += 8
                            }
                            if (4 & state.wrap && hold !== (4294967295 & state.total)) {
                                strm.msg = "incorrect length check",
                                state.mode = BAD;
                                break
                            }
                            hold = 0,
                            bits = 0
                        }
                        state.mode = 16208;
                    case 16208:
                        ret = Z_STREAM_END;
                        break inf_leave;
                    case BAD:
                        ret = Z_DATA_ERROR;
                        break inf_leave;
                    case 16210:
                        return Z_MEM_ERROR;
                    default:
                        return Z_STREAM_ERROR
                    }
                return strm.next_out = put,
                strm.avail_out = left,
                strm.next_in = next,
                strm.avail_in = have,
                state.hold = hold,
                state.bits = bits,
                (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < 16206 || flush !== Z_FINISH)) && updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out) ? (state.mode = 16210,
                Z_MEM_ERROR) : (_in -= strm.avail_in,
                _out -= strm.avail_out,
                strm.total_in += _in,
                strm.total_out += _out,
                state.total += _out,
                4 & state.wrap && _out && (strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out)),
                strm.data_type = state.bits + (state.last ? 64 : 0) + (16191 === state.mode ? 128 : 0) + (16199 === state.mode || 16194 === state.mode ? 256 : 0),
                (0 === _in && 0 === _out || flush === Z_FINISH) && ret === Z_OK && (ret = Z_BUF_ERROR),
                ret)
            }
            ,
            module.exports.inflateEnd = strm=>{
                if (inflateStateCheck(strm))
                    return Z_STREAM_ERROR;
                let state = strm.state;
                return state.window && (state.window = null),
                strm.state = null,
                Z_OK
            }
            ,
            module.exports.inflateGetHeader = (strm,head)=>{
                if (inflateStateCheck(strm))
                    return Z_STREAM_ERROR;
                const state = strm.state;
                return 0 == (2 & state.wrap) ? Z_STREAM_ERROR : (state.head = head,
                head.done = !1,
                Z_OK)
            }
            ,
            module.exports.inflateSetDictionary = (strm,dictionary)=>{
                const dictLength = dictionary.length;
                let state, dictid, ret;
                return inflateStateCheck(strm) ? Z_STREAM_ERROR : (state = strm.state,
                0 !== state.wrap && 16190 !== state.mode ? Z_STREAM_ERROR : 16190 === state.mode && (dictid = 1,
                dictid = adler32(dictid, dictionary, dictLength, 0),
                dictid !== state.check) ? Z_DATA_ERROR : (ret = updatewindow(strm, dictionary, dictLength, dictLength),
                ret ? (state.mode = 16210,
                Z_MEM_ERROR) : (state.havedict = 1,
                Z_OK)))
            }
            ,
            module.exports.inflateInfo = "pako inflate (from Nodeca project)"
        }
        ,
        63645: module=>{
            "use strict";
            const lbase = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0])
              , lext = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78])
              , dbase = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0])
              , dext = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]);
            module.exports = (type,lens,lens_index,codes,table,table_index,work,opts)=>{
                const bits = opts.bits;
                let incr, fill, low, mask, next, match, len = 0, sym = 0, min = 0, max = 0, root = 0, curr = 0, drop = 0, left = 0, used = 0, huff = 0, base = null;
                const count = new Uint16Array(16)
                  , offs = new Uint16Array(16);
                let here_bits, here_op, here_val, extra = null;
                for (len = 0; len <= 15; len++)
                    count[len] = 0;
                for (sym = 0; sym < codes; sym++)
                    count[lens[lens_index + sym]]++;
                for (root = bits,
                max = 15; max >= 1 && 0 === count[max]; max--)
                    ;
                if (root > max && (root = max),
                0 === max)
                    return table[table_index++] = 20971520,
                    table[table_index++] = 20971520,
                    opts.bits = 1,
                    0;
                for (min = 1; min < max && 0 === count[min]; min++)
                    ;
                for (root < min && (root = min),
                left = 1,
                len = 1; len <= 15; len++)
                    if (left <<= 1,
                    left -= count[len],
                    left < 0)
                        return -1;
                if (left > 0 && (0 === type || 1 !== max))
                    return -1;
                for (offs[1] = 0,
                len = 1; len < 15; len++)
                    offs[len + 1] = offs[len] + count[len];
                for (sym = 0; sym < codes; sym++)
                    0 !== lens[lens_index + sym] && (work[offs[lens[lens_index + sym]]++] = sym);
                if (0 === type ? (base = extra = work,
                match = 20) : 1 === type ? (base = lbase,
                extra = lext,
                match = 257) : (base = dbase,
                extra = dext,
                match = 0),
                huff = 0,
                sym = 0,
                len = min,
                next = table_index,
                curr = root,
                drop = 0,
                low = -1,
                used = 1 << root,
                mask = used - 1,
                1 === type && used > 852 || 2 === type && used > 592)
                    return 1;
                for (; ; ) {
                    here_bits = len - drop,
                    work[sym] + 1 < match ? (here_op = 0,
                    here_val = work[sym]) : work[sym] >= match ? (here_op = extra[work[sym] - match],
                    here_val = base[work[sym] - match]) : (here_op = 96,
                    here_val = 0),
                    incr = 1 << len - drop,
                    fill = 1 << curr,
                    min = fill;
                    do {
                        fill -= incr,
                        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0
                    } while (0 !== fill);
                    for (incr = 1 << len - 1; huff & incr; )
                        incr >>= 1;
                    if (0 !== incr ? (huff &= incr - 1,
                    huff += incr) : huff = 0,
                    sym++,
                    0 == --count[len]) {
                        if (len === max)
                            break;
                        len = lens[lens_index + work[sym]]
                    }
                    if (len > root && (huff & mask) !== low) {
                        for (0 === drop && (drop = root),
                        next += min,
                        curr = len - drop,
                        left = 1 << curr; curr + drop < max && (left -= count[curr + drop],
                        !(left <= 0)); )
                            curr++,
                            left <<= 1;
                        if (used += 1 << curr,
                        1 === type && used > 852 || 2 === type && used > 592)
                            return 1;
                        low = huff & mask,
                        table[low] = root << 24 | curr << 16 | next - table_index | 0
                    }
                }
                return 0 !== huff && (table[next + huff] = len - drop << 24 | 64 << 16 | 0),
                opts.bits = root,
                0
            }
        }
        ,
        18521: module=>{
            "use strict";
            module.exports = {
                2: "need dictionary",
                1: "stream end",
                0: "",
                "-1": "file error",
                "-2": "stream error",
                "-3": "data error",
                "-4": "insufficient memory",
                "-5": "buffer error",
                "-6": "incompatible version"
            }
        }
        ,
        22416: module=>{
            "use strict";
            function zero(buf) {
                let len = buf.length;
                for (; --len >= 0; )
                    buf[len] = 0
            }
            const extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
              , extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
              , extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
              , bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
              , static_ltree = new Array(576);
            zero(static_ltree);
            const static_dtree = new Array(60);
            zero(static_dtree);
            const _dist_code = new Array(512);
            zero(_dist_code);
            const _length_code = new Array(256);
            zero(_length_code);
            const base_length = new Array(29);
            zero(base_length);
            const base_dist = new Array(30);
            function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
                this.static_tree = static_tree,
                this.extra_bits = extra_bits,
                this.extra_base = extra_base,
                this.elems = elems,
                this.max_length = max_length,
                this.has_stree = static_tree && static_tree.length
            }
            let static_l_desc, static_d_desc, static_bl_desc;
            function TreeDesc(dyn_tree, stat_desc) {
                this.dyn_tree = dyn_tree,
                this.max_code = 0,
                this.stat_desc = stat_desc
            }
            zero(base_dist);
            const d_code = dist=>dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)]
              , put_short = (s,w)=>{
                s.pending_buf[s.pending++] = 255 & w,
                s.pending_buf[s.pending++] = w >>> 8 & 255
            }
              , send_bits = (s,value,length)=>{
                s.bi_valid > 16 - length ? (s.bi_buf |= value << s.bi_valid & 65535,
                put_short(s, s.bi_buf),
                s.bi_buf = value >> 16 - s.bi_valid,
                s.bi_valid += length - 16) : (s.bi_buf |= value << s.bi_valid & 65535,
                s.bi_valid += length)
            }
              , send_code = (s,c,tree)=>{
                send_bits(s, tree[2 * c], tree[2 * c + 1])
            }
              , bi_reverse = (code,len)=>{
                let res = 0;
                do {
                    res |= 1 & code,
                    code >>>= 1,
                    res <<= 1
                } while (--len > 0);
                return res >>> 1
            }
              , gen_codes = (tree,max_code,bl_count)=>{
                const next_code = new Array(16);
                let bits, n, code = 0;
                for (bits = 1; bits <= 15; bits++)
                    code = code + bl_count[bits - 1] << 1,
                    next_code[bits] = code;
                for (n = 0; n <= max_code; n++) {
                    let len = tree[2 * n + 1];
                    0 !== len && (tree[2 * n] = bi_reverse(next_code[len]++, len))
                }
            }
              , init_block = s=>{
                let n;
                for (n = 0; n < 286; n++)
                    s.dyn_ltree[2 * n] = 0;
                for (n = 0; n < 30; n++)
                    s.dyn_dtree[2 * n] = 0;
                for (n = 0; n < 19; n++)
                    s.bl_tree[2 * n] = 0;
                s.dyn_ltree[512] = 1,
                s.opt_len = s.static_len = 0,
                s.sym_next = s.matches = 0
            }
              , bi_windup = s=>{
                s.bi_valid > 8 ? put_short(s, s.bi_buf) : s.bi_valid > 0 && (s.pending_buf[s.pending++] = s.bi_buf),
                s.bi_buf = 0,
                s.bi_valid = 0
            }
              , smaller = (tree,n,m,depth)=>{
                const _n2 = 2 * n
                  , _m2 = 2 * m;
                return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m]
            }
              , pqdownheap = (s,tree,k)=>{
                const v = s.heap[k];
                let j = k << 1;
                for (; j <= s.heap_len && (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth) && j++,
                !smaller(tree, v, s.heap[j], s.depth)); )
                    s.heap[k] = s.heap[j],
                    k = j,
                    j <<= 1;
                s.heap[k] = v
            }
              , compress_block = (s,ltree,dtree)=>{
                let dist, lc, code, extra, sx = 0;
                if (0 !== s.sym_next)
                    do {
                        dist = 255 & s.pending_buf[s.sym_buf + sx++],
                        dist += (255 & s.pending_buf[s.sym_buf + sx++]) << 8,
                        lc = s.pending_buf[s.sym_buf + sx++],
                        0 === dist ? send_code(s, lc, ltree) : (code = _length_code[lc],
                        send_code(s, code + 256 + 1, ltree),
                        extra = extra_lbits[code],
                        0 !== extra && (lc -= base_length[code],
                        send_bits(s, lc, extra)),
                        dist--,
                        code = d_code(dist),
                        send_code(s, code, dtree),
                        extra = extra_dbits[code],
                        0 !== extra && (dist -= base_dist[code],
                        send_bits(s, dist, extra)))
                    } while (sx < s.sym_next);
                send_code(s, 256, ltree)
            }
              , build_tree = (s,desc)=>{
                const tree = desc.dyn_tree
                  , stree = desc.stat_desc.static_tree
                  , has_stree = desc.stat_desc.has_stree
                  , elems = desc.stat_desc.elems;
                let n, m, node, max_code = -1;
                for (s.heap_len = 0,
                s.heap_max = 573,
                n = 0; n < elems; n++)
                    0 !== tree[2 * n] ? (s.heap[++s.heap_len] = max_code = n,
                    s.depth[n] = 0) : tree[2 * n + 1] = 0;
                for (; s.heap_len < 2; )
                    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0,
                    tree[2 * node] = 1,
                    s.depth[node] = 0,
                    s.opt_len--,
                    has_stree && (s.static_len -= stree[2 * node + 1]);
                for (desc.max_code = max_code,
                n = s.heap_len >> 1; n >= 1; n--)
                    pqdownheap(s, tree, n);
                node = elems;
                do {
                    n = s.heap[1],
                    s.heap[1] = s.heap[s.heap_len--],
                    pqdownheap(s, tree, 1),
                    m = s.heap[1],
                    s.heap[--s.heap_max] = n,
                    s.heap[--s.heap_max] = m,
                    tree[2 * node] = tree[2 * n] + tree[2 * m],
                    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1,
                    tree[2 * n + 1] = tree[2 * m + 1] = node,
                    s.heap[1] = node++,
                    pqdownheap(s, tree, 1)
                } while (s.heap_len >= 2);
                s.heap[--s.heap_max] = s.heap[1],
                ((s,desc)=>{
                    const tree = desc.dyn_tree
                      , max_code = desc.max_code
                      , stree = desc.stat_desc.static_tree
                      , has_stree = desc.stat_desc.has_stree
                      , extra = desc.stat_desc.extra_bits
                      , base = desc.stat_desc.extra_base
                      , max_length = desc.stat_desc.max_length;
                    let h, n, m, bits, xbits, f, overflow = 0;
                    for (bits = 0; bits <= 15; bits++)
                        s.bl_count[bits] = 0;
                    for (tree[2 * s.heap[s.heap_max] + 1] = 0,
                    h = s.heap_max + 1; h < 573; h++)
                        n = s.heap[h],
                        bits = tree[2 * tree[2 * n + 1] + 1] + 1,
                        bits > max_length && (bits = max_length,
                        overflow++),
                        tree[2 * n + 1] = bits,
                        n > max_code || (s.bl_count[bits]++,
                        xbits = 0,
                        n >= base && (xbits = extra[n - base]),
                        f = tree[2 * n],
                        s.opt_len += f * (bits + xbits),
                        has_stree && (s.static_len += f * (stree[2 * n + 1] + xbits)));
                    if (0 !== overflow) {
                        do {
                            for (bits = max_length - 1; 0 === s.bl_count[bits]; )
                                bits--;
                            s.bl_count[bits]--,
                            s.bl_count[bits + 1] += 2,
                            s.bl_count[max_length]--,
                            overflow -= 2
                        } while (overflow > 0);
                        for (bits = max_length; 0 !== bits; bits--)
                            for (n = s.bl_count[bits]; 0 !== n; )
                                m = s.heap[--h],
                                m > max_code || (tree[2 * m + 1] !== bits && (s.opt_len += (bits - tree[2 * m + 1]) * tree[2 * m],
                                tree[2 * m + 1] = bits),
                                n--)
                    }
                }
                )(s, desc),
                gen_codes(tree, max_code, s.bl_count)
            }
              , scan_tree = (s,tree,max_code)=>{
                let n, curlen, prevlen = -1, nextlen = tree[1], count = 0, max_count = 7, min_count = 4;
                for (0 === nextlen && (max_count = 138,
                min_count = 3),
                tree[2 * (max_code + 1) + 1] = 65535,
                n = 0; n <= max_code; n++)
                    curlen = nextlen,
                    nextlen = tree[2 * (n + 1) + 1],
                    ++count < max_count && curlen === nextlen || (count < min_count ? s.bl_tree[2 * curlen] += count : 0 !== curlen ? (curlen !== prevlen && s.bl_tree[2 * curlen]++,
                    s.bl_tree[32]++) : count <= 10 ? s.bl_tree[34]++ : s.bl_tree[36]++,
                    count = 0,
                    prevlen = curlen,
                    0 === nextlen ? (max_count = 138,
                    min_count = 3) : curlen === nextlen ? (max_count = 6,
                    min_count = 3) : (max_count = 7,
                    min_count = 4))
            }
              , send_tree = (s,tree,max_code)=>{
                let n, curlen, prevlen = -1, nextlen = tree[1], count = 0, max_count = 7, min_count = 4;
                for (0 === nextlen && (max_count = 138,
                min_count = 3),
                n = 0; n <= max_code; n++)
                    if (curlen = nextlen,
                    nextlen = tree[2 * (n + 1) + 1],
                    !(++count < max_count && curlen === nextlen)) {
                        if (count < min_count)
                            do {
                                send_code(s, curlen, s.bl_tree)
                            } while (0 != --count);
                        else
                            0 !== curlen ? (curlen !== prevlen && (send_code(s, curlen, s.bl_tree),
                            count--),
                            send_code(s, 16, s.bl_tree),
                            send_bits(s, count - 3, 2)) : count <= 10 ? (send_code(s, 17, s.bl_tree),
                            send_bits(s, count - 3, 3)) : (send_code(s, 18, s.bl_tree),
                            send_bits(s, count - 11, 7));
                        count = 0,
                        prevlen = curlen,
                        0 === nextlen ? (max_count = 138,
                        min_count = 3) : curlen === nextlen ? (max_count = 6,
                        min_count = 3) : (max_count = 7,
                        min_count = 4)
                    }
            }
            ;
            let static_init_done = !1;
            const _tr_stored_block = (s,buf,stored_len,last)=>{
                send_bits(s, 0 + (last ? 1 : 0), 3),
                bi_windup(s),
                put_short(s, stored_len),
                put_short(s, ~stored_len),
                stored_len && s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending),
                s.pending += stored_len
            }
            ;
            module.exports._tr_init = s=>{
                static_init_done || ((()=>{
                    let n, bits, length, code, dist;
                    const bl_count = new Array(16);
                    for (length = 0,
                    code = 0; code < 28; code++)
                        for (base_length[code] = length,
                        n = 0; n < 1 << extra_lbits[code]; n++)
                            _length_code[length++] = code;
                    for (_length_code[length - 1] = code,
                    dist = 0,
                    code = 0; code < 16; code++)
                        for (base_dist[code] = dist,
                        n = 0; n < 1 << extra_dbits[code]; n++)
                            _dist_code[dist++] = code;
                    for (dist >>= 7; code < 30; code++)
                        for (base_dist[code] = dist << 7,
                        n = 0; n < 1 << extra_dbits[code] - 7; n++)
                            _dist_code[256 + dist++] = code;
                    for (bits = 0; bits <= 15; bits++)
                        bl_count[bits] = 0;
                    for (n = 0; n <= 143; )
                        static_ltree[2 * n + 1] = 8,
                        n++,
                        bl_count[8]++;
                    for (; n <= 255; )
                        static_ltree[2 * n + 1] = 9,
                        n++,
                        bl_count[9]++;
                    for (; n <= 279; )
                        static_ltree[2 * n + 1] = 7,
                        n++,
                        bl_count[7]++;
                    for (; n <= 287; )
                        static_ltree[2 * n + 1] = 8,
                        n++,
                        bl_count[8]++;
                    for (gen_codes(static_ltree, 287, bl_count),
                    n = 0; n < 30; n++)
                        static_dtree[2 * n + 1] = 5,
                        static_dtree[2 * n] = bi_reverse(n, 5);
                    static_l_desc = new StaticTreeDesc(static_ltree,extra_lbits,257,286,15),
                    static_d_desc = new StaticTreeDesc(static_dtree,extra_dbits,0,30,15),
                    static_bl_desc = new StaticTreeDesc(new Array(0),extra_blbits,0,19,7)
                }
                )(),
                static_init_done = !0),
                s.l_desc = new TreeDesc(s.dyn_ltree,static_l_desc),
                s.d_desc = new TreeDesc(s.dyn_dtree,static_d_desc),
                s.bl_desc = new TreeDesc(s.bl_tree,static_bl_desc),
                s.bi_buf = 0,
                s.bi_valid = 0,
                init_block(s)
            }
            ,
            module.exports._tr_stored_block = _tr_stored_block,
            module.exports._tr_flush_block = (s,buf,stored_len,last)=>{
                let opt_lenb, static_lenb, max_blindex = 0;
                s.level > 0 ? (2 === s.strm.data_type && (s.strm.data_type = (s=>{
                    let n, block_mask = 4093624447;
                    for (n = 0; n <= 31; n++,
                    block_mask >>>= 1)
                        if (1 & block_mask && 0 !== s.dyn_ltree[2 * n])
                            return 0;
                    if (0 !== s.dyn_ltree[18] || 0 !== s.dyn_ltree[20] || 0 !== s.dyn_ltree[26])
                        return 1;
                    for (n = 32; n < 256; n++)
                        if (0 !== s.dyn_ltree[2 * n])
                            return 1;
                    return 0
                }
                )(s)),
                build_tree(s, s.l_desc),
                build_tree(s, s.d_desc),
                max_blindex = (s=>{
                    let max_blindex;
                    for (scan_tree(s, s.dyn_ltree, s.l_desc.max_code),
                    scan_tree(s, s.dyn_dtree, s.d_desc.max_code),
                    build_tree(s, s.bl_desc),
                    max_blindex = 18; max_blindex >= 3 && 0 === s.bl_tree[2 * bl_order[max_blindex] + 1]; max_blindex--)
                        ;
                    return s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4,
                    max_blindex
                }
                )(s),
                opt_lenb = s.opt_len + 3 + 7 >>> 3,
                static_lenb = s.static_len + 3 + 7 >>> 3,
                static_lenb <= opt_lenb && (opt_lenb = static_lenb)) : opt_lenb = static_lenb = stored_len + 5,
                stored_len + 4 <= opt_lenb && -1 !== buf ? _tr_stored_block(s, buf, stored_len, last) : 4 === s.strategy || static_lenb === opt_lenb ? (send_bits(s, 2 + (last ? 1 : 0), 3),
                compress_block(s, static_ltree, static_dtree)) : (send_bits(s, 4 + (last ? 1 : 0), 3),
                ((s,lcodes,dcodes,blcodes)=>{
                    let rank;
                    for (send_bits(s, lcodes - 257, 5),
                    send_bits(s, dcodes - 1, 5),
                    send_bits(s, blcodes - 4, 4),
                    rank = 0; rank < blcodes; rank++)
                        send_bits(s, s.bl_tree[2 * bl_order[rank] + 1], 3);
                    send_tree(s, s.dyn_ltree, lcodes - 1),
                    send_tree(s, s.dyn_dtree, dcodes - 1)
                }
                )(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1),
                compress_block(s, s.dyn_ltree, s.dyn_dtree)),
                init_block(s),
                last && bi_windup(s)
            }
            ,
            module.exports._tr_tally = (s,dist,lc)=>(s.pending_buf[s.sym_buf + s.sym_next++] = dist,
            s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8,
            s.pending_buf[s.sym_buf + s.sym_next++] = lc,
            0 === dist ? s.dyn_ltree[2 * lc]++ : (s.matches++,
            dist--,
            s.dyn_ltree[2 * (_length_code[lc] + 256 + 1)]++,
            s.dyn_dtree[2 * d_code(dist)]++),
            s.sym_next === s.sym_end),
            module.exports._tr_align = s=>{
                send_bits(s, 2, 3),
                send_code(s, 256, static_ltree),
                (s=>{
                    16 === s.bi_valid ? (put_short(s, s.bi_buf),
                    s.bi_buf = 0,
                    s.bi_valid = 0) : s.bi_valid >= 8 && (s.pending_buf[s.pending++] = 255 & s.bi_buf,
                    s.bi_buf >>= 8,
                    s.bi_valid -= 8)
                }
                )(s)
            }
        }
        ,
        90971: module=>{
            "use strict";
            module.exports = function() {
                this.input = null,
                this.next_in = 0,
                this.avail_in = 0,
                this.total_in = 0,
                this.output = null,
                this.next_out = 0,
                this.avail_out = 0,
                this.total_out = 0,
                this.msg = "",
                this.state = null,
                this.data_type = 2,
                this.adler = 0
            }
        }
        ,
        34078: function(module, exports, __webpack_require__) {
            var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__, definition;
            definition = function() {
                return function() {
                    return function(strArray) {
                        var resultArray = [];
                        if (0 === strArray.length)
                            return "";
                        if ("string" != typeof strArray[0])
                            throw new TypeError("Url must be a string. Received " + strArray[0]);
                        if (strArray[0].match(/^[^/:]+:\/*$/) && strArray.length > 1) {
                            var first = strArray.shift();
                            strArray[0] = first + strArray[0]
                        }
                        strArray[0].match(/^file:\/\/\//) ? strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, "$1:///") : strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, "$1://");
                        for (var i = 0; i < strArray.length; i++) {
                            var component = strArray[i];
                            if ("string" != typeof component)
                                throw new TypeError("Url must be a string. Received " + component);
                            "" !== component && (i > 0 && (component = component.replace(/^[\/]+/, "")),
                            component = i < strArray.length - 1 ? component.replace(/[\/]+$/, "") : component.replace(/[\/]+$/, "/"),
                            resultArray.push(component))
                        }
                        var str = resultArray.join("/")
                          , parts = (str = str.replace(/\/(\?|&|#[^!])/g, "$1")).split("?");
                        return parts.shift() + (parts.length > 0 ? "?" : "") + parts.join("&")
                    }("object" == typeof arguments[0] ? arguments[0] : [].slice.call(arguments))
                }
            }
            ,
            module.exports ? module.exports = definition() : void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = definition) ? __WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module) : __WEBPACK_AMD_DEFINE_FACTORY__) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)
        },
        57147: (__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{
            "use strict";
            __webpack_require__.r(__webpack_exports__),
            __webpack_require__.d(__webpack_exports__, {
                DOMException: ()=>DOMException,
                Headers: ()=>Headers,
                Request: ()=>Request,
                Response: ()=>Response,
                fetch: ()=>fetch
            });
            var global = "undefined" != typeof globalThis && globalThis || "undefined" != typeof self && self || void 0 !== global && global
              , support = {
                searchParams: "URLSearchParams"in global,
                iterable: "Symbol"in global && "iterator"in Symbol,
                blob: "FileReader"in global && "Blob"in global && function() {
                    try {
                        return new Blob,
                        !0
                    } catch (e) {
                        return !1
                    }
                }(),
                formData: "FormData"in global,
                arrayBuffer: "ArrayBuffer"in global
            };
            if (support.arrayBuffer)
                var viewClasses = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"]
                  , isArrayBufferView = ArrayBuffer.isView || function(obj) {
                    return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
                }
                ;
            function normalizeName(name) {
                if ("string" != typeof name && (name = String(name)),
                /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || "" === name)
                    throw new TypeError('Invalid character in header field name: "' + name + '"');
                return name.toLowerCase()
            }
            function normalizeValue(value) {
                return "string" != typeof value && (value = String(value)),
                value
            }
            function iteratorFor(items) {
                var iterator = {
                    next: function() {
                        var value = items.shift();
                        return {
                            done: void 0 === value,
                            value
                        }
                    }
                };
                return support.iterable && (iterator[Symbol.iterator] = function() {
                    return iterator
                }
                ),
                iterator
            }
            function Headers(headers) {
                this.map = {},
                headers instanceof Headers ? headers.forEach((function(value, name) {
                    this.append(name, value)
                }
                ), this) : Array.isArray(headers) ? headers.forEach((function(header) {
                    this.append(header[0], header[1])
                }
                ), this) : headers && Object.getOwnPropertyNames(headers).forEach((function(name) {
                    this.append(name, headers[name])
                }
                ), this)
            }
            function consumed(body) {
                if (body.bodyUsed)
                    return Promise.reject(new TypeError("Already read"));
                body.bodyUsed = !0
            }
            function fileReaderReady(reader) {
                return new Promise((function(resolve, reject) {
                    reader.onload = function() {
                        resolve(reader.result)
                    }
                    ,
                    reader.onerror = function() {
                        reject(reader.error)
                    }
                }
                ))
            }
            function readBlobAsArrayBuffer(blob) {
                var reader = new FileReader
                  , promise = fileReaderReady(reader);
                return reader.readAsArrayBuffer(blob),
                promise
            }
            function bufferClone(buf) {
                if (buf.slice)
                    return buf.slice(0);
                var view = new Uint8Array(buf.byteLength);
                return view.set(new Uint8Array(buf)),
                view.buffer
            }
            function Body() {
                return this.bodyUsed = !1,
                this._initBody = function(body) {
                    var obj;
                    this.bodyUsed = this.bodyUsed,
                    this._bodyInit = body,
                    body ? "string" == typeof body ? this._bodyText = body : support.blob && Blob.prototype.isPrototypeOf(body) ? this._bodyBlob = body : support.formData && FormData.prototype.isPrototypeOf(body) ? this._bodyFormData = body : support.searchParams && URLSearchParams.prototype.isPrototypeOf(body) ? this._bodyText = body.toString() : support.arrayBuffer && support.blob && ((obj = body) && DataView.prototype.isPrototypeOf(obj)) ? (this._bodyArrayBuffer = bufferClone(body.buffer),
                    this._bodyInit = new Blob([this._bodyArrayBuffer])) : support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body)) ? this._bodyArrayBuffer = bufferClone(body) : this._bodyText = body = Object.prototype.toString.call(body) : this._bodyText = "",
                    this.headers.get("content-type") || ("string" == typeof body ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : support.searchParams && URLSearchParams.prototype.isPrototypeOf(body) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"))
                }
                ,
                support.blob && (this.blob = function() {
                    var rejected = consumed(this);
                    if (rejected)
                        return rejected;
                    if (this._bodyBlob)
                        return Promise.resolve(this._bodyBlob);
                    if (this._bodyArrayBuffer)
                        return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                    if (this._bodyFormData)
                        throw new Error("could not read FormData body as blob");
                    return Promise.resolve(new Blob([this._bodyText]))
                }
                ,
                this.arrayBuffer = function() {
                    if (this._bodyArrayBuffer) {
                        var isConsumed = consumed(this);
                        return isConsumed || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength)) : Promise.resolve(this._bodyArrayBuffer))
                    }
                    return this.blob().then(readBlobAsArrayBuffer)
                }
                ),
                this.text = function() {
                    var blob, reader, promise, rejected = consumed(this);
                    if (rejected)
                        return rejected;
                    if (this._bodyBlob)
                        return blob = this._bodyBlob,
                        reader = new FileReader,
                        promise = fileReaderReady(reader),
                        reader.readAsText(blob),
                        promise;
                    if (this._bodyArrayBuffer)
                        return Promise.resolve(function(buf) {
                            for (var view = new Uint8Array(buf), chars = new Array(view.length), i = 0; i < view.length; i++)
                                chars[i] = String.fromCharCode(view[i]);
                            return chars.join("")
                        }(this._bodyArrayBuffer));
                    if (this._bodyFormData)
                        throw new Error("could not read FormData body as text");
                    return Promise.resolve(this._bodyText)
                }
                ,
                support.formData && (this.formData = function() {
                    return this.text().then(decode)
                }
                ),
                this.json = function() {
                    return this.text().then(JSON.parse)
                }
                ,
                this
            }
            Headers.prototype.append = function(name, value) {
                name = normalizeName(name),
                value = normalizeValue(value);
                var oldValue = this.map[name];
                this.map[name] = oldValue ? oldValue + ", " + value : value
            }
            ,
            Headers.prototype.delete = function(name) {
                delete this.map[normalizeName(name)]
            }
            ,
            Headers.prototype.get = function(name) {
                return name = normalizeName(name),
                this.has(name) ? this.map[name] : null
            }
            ,
            Headers.prototype.has = function(name) {
                return this.map.hasOwnProperty(normalizeName(name))
            }
            ,
            Headers.prototype.set = function(name, value) {
                this.map[normalizeName(name)] = normalizeValue(value)
            }
            ,
            Headers.prototype.forEach = function(callback, thisArg) {
                for (var name in this.map)
                    this.map.hasOwnProperty(name) && callback.call(thisArg, this.map[name], name, this)
            }
            ,
            Headers.prototype.keys = function() {
                var items = [];
                return this.forEach((function(value, name) {
                    items.push(name)
                }
                )),
                iteratorFor(items)
            }
            ,
            Headers.prototype.values = function() {
                var items = [];
                return this.forEach((function(value) {
                    items.push(value)
                }
                )),
                iteratorFor(items)
            }
            ,
            Headers.prototype.entries = function() {
                var items = [];
                return this.forEach((function(value, name) {
                    items.push([name, value])
                }
                )),
                iteratorFor(items)
            }
            ,
            support.iterable && (Headers.prototype[Symbol.iterator] = Headers.prototype.entries);
            var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
            function Request(input, options) {
                if (!(this instanceof Request))
                    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
                var method, upcased, body = (options = options || {}).body;
                if (input instanceof Request) {
                    if (input.bodyUsed)
                        throw new TypeError("Already read");
                    this.url = input.url,
                    this.credentials = input.credentials,
                    options.headers || (this.headers = new Headers(input.headers)),
                    this.method = input.method,
                    this.mode = input.mode,
                    this.signal = input.signal,
                    body || null == input._bodyInit || (body = input._bodyInit,
                    input.bodyUsed = !0)
                } else
                    this.url = String(input);
                if (this.credentials = options.credentials || this.credentials || "same-origin",
                !options.headers && this.headers || (this.headers = new Headers(options.headers)),
                this.method = (method = options.method || this.method || "GET",
                upcased = method.toUpperCase(),
                methods.indexOf(upcased) > -1 ? upcased : method),
                this.mode = options.mode || this.mode || null,
                this.signal = options.signal || this.signal,
                this.referrer = null,
                ("GET" === this.method || "HEAD" === this.method) && body)
                    throw new TypeError("Body not allowed for GET or HEAD requests");
                if (this._initBody(body),
                !("GET" !== this.method && "HEAD" !== this.method || "no-store" !== options.cache && "no-cache" !== options.cache)) {
                    var reParamSearch = /([?&])_=[^&]*/;
                    if (reParamSearch.test(this.url))
                        this.url = this.url.replace(reParamSearch, "$1_=" + (new Date).getTime());
                    else {
                        this.url += (/\?/.test(this.url) ? "&" : "?") + "_=" + (new Date).getTime()
                    }
                }
            }
            function decode(body) {
                var form = new FormData;
                return body.trim().split("&").forEach((function(bytes) {
                    if (bytes) {
                        var split = bytes.split("=")
                          , name = split.shift().replace(/\+/g, " ")
                          , value = split.join("=").replace(/\+/g, " ");
                        form.append(decodeURIComponent(name), decodeURIComponent(value))
                    }
                }
                )),
                form
            }
            function Response(bodyInit, options) {
                if (!(this instanceof Response))
                    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
                options || (options = {}),
                this.type = "default",
                this.status = void 0 === options.status ? 200 : options.status,
                this.ok = this.status >= 200 && this.status < 300,
                this.statusText = void 0 === options.statusText ? "" : "" + options.statusText,
                this.headers = new Headers(options.headers),
                this.url = options.url || "",
                this._initBody(bodyInit)
            }
            Request.prototype.clone = function() {
                return new Request(this,{
                    body: this._bodyInit
                })
            }
            ,
            Body.call(Request.prototype),
            Body.call(Response.prototype),
            Response.prototype.clone = function() {
                return new Response(this._bodyInit,{
                    status: this.status,
                    statusText: this.statusText,
                    headers: new Headers(this.headers),
                    url: this.url
                })
            }
            ,
            Response.error = function() {
                var response = new Response(null,{
                    status: 0,
                    statusText: ""
                });
                return response.type = "error",
                response
            }
            ;
            var redirectStatuses = [301, 302, 303, 307, 308];
            Response.redirect = function(url, status) {
                if (-1 === redirectStatuses.indexOf(status))
                    throw new RangeError("Invalid status code");
                return new Response(null,{
                    status,
                    headers: {
                        location: url
                    }
                })
            }
            ;
            var DOMException = global.DOMException;
            try {
                new DOMException
            } catch (err) {
                (DOMException = function(message, name) {
                    this.message = message,
                    this.name = name;
                    var error = Error(message);
                    this.stack = error.stack
                }
                ).prototype = Object.create(Error.prototype),
                DOMException.prototype.constructor = DOMException
            }
            function fetch(input, init) {
                return new Promise((function(resolve, reject) {
                    var request = new Request(input,init);
                    if (request.signal && request.signal.aborted)
                        return reject(new DOMException("Aborted","AbortError"));
                    var xhr = new XMLHttpRequest;
                    function abortXhr() {
                        xhr.abort()
                    }
                    xhr.onload = function() {
                        var rawHeaders, headers, options = {
                            status: xhr.status,
                            statusText: xhr.statusText,
                            headers: (rawHeaders = xhr.getAllResponseHeaders() || "",
                            headers = new Headers,
                            rawHeaders.replace(/\r?\n[\t ]+/g, " ").split("\r").map((function(header) {
                                return 0 === header.indexOf("\n") ? header.substr(1, header.length) : header
                            }
                            )).forEach((function(line) {
                                var parts = line.split(":")
                                  , key = parts.shift().trim();
                                if (key) {
                                    var value = parts.join(":").trim();
                                    headers.append(key, value)
                                }
                            }
                            )),
                            headers)
                        };
                        options.url = "responseURL"in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
                        var body = "response"in xhr ? xhr.response : xhr.responseText;
                        setTimeout((function() {
                            resolve(new Response(body,options))
                        }
                        ), 0)
                    }
                    ,
                    xhr.onerror = function() {
                        setTimeout((function() {
                            reject(new TypeError("Network request failed"))
                        }
                        ), 0)
                    }
                    ,
                    xhr.ontimeout = function() {
                        setTimeout((function() {
                            reject(new TypeError("Network request failed"))
                        }
                        ), 0)
                    }
                    ,
                    xhr.onabort = function() {
                        setTimeout((function() {
                            reject(new DOMException("Aborted","AbortError"))
                        }
                        ), 0)
                    }
                    ,
                    xhr.open(request.method, function(url) {
                        try {
                            return "" === url && global.location.href ? global.location.href : url
                        } catch (e) {
                            return url
                        }
                    }(request.url), !0),
                    "include" === request.credentials ? xhr.withCredentials = !0 : "omit" === request.credentials && (xhr.withCredentials = !1),
                    "responseType"in xhr && (support.blob ? xhr.responseType = "blob" : support.arrayBuffer && request.headers.get("Content-Type") && -1 !== request.headers.get("Content-Type").indexOf("application/octet-stream") && (xhr.responseType = "arraybuffer")),
                    !init || "object" != typeof init.headers || init.headers instanceof Headers ? request.headers.forEach((function(value, name) {
                        xhr.setRequestHeader(name, value)
                    }
                    )) : Object.getOwnPropertyNames(init.headers).forEach((function(name) {
                        xhr.setRequestHeader(name, normalizeValue(init.headers[name]))
                    }
                    )),
                    request.signal && (request.signal.addEventListener("abort", abortXhr),
                    xhr.onreadystatechange = function() {
                        4 === xhr.readyState && request.signal.removeEventListener("abort", abortXhr)
                    }
                    ),
                    xhr.send(void 0 === request._bodyInit ? null : request._bodyInit)
                }
                ))
            }
            fetch.polyfill = !0,
            global.fetch || (global.fetch = fetch,
            global.Headers = Headers,
            global.Request = Request,
            global.Response = Response)
        }
        ,
        46601: ()=>{}
        ,
        89214: ()=>{}
        ,
        99339: ()=>{}
        ,
        73897: module=>{
            module.exports = function(r, a) {
                (null == a || a > r.length) && (a = r.length);
                for (var e = 0, n = Array(a); e < a; e++)
                    n[e] = r[e];
                return n
            }
            ,
            module.exports.__esModule = !0,
            module.exports.default = module.exports
        }
        ,
        85372: module=>{
            module.exports = function(r) {
                if (Array.isArray(r))
                    return r
            }
            ,
            module.exports.__esModule = !0,
            module.exports.default = module.exports
        }
        ,
        63405: (module,__unused_webpack_exports,__webpack_require__)=>{
            var arrayLikeToArray = __webpack_require__(73897);
            module.exports = function(r) {
                if (Array.isArray(r))
                    return arrayLikeToArray(r)
            }
            ,
            module.exports.__esModule = !0,
            module.exports.default = module.exports
        }
        ,
        66115: module=>{
            module.exports = function(e) {
                if (void 0 === e)
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return e
            }
            ,
            module.exports.__esModule = !0,
            module.exports.default = module.exports
        }
        ,
        17156: module=>{
            function asyncGeneratorStep(n, t, e, r, o, a, c) {
                try {
                    var i = n[a](c)
                      , u = i.value
                } catch (n) {
                    return void e(n)
                }
                i.done ? t(u) : Promise.resolve(u).then(r, o)
            }
            module.exports = function(n) {
                return function() {
                    var t = this
                      , e = arguments;
                    return new Promise((function(r, o) {
                        var a = n.apply(t, e);
                        function _next(n) {
                            asyncGeneratorStep(a, r, o, _next, _throw, "next", n)
                        }
                        function _throw(n) {
                            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n)
                        }
                        _next(void 0)
                    }
                    ))
                }
            }
            ,
            module.exports.__esModule = !0,
            module.exports.default = module.exports
        }
        ,
        56690: module=>{
            module.exports = function(a, n) {
                if (!(a instanceof n))
                    throw new TypeError("Cannot call a class as a function")
            }
            ,
            module.exports.__esModule = !0,
            module.exports.default = module.exports
        }
        ,
        29399: module=>{
            module.exports = function(e, t) {
                if (!{}.hasOwnProperty.call(e, t))
                    throw new TypeError("attempted to use private field on non-instance");
                return e
            }
            ,
            module.exports.__esModule = !0,
            module.exports.default = module.exports
        }
        ,
        40426: module=>{
            var id = 0;
            module.exports = function(e) {
                return "__private_" + id++ + "_" + e
            }
            ,
            module.exports.__esModule = !0,
            module.exports.default = module.exports
        }
        ,
        89728: (module,__unused_webpack_exports,__webpack_require__)=>{
            var toPropertyKey = __webpack_require__(64062);
            function _defineProperties(e, r) {
                for (var t = 0; t < r.length; t++) {
                    var o = r[t];
                    o.enumerable = o.enumerable || !1,
                    o.configurable = !0,
                    "value"in o && (o.writable = !0),
                    Object.defineProperty(e, toPropertyKey(o.key), o)
                }
            }
            module.exports = function(e, r, t) {
                return r && _defineProperties(e.prototype, r),
                t && _defineProperties(e, t),
                Object.defineProperty(e, "prototype", {
                    writable: !1
                }),
                e
            }
            ,
            module.exports.__esModule = !0,
            module.exports.default = module.exports
        }
        ,
        73808: module=>{
            function _getPrototypeOf(t) {
                return module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                }
                ,
                module.exports.__esModule = !0,
                module.exports.default = module.exports,
                _getPrototypeOf(t)
            }
            module.exports = _getPrototypeOf,
            module.exports.__esModule = !0,
            module.exports.default = module.exports
        }
        ,
        61655: (module,__unused_webpack_exports,__webpack_require__)=>{
            var setPrototypeOf = __webpack_require__(6015);
            module.exports = function(t, e) {
                if ("function" != typeof e && null !== e)
                    throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }),
                Object.defineProperty(t, "prototype", {
                    writable: !1
                }),
                e && setPrototypeOf(t, e)
            }
            ,
            module.exports.__esModule = !0,
            module.exports.default = module.exports
        }
        ,
        64836: module=>{
            module.exports = function(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            ,
            module.exports.__esModule = !0,
            module.exports.default = module.exports
        }
        ,
        79498: module=>{
            module.exports = function(r) {
                if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"])
                    return Array.from(r)
            }
            ,
            module.exports.__esModule = !0,
            module.exports.default = module.exports
        }
        ,
        68872: module=>{
            module.exports = function(r, l) {
                var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
                if (null != t) {
                    var e, n, i, u, a = [], f = !0, o = !1;
                    try {
                        if (i = (t = t.call(r)).next,
                        0 === l) {
                            if (Object(t) !== t)
                                return;
                            f = !1
                        } else
                            for (; !(f = (e = i.call(t)).done) && (a.push(e.value),
                            a.length !== l); f = !0)
                                ;
                    } catch (r) {
                        o = !0,
                        n = r
                    } finally {
                        try {
                            if (!f && null != t.return && (u = t.return(),
                            Object(u) !== u))
                                return
                        } finally {
                            if (o)
                                throw n
                        }
                    }
                    return a
                }
            }
            ,
            module.exports.__esModule = !0,
            module.exports.default = module.exports
        }
        ,
        12218: module=>{
            module.exports = function() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            ,
            module.exports.__esModule = !0,
            module.exports.default = module.exports
        }
        ,
        42281: module=>{
            module.exports = function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            ,
            module.exports.__esModule = !0,
            module.exports.default = module.exports
        }
        ,
        94993: (module,__unused_webpack_exports,__webpack_require__)=>{
            var _typeof = __webpack_require__(18698).default
              , assertThisInitialized = __webpack_require__(66115);
            module.exports = function(t, e) {
                if (e && ("object" == _typeof(e) || "function" == typeof e))
                    return e;
                if (void 0 !== e)
                    throw new TypeError("Derived constructors may only return object or undefined");
                return assertThisInitialized(t)
            }
            ,
            module.exports.__esModule = !0,
            module.exports.default = module.exports
        }
        ,
        6015: module=>{
            function _setPrototypeOf(t, e) {
                return module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
                    return t.__proto__ = e,
                    t
                }
                ,
                module.exports.__esModule = !0,
                module.exports.default = module.exports,
                _setPrototypeOf(t, e)
            }
            module.exports = _setPrototypeOf,
            module.exports.__esModule = !0,
            module.exports.default = module.exports
        }
        ,
        27424: (module,__unused_webpack_exports,__webpack_require__)=>{
            var arrayWithHoles = __webpack_require__(85372)
              , iterableToArrayLimit = __webpack_require__(68872)
              , unsupportedIterableToArray = __webpack_require__(86116)
              , nonIterableRest = __webpack_require__(12218);
            module.exports = function(r, e) {
                return arrayWithHoles(r) || iterableToArrayLimit(r, e) || unsupportedIterableToArray(r, e) || nonIterableRest()
            }
            ,
            module.exports.__esModule = !0,
            module.exports.default = module.exports
        }
        ,
        861: (module,__unused_webpack_exports,__webpack_require__)=>{
            var arrayWithoutHoles = __webpack_require__(63405)
              , iterableToArray = __webpack_require__(79498)
              , unsupportedIterableToArray = __webpack_require__(86116)
              , nonIterableSpread = __webpack_require__(42281);
            module.exports = function(r) {
                return arrayWithoutHoles(r) || iterableToArray(r) || unsupportedIterableToArray(r) || nonIterableSpread()
            }
            ,
            module.exports.__esModule = !0,
            module.exports.default = module.exports
        }
        ,
        95036: (module,__unused_webpack_exports,__webpack_require__)=>{
            var _typeof = __webpack_require__(18698).default;
            module.exports = function(t, r) {
                if ("object" != _typeof(t) || !t)
                    return t;
                var e = t[Symbol.toPrimitive];
                if (void 0 !== e) {
                    var i = e.call(t, r || "default");
                    if ("object" != _typeof(i))
                        return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return ("string" === r ? String : Number)(t)
            }
            ,
            module.exports.__esModule = !0,
            module.exports.default = module.exports
        }
        ,
        64062: (module,__unused_webpack_exports,__webpack_require__)=>{
            var _typeof = __webpack_require__(18698).default
              , toPrimitive = __webpack_require__(95036);
            module.exports = function(t) {
                var i = toPrimitive(t, "string");
                return "symbol" == _typeof(i) ? i : i + ""
            }
            ,
            module.exports.__esModule = !0,
            module.exports.default = module.exports
        }
        ,
        18698: module=>{
            function _typeof(o) {
                return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
                    return typeof o
                }
                : function(o) {
                    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o
                }
                ,
                module.exports.__esModule = !0,
                module.exports.default = module.exports,
                _typeof(o)
            }
            module.exports = _typeof,
            module.exports.__esModule = !0,
            module.exports.default = module.exports
        }
        ,
        86116: (module,__unused_webpack_exports,__webpack_require__)=>{
            var arrayLikeToArray = __webpack_require__(73897);
            module.exports = function(r, a) {
                if (r) {
                    if ("string" == typeof r)
                        return arrayLikeToArray(r, a);
                    var t = {}.toString.call(r).slice(8, -1);
                    return "Object" === t && r.constructor && (t = r.constructor.name),
                    "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? arrayLikeToArray(r, a) : void 0
                }
            }
            ,
            module.exports.__esModule = !0,
            module.exports.default = module.exports
        }
        ,
        30484: function(__unused_webpack_module, exports) {
            !function(t) {
                "use strict";
                function r(t) {
                    return n.test(t)
                }
                var n = /^-?[0-9]+$/;
                function e(t) {
                    return i.test(t)
                }
                var o, i = /^-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?$/;
                function a(t, n) {
                    var e = parseFloat(t)
                      , o = String(e)
                      , i = c(t)
                      , a = c(o);
                    return i === a || !!(!0 === (null == n ? void 0 : n.approx) && !r(t) && a.length >= 14 && i.startsWith(a.substring(0, 14)))
                }
                function u(n) {
                    if (!a(n, {
                        approx: !1
                    })) {
                        if (r(n))
                            return t.UnsafeNumberReason.truncate_integer;
                        var e = parseFloat(n);
                        return isFinite(e) ? 0 === e ? t.UnsafeNumberReason.underflow : t.UnsafeNumberReason.truncate_float : t.UnsafeNumberReason.overflow
                    }
                }
                function c(t) {
                    return t.replace(f, "").replace(s, "").replace(y, "").replace(l, "")
                }
                t.UnsafeNumberReason = void 0,
                (o = t.UnsafeNumberReason || (t.UnsafeNumberReason = {})).underflow = "underflow",
                o.overflow = "overflow",
                o.truncate_integer = "truncate_integer",
                o.truncate_float = "truncate_float";
                var f = /[eE][+-]?\d+$/
                  , l = /^-?(0*)?/
                  , s = /\./
                  , y = /0+$/;
                function d(t) {
                    return d = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                        return typeof t
                    }
                    : function(t) {
                        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                    }
                    ,
                    d(t)
                }
                function p(t, r) {
                    for (var n = 0; n < r.length; n++) {
                        var e = r[n];
                        e.enumerable = e.enumerable || !1,
                        e.configurable = !0,
                        "value"in e && (e.writable = !0),
                        Object.defineProperty(t, b(e.key), e)
                    }
                }
                function b(t) {
                    var r = function(t, r) {
                        if ("object" !== d(t) || null === t)
                            return t;
                        var n = t[Symbol.toPrimitive];
                        if (void 0 !== n) {
                            var e = n.call(t, r || "default");
                            if ("object" !== d(e))
                                return e;
                            throw new TypeError("@@toPrimitive must return a primitive value.")
                        }
                        return ("string" === r ? String : Number)(t)
                    }(t, "string");
                    return "symbol" === d(r) ? r : String(r)
                }
                var v = function() {
                    function n(t) {
                        if (function(t, r) {
                            if (!(t instanceof r))
                                throw new TypeError("Cannot call a class as a function")
                        }(this, n),
                        function(t, r, n) {
                            (r = b(r))in t ? Object.defineProperty(t, r, {
                                value: n,
                                enumerable: !0,
                                configurable: !0,
                                writable: !0
                            }) : t[r] = n
                        }(this, "isLosslessNumber", !0),
                        !e(t))
                            throw new Error('Invalid number (value: "' + t + '")');
                        this.value = t
                    }
                    var o, i, a;
                    return o = n,
                    (i = [{
                        key: "valueOf",
                        value: function() {
                            var n = u(this.value);
                            if (void 0 === n || n === t.UnsafeNumberReason.truncate_float)
                                return parseFloat(this.value);
                            if (r(this.value))
                                return BigInt(this.value);
                            throw new Error("Cannot safely convert to number: " + "the value '".concat(this.value, "' would ").concat(n, " and become ").concat(parseFloat(this.value)))
                        }
                    }, {
                        key: "toString",
                        value: function() {
                            return this.value
                        }
                    }]) && p(o.prototype, i),
                    a && p(o, a),
                    Object.defineProperty(o, "prototype", {
                        writable: !1
                    }),
                    n
                }();
                function h(t) {
                    return t && "object" === d(t) && !0 === t.isLosslessNumber || !1
                }
                function m(t) {
                    return new v(t)
                }
                function w(t) {
                    return w = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                        return typeof t
                    }
                    : function(t) {
                        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                    }
                    ,
                    w(t)
                }
                function g(t, r) {
                    return S({
                        "": t
                    }, "", t, r)
                }
                function S(t, r, n, e) {
                    return Array.isArray(n) ? e.call(t, r, function(t, r) {
                        for (var n = 0; n < t.length; n++)
                            t[n] = S(t, n + "", t[n], r);
                        return t
                    }(n, e)) : n && "object" === w(n) && !h(n) ? e.call(t, r, function(t, r) {
                        return Object.keys(t).forEach((function(n) {
                            var e = S(t, n, t[n], r);
                            void 0 !== e ? t[n] = e : delete t[n]
                        }
                        )),
                        t
                    }(n, e)) : e.call(t, r, n)
                }
                function A(t) {
                    return A = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                        return typeof t
                    }
                    : function(t) {
                        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                    }
                    ,
                    A(t)
                }
                function C(t) {
                    return function(t) {
                        if (Array.isArray(t))
                            return N(t)
                    }(t) || function(t) {
                        if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"])
                            return Array.from(t)
                    }(t) || function(t, r) {
                        if (t) {
                            if ("string" == typeof t)
                                return N(t, r);
                            var n = Object.prototype.toString.call(t).slice(8, -1);
                            return "Object" === n && t.constructor && (n = t.constructor.name),
                            "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? N(t, r) : void 0
                        }
                    }(t) || function() {
                        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }()
                }
                function N(t, r) {
                    (null == r || r > t.length) && (r = t.length);
                    for (var n = 0, e = new Array(r); n < r; n++)
                        e[n] = t[n];
                    return e
                }
                function E(t) {
                    return t === $ || t === P || t === B || t === D
                }
                function x(t) {
                    return t >= Z && t <= z || t >= V && t <= rt || t >= X && t <= nt
                }
                function j(t) {
                    return t >= Z && t <= z
                }
                function O(t) {
                    return t >= q && t <= z
                }
                function I(t) {
                    return t >= 32 && t <= 1114111
                }
                function k(t, r) {
                    return t === r || (Array.isArray(t) && Array.isArray(r) ? t.length === r.length && t.every((function(t, n) {
                        return k(t, r[n])
                    }
                    )) : !(!R(t) || !R(r)) && C(new Set([].concat(C(Object.keys(t)), C(Object.keys(r))))).every((function(n) {
                        return k(t[n], r[n])
                    }
                    )))
                }
                function R(t) {
                    return "object" === A(t) && null !== t
                }
                var U = {
                    '"': '"',
                    "\\": "\\",
                    "/": "/",
                    b: "\b",
                    f: "\f",
                    n: "\n",
                    r: "\r",
                    t: "\t"
                }
                  , _ = 92
                  , F = 123
                  , J = 125
                  , L = 91
                  , T = 93
                  , $ = 32
                  , P = 10
                  , B = 9
                  , D = 13
                  , Q = 34
                  , M = 43
                  , W = 45
                  , Z = 48
                  , q = 49
                  , z = 57
                  , G = 44
                  , H = 46
                  , K = 58
                  , V = 65
                  , X = 97
                  , Y = 69
                  , tt = 101
                  , rt = 70
                  , nt = 102;
                function et(t) {
                    return et = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                        return typeof t
                    }
                    : function(t) {
                        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                    }
                    ,
                    et(t)
                }
                var ot = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$/;
                t.LosslessNumber = v,
                t.config = function(t) {
                    throw new Error("config is deprecated, support for circularRefs is removed from the library. If you encounter circular references in your data structures, please rethink your datastructures: better prevent circular references in the first place.")
                }
                ,
                t.getUnsafeNumberReason = u,
                t.isInteger = r,
                t.isLosslessNumber = h,
                t.isNumber = e,
                t.isSafeNumber = a,
                t.parse = function(t, r) {
                    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : m
                      , e = 0
                      , o = u();
                    return p(o),
                    v(),
                    r ? g(o, r) : o;
                    function i() {
                        if (t.charCodeAt(e) === F) {
                            e++,
                            f();
                            for (var r = {}, n = !0; e < t.length && t.charCodeAt(e) !== J; ) {
                                n ? n = !1 : (y(),
                                f());
                                var o = e
                                  , i = l();
                                void 0 === i && S(),
                                f(),
                                d();
                                var a = u();
                                Object.prototype.hasOwnProperty.call(r, i) && !k(a, r[i]) && A(i, o + 1),
                                r[i] = a
                            }
                            return t.charCodeAt(e) !== J && C(),
                            e++,
                            r
                        }
                    }
                    function a() {
                        if (t.charCodeAt(e) === L) {
                            e++,
                            f();
                            for (var r = [], n = !0; e < t.length && t.charCodeAt(e) !== T; ) {
                                n ? n = !1 : y();
                                var o = u();
                                b(o),
                                r.push(o)
                            }
                            return t.charCodeAt(e) !== T && N(),
                            e++,
                            r
                        }
                    }
                    function u() {
                        var t, r, n, e, o, u;
                        f();
                        var y = null !== (t = null !== (r = null !== (n = null !== (e = null !== (o = null !== (u = l()) && void 0 !== u ? u : s()) && void 0 !== o ? o : i()) && void 0 !== e ? e : a()) && void 0 !== n ? n : c("true", !0)) && void 0 !== r ? r : c("false", !1)) && void 0 !== t ? t : c("null", null);
                        return f(),
                        y
                    }
                    function c(r, n) {
                        if (t.slice(e, e + r.length) === r)
                            return e += r.length,
                            n
                    }
                    function f() {
                        for (; E(t.charCodeAt(e)); )
                            e++
                    }
                    function l() {
                        if (t.charCodeAt(e) === Q) {
                            e++;
                            for (var r = ""; e < t.length && t.charCodeAt(e) !== Q; ) {
                                if (t.charCodeAt(e) === _) {
                                    var n = t[e + 1]
                                      , o = U[n];
                                    void 0 !== o ? (r += o,
                                    e++) : "u" === n ? x(t.charCodeAt(e + 2)) && x(t.charCodeAt(e + 3)) && x(t.charCodeAt(e + 4)) && x(t.charCodeAt(e + 5)) ? (r += String.fromCharCode(parseInt(t.slice(e + 2, e + 6), 16)),
                                    e += 5) : P(e) : $(e)
                                } else
                                    I(t.charCodeAt(e)) ? r += t[e] : R(t[e]);
                                e++
                            }
                            return w(),
                            e++,
                            r
                        }
                    }
                    function s() {
                        var r = e;
                        if (t.charCodeAt(e) === W && (e++,
                        h(r)),
                        t.charCodeAt(e) === Z)
                            e++;
                        else if (O(t.charCodeAt(e)))
                            for (e++; j(t.charCodeAt(e)); )
                                e++;
                        if (t.charCodeAt(e) === H)
                            for (e++,
                            h(r); j(t.charCodeAt(e)); )
                                e++;
                        if (t.charCodeAt(e) === tt || t.charCodeAt(e) === Y)
                            for (e++,
                            t.charCodeAt(e) !== W && t.charCodeAt(e) !== M || e++,
                            h(r); j(t.charCodeAt(e)); )
                                e++;
                        if (e > r)
                            return n(t.slice(r, e))
                    }
                    function y() {
                        if (t.charCodeAt(e) !== G)
                            throw new SyntaxError("Comma ',' expected after value ".concat(q()));
                        e++
                    }
                    function d() {
                        if (t.charCodeAt(e) !== K)
                            throw new SyntaxError("Colon ':' expected after property name ".concat(q()));
                        e++
                    }
                    function p(t) {
                        if (void 0 === t)
                            throw new SyntaxError("JSON value expected ".concat(q()))
                    }
                    function b(t) {
                        if (void 0 === t)
                            throw new SyntaxError("Array item expected ".concat(q()))
                    }
                    function v() {
                        if (e < t.length)
                            throw new SyntaxError("Expected end of input ".concat(q()))
                    }
                    function h(r) {
                        if (!j(t.charCodeAt(e))) {
                            var n = t.slice(r, e);
                            throw new SyntaxError("Invalid number '".concat(n, "', expecting a digit ").concat(q()))
                        }
                    }
                    function w() {
                        if (t.charCodeAt(e) !== Q)
                            throw new SyntaxError("End of string '\"' expected ".concat(q()))
                    }
                    function S() {
                        throw new SyntaxError("Quoted object key expected ".concat(q()))
                    }
                    function A(t, r) {
                        throw new SyntaxError("Duplicate key '".concat(t, "' encountered at position ").concat(r))
                    }
                    function C() {
                        throw new SyntaxError("Quoted object key or end of object '}' expected ".concat(q()))
                    }
                    function N() {
                        throw new SyntaxError("Array item or end of array ']' expected ".concat(q()))
                    }
                    function R(t) {
                        throw new SyntaxError("Invalid character '".concat(t, "' ").concat(B()))
                    }
                    function $(r) {
                        var n = t.slice(r, r + 2);
                        throw new SyntaxError("Invalid escape character '".concat(n, "' ").concat(B()))
                    }
                    function P(r) {
                        for (var n = r + 2; /\w/.test(t[n]); )
                            n++;
                        var e = t.slice(r, n);
                        throw new SyntaxError("Invalid unicode character '".concat(e, "' ").concat(B()))
                    }
                    function B() {
                        return "at position ".concat(e)
                    }
                    function D() {
                        return e < t.length ? "but got '".concat(t[e], "'") : "but reached end of input"
                    }
                    function q() {
                        return D() + " " + B()
                    }
                }
                ,
                t.parseLosslessNumber = m,
                t.parseNumberAndBigInt = function(t) {
                    return r(t) ? BigInt(t) : parseFloat(t)
                }
                ,
                t.reviveDate = function(t, r) {
                    return "string" == typeof r && ot.test(r) ? new Date(r) : r
                }
                ,
                t.stringify = function t(r, n, o, i) {
                    var a = function(t) {
                        return "number" == typeof t ? " ".repeat(t) : "string" == typeof t && "" !== t ? t : void 0
                    }(o);
                    return u("function" == typeof n ? n.call({
                        "": r
                    }, "", r) : r, "");
                    function u(r, c) {
                        if (Array.isArray(i)) {
                            var f = i.find((function(t) {
                                return t.test(r)
                            }
                            ));
                            if (f) {
                                var l = f.stringify(r);
                                if ("string" != typeof l || !e(l))
                                    throw new Error("Invalid JSON number: output of a number stringifier must be a string containing a JSON number " + "(output: ".concat(l, ")"));
                                return l
                            }
                        }
                        return "boolean" == typeof r || "number" == typeof r || "string" == typeof r || null === r || r instanceof Date || r instanceof Boolean || r instanceof Number || r instanceof String ? JSON.stringify(r) : r && r.isLosslessNumber || "bigint" == typeof r ? r.toString() : Array.isArray(r) ? function(t, r) {
                            if (0 === t.length)
                                return "[]";
                            for (var e = a ? r + a : void 0, o = a ? "[\n" : "[", i = 0; i < t.length; i++) {
                                var c = "function" == typeof n ? n.call(t, String(i), t[i]) : t[i];
                                a && (o += e),
                                o += void 0 !== c && "function" != typeof c ? u(c, e) : "null",
                                i < t.length - 1 && (o += a ? ",\n" : ",")
                            }
                            return o + (a ? "\n" + r + "]" : "]")
                        }(r, c) : r && "object" === et(r) ? function(r, e) {
                            if ("function" == typeof r.toJSON)
                                return t(r.toJSON(), n, o, void 0);
                            var i = Array.isArray(n) ? n.map(String) : Object.keys(r);
                            if (0 === i.length)
                                return "{}";
                            var c = a ? e + a : void 0
                              , f = !0
                              , l = a ? "{\n" : "{";
                            return i.forEach((function(t) {
                                var e = "function" == typeof n ? n.call(r, t, r[t]) : r[t];
                                if (function(t, r) {
                                    return void 0 !== r && "function" != typeof r && "symbol" !== et(r)
                                }(0, e)) {
                                    f ? f = !1 : l += a ? ",\n" : ",";
                                    var o = JSON.stringify(t);
                                    l += a ? c + o + ": " : o + ":",
                                    l += u(e, c)
                                }
                            }
                            )),
                            l += a ? "\n" + e + "}" : "}"
                        }(r, c) : void 0
                    }
                }
                ,
                t.toLosslessNumber = function(t) {
                    if (c(t + "").length > 15)
                        throw new Error("Invalid number: contains more than 15 digits and is most likely truncated and unsafe by itself " + "(value: ".concat(t, ")"));
                    if (isNaN(t))
                        throw new Error("Invalid number: NaN");
                    if (!isFinite(t))
                        throw new Error("Invalid number: " + t);
                    return new v(String(t))
                }
                ,
                t.toSafeNumberOrThrow = function(r, n) {
                    var e = parseFloat(r)
                      , o = u(r);
                    if (!0 === (null == n ? void 0 : n.approx) ? o && o !== t.UnsafeNumberReason.truncate_float : o) {
                        var i = o.replace(/_\w+$/, "");
                        throw new Error("Cannot safely convert to number: " + "the value '".concat(r, "' would ").concat(i, " and become ").concat(e))
                    }
                    return e
                }
            }(exports)
        },
        89732: (__unused_webpack_module,exports)=>{
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            })
        }
        ,
        65482: (__unused_webpack_module,exports)=>{
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            })
        }
        ,
        99284: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                void 0 === k2 && (k2 = k);
                var desc = Object.getOwnPropertyDescriptor(m, k);
                desc && !("get"in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
                    enumerable: !0,
                    get: function() {
                        return m[k]
                    }
                }),
                Object.defineProperty(o, k2, desc)
            }
            : function(o, m, k, k2) {
                void 0 === k2 && (k2 = k),
                o[k2] = m[k]
            }
            )
              , __exportStar = this && this.__exportStar || function(m, exports) {
                for (var p in m)
                    "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p)
            }
            ;
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.SPEC = exports.Errors = void 0,
            exports.Errors = __webpack_require__(65482),
            exports.SPEC = __webpack_require__(89732),
            __exportStar(__webpack_require__(73409), exports)
        },
        73409: (__unused_webpack_module,exports)=>{
            "use strict";
            var ETransactionType, ESimulationFlag, ETransactionStatus, ETransactionFinalityStatus, ETransactionExecutionStatus, EBlockTag, EDataAvailabilityMode, EDAMode, ETransactionVersion, ETransactionVersion2, ETransactionVersion3;
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.ETransactionVersion3 = exports.ETransactionVersion2 = exports.ETransactionVersion = exports.EDAMode = exports.EDataAvailabilityMode = exports.EBlockTag = exports.ETransactionExecutionStatus = exports.ETransactionFinalityStatus = exports.ETransactionStatus = exports.ESimulationFlag = exports.ETransactionType = void 0,
            function(ETransactionType) {
                ETransactionType.DECLARE = "DECLARE",
                ETransactionType.DEPLOY = "DEPLOY",
                ETransactionType.DEPLOY_ACCOUNT = "DEPLOY_ACCOUNT",
                ETransactionType.INVOKE = "INVOKE",
                ETransactionType.L1_HANDLER = "L1_HANDLER"
            }(ETransactionType || (exports.ETransactionType = ETransactionType = {})),
            function(ESimulationFlag) {
                ESimulationFlag.SKIP_VALIDATE = "SKIP_VALIDATE",
                ESimulationFlag.SKIP_FEE_CHARGE = "SKIP_FEE_CHARGE"
            }(ESimulationFlag || (exports.ESimulationFlag = ESimulationFlag = {})),
            function(ETransactionStatus) {
                ETransactionStatus.RECEIVED = "RECEIVED",
                ETransactionStatus.REJECTED = "REJECTED",
                ETransactionStatus.ACCEPTED_ON_L2 = "ACCEPTED_ON_L2",
                ETransactionStatus.ACCEPTED_ON_L1 = "ACCEPTED_ON_L1"
            }(ETransactionStatus || (exports.ETransactionStatus = ETransactionStatus = {})),
            function(ETransactionFinalityStatus) {
                ETransactionFinalityStatus.ACCEPTED_ON_L2 = "ACCEPTED_ON_L2",
                ETransactionFinalityStatus.ACCEPTED_ON_L1 = "ACCEPTED_ON_L1"
            }(ETransactionFinalityStatus || (exports.ETransactionFinalityStatus = ETransactionFinalityStatus = {})),
            function(ETransactionExecutionStatus) {
                ETransactionExecutionStatus.SUCCEEDED = "SUCCEEDED",
                ETransactionExecutionStatus.REVERTED = "REVERTED"
            }(ETransactionExecutionStatus || (exports.ETransactionExecutionStatus = ETransactionExecutionStatus = {})),
            function(EBlockTag) {
                EBlockTag.LATEST = "latest",
                EBlockTag.PENDING = "pending"
            }(EBlockTag || (exports.EBlockTag = EBlockTag = {})),
            function(EDataAvailabilityMode) {
                EDataAvailabilityMode.L1 = "L1",
                EDataAvailabilityMode.L2 = "L2"
            }(EDataAvailabilityMode || (exports.EDataAvailabilityMode = EDataAvailabilityMode = {})),
            function(EDAMode) {
                EDAMode[EDAMode.L1 = 0] = "L1",
                EDAMode[EDAMode.L2 = 1] = "L2"
            }(EDAMode || (exports.EDAMode = EDAMode = {})),
            function(ETransactionVersion) {
                ETransactionVersion.V0 = "0x0",
                ETransactionVersion.V1 = "0x1",
                ETransactionVersion.V2 = "0x2",
                ETransactionVersion.V3 = "0x3",
                ETransactionVersion.F0 = "0x100000000000000000000000000000000",
                ETransactionVersion.F1 = "0x100000000000000000000000000000001",
                ETransactionVersion.F2 = "0x100000000000000000000000000000002",
                ETransactionVersion.F3 = "0x100000000000000000000000000000003"
            }(ETransactionVersion || (exports.ETransactionVersion = ETransactionVersion = {})),
            function(ETransactionVersion2) {
                ETransactionVersion2.V0 = "0x0",
                ETransactionVersion2.V1 = "0x1",
                ETransactionVersion2.V2 = "0x2",
                ETransactionVersion2.F0 = "0x100000000000000000000000000000000",
                ETransactionVersion2.F1 = "0x100000000000000000000000000000001",
                ETransactionVersion2.F2 = "0x100000000000000000000000000000002"
            }(ETransactionVersion2 || (exports.ETransactionVersion2 = ETransactionVersion2 = {})),
            function(ETransactionVersion3) {
                ETransactionVersion3.V3 = "0x3",
                ETransactionVersion3.F3 = "0x100000000000000000000000000000003"
            }(ETransactionVersion3 || (exports.ETransactionVersion3 = ETransactionVersion3 = {}))
        }
        ,
        19765: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                void 0 === k2 && (k2 = k);
                var desc = Object.getOwnPropertyDescriptor(m, k);
                desc && !("get"in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
                    enumerable: !0,
                    get: function() {
                        return m[k]
                    }
                }),
                Object.defineProperty(o, k2, desc)
            }
            : function(o, m, k, k2) {
                void 0 === k2 && (k2 = k),
                o[k2] = m[k]
            }
            )
              , __exportStar = this && this.__exportStar || function(m, exports) {
                for (var p in m)
                    "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p)
            }
            ;
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.WALLET_API = exports.API = void 0,
            __exportStar(__webpack_require__(99284), exports),
            exports.API = __webpack_require__(99284),
            __exportStar(__webpack_require__(36218), exports),
            exports.WALLET_API = __webpack_require__(36218)
        },
        49411: (__unused_webpack_module,exports)=>{
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            })
        }
        ,
        45731: (__unused_webpack_module,exports)=>{
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            })
        }
        ,
        23146: (__unused_webpack_module,exports)=>{
            "use strict";
            var Permission;
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.Permission = void 0,
            function(Permission) {
                Permission.Accounts = "accounts"
            }(Permission || (exports.Permission = Permission = {}))
        }
        ,
        70406: (__unused_webpack_module,exports)=>{
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            })
        }
        ,
        27384: (__unused_webpack_module,exports)=>{
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            })
        }
        ,
        36218: function(__unused_webpack_module, exports, __webpack_require__) {
            "use strict";
            var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                void 0 === k2 && (k2 = k);
                var desc = Object.getOwnPropertyDescriptor(m, k);
                desc && !("get"in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
                    enumerable: !0,
                    get: function() {
                        return m[k]
                    }
                }),
                Object.defineProperty(o, k2, desc)
            }
            : function(o, m, k, k2) {
                void 0 === k2 && (k2 = k),
                o[k2] = m[k]
            }
            )
              , __exportStar = this && this.__exportStar || function(m, exports) {
                for (var p in m)
                    "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p)
            }
            ;
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            __exportStar(__webpack_require__(23146), exports),
            __exportStar(__webpack_require__(89117), exports),
            __exportStar(__webpack_require__(49411), exports),
            __exportStar(__webpack_require__(45731), exports),
            __exportStar(__webpack_require__(68884), exports),
            __exportStar(__webpack_require__(27384), exports),
            __exportStar(__webpack_require__(70406), exports)
        },
        68884: (__unused_webpack_module,exports)=>{
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            })
        }
        ,
        89117: (__unused_webpack_module,exports)=>{
            "use strict";
            var TypedDataRevision;
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }),
            exports.TypedDataRevision = void 0,
            function(TypedDataRevision) {
                TypedDataRevision.Active = "1",
                TypedDataRevision.Legacy = "0"
            }(TypedDataRevision || (exports.TypedDataRevision = TypedDataRevision = {}))
        }
        ,
        13631: (__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{
            "use strict";
            function fixStack(target, fn) {
                void 0 === fn && (fn = target.constructor);
                var captureStackTrace = Error.captureStackTrace;
                captureStackTrace && captureStackTrace(target, fn)
            }
            __webpack_require__.r(__webpack_exports__),
            __webpack_require__.d(__webpack_exports__, {
                CustomError: ()=>CustomError,
                customErrorFactory: ()=>customErrorFactory
            });
            var _extendStatics, __extends = (_extendStatics = function(d, b) {
                return _extendStatics = Object.setPrototypeOf || {
                    __proto__: []
                }instanceof Array && function(d, b) {
                    d.__proto__ = b
                }
                || function(d, b) {
                    for (var p in b)
                        Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p])
                }
                ,
                _extendStatics(d, b)
            }
            ,
            function(d, b) {
                if ("function" != typeof b && null !== b)
                    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                function __() {
                    this.constructor = d
                }
                _extendStatics(d, b),
                d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype,
                new __)
            }
            ), CustomError = function(_super) {
                function CustomError(message, options) {
                    var target, prototype, setPrototypeOf, _newTarget = this.constructor, _this = _super.call(this, message, options) || this;
                    return Object.defineProperty(_this, "name", {
                        value: _newTarget.name,
                        enumerable: !1,
                        configurable: !0
                    }),
                    target = _this,
                    prototype = _newTarget.prototype,
                    (setPrototypeOf = Object.setPrototypeOf) ? setPrototypeOf(target, prototype) : target.__proto__ = prototype,
                    fixStack(_this),
                    _this
                }
                return __extends(CustomError, _super),
                CustomError
            }(Error), __spreadArray = function(to, from, pack) {
                if (pack || 2 === arguments.length)
                    for (var ar, i = 0, l = from.length; i < l; i++)
                        !ar && i in from || (ar || (ar = Array.prototype.slice.call(from, 0, i)),
                        ar[i] = from[i]);
                return to.concat(ar || Array.prototype.slice.call(from))
            };
            function customErrorFactory(fn, parent) {
                function CustomError() {
                    for (var args = [], _i = 0; _i < arguments.length; _i++)
                        args[_i] = arguments[_i];
                    if (!(this instanceof CustomError))
                        return new (CustomError.bind.apply(CustomError, __spreadArray([void 0], args, !1)));
                    parent.apply(this, args),
                    Object.defineProperty(this, "name", {
                        value: fn.name || parent.name,
                        enumerable: !1,
                        configurable: !0
                    }),
                    fn.apply(this, args),
                    fixStack(this, CustomError)
                }
                return void 0 === parent && (parent = Error),
                Object.defineProperties(CustomError, {
                    prototype: {
                        value: Object.create(parent.prototype, {
                            constructor: {
                                value: CustomError,
                                writable: !0,
                                configurable: !0
                            }
                        })
                    }
                })
            }
        }
        ,
        18597: module=>{
            "use strict";
            module.exports = {
                i8: "6.5.4"
            }
        }
    }, __webpack_module_cache__ = {};
    function __webpack_require__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (void 0 !== cachedModule) {
            if (void 0 !== cachedModule.error)
                throw cachedModule.error;
            return cachedModule.exports
        }
        var module = __webpack_module_cache__[moduleId] = {
            id: moduleId,
            loaded: !1,
            exports: {}
        };
        try {
            var execOptions = {
                id: moduleId,
                module,
                factory: __webpack_modules__[moduleId],
                require: __webpack_require__
            };
            __webpack_require__.i.forEach((function(handler) {
                handler(execOptions)
            }
            )),
            module = execOptions.module,
            execOptions.factory.call(module.exports, module, module.exports, execOptions.require)
        } catch (e) {
            throw module.error = e,
            e
        }
        return module.loaded = !0,
        module.exports
    }
    __webpack_require__.m = __webpack_modules__,
    __webpack_require__.c = __webpack_module_cache__,
    __webpack_require__.i = [],
    __webpack_require__.d = (exports,definition)=>{
        for (var key in definition)
            __webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key) && Object.defineProperty(exports, key, {
                enumerable: !0,
                get: definition[key]
            })
    }
    ,
    __webpack_require__.hu = chunkId=>chunkId + "." + __webpack_require__.h() + ".hot-update.js",
    __webpack_require__.hmrF = ()=>"inpage." + __webpack_require__.h() + ".hot-update.json",
    __webpack_require__.h = ()=>"e92f488737ebfc3f4ed5",
    __webpack_require__.g = function() {
        if ("object" == typeof globalThis)
            return globalThis;
        try {
            return this || new Function("return this")()
        } catch (e) {
            if ("object" == typeof window)
                return window
        }
    }(),
    __webpack_require__.o = (obj,prop)=>Object.prototype.hasOwnProperty.call(obj, prop),
    inProgress = {},
    __webpack_require__.l = (url,done,key,chunkId)=>{
        if (inProgress[url])
            inProgress[url].push(done);
        else {
            var script, needAttach;
            if (void 0 !== key)
                for (var scripts = document.getElementsByTagName("script"), i = 0; i < scripts.length; i++) {
                    var s = scripts[i];
                    if (s.getAttribute("src") == url || s.getAttribute("data-webpack") == "wallet_app:" + key) {
                        script = s;
                        break
                    }
                }
            script || (needAttach = !0,
            (script = document.createElement("script")).charset = "utf-8",
            script.timeout = 120,
            __webpack_require__.nc && script.setAttribute("nonce", __webpack_require__.nc),
            script.setAttribute("data-webpack", "wallet_app:" + key),
            script.src = url),
            inProgress[url] = [done];
            var onScriptComplete = (prev,event)=>{
                script.onerror = script.onload = null,
                clearTimeout(timeout);
                var doneFns = inProgress[url];
                if (delete inProgress[url],
                script.parentNode && script.parentNode.removeChild(script),
                doneFns && doneFns.forEach((fn=>fn(event))),
                prev)
                    return prev(event)
            }
              , timeout = setTimeout(onScriptComplete.bind(null, void 0, {
                type: "timeout",
                target: script
            }), 12e4);
            script.onerror = onScriptComplete.bind(null, script.onerror),
            script.onload = onScriptComplete.bind(null, script.onload),
            needAttach && document.head.appendChild(script)
        }
    }
    ,
    __webpack_require__.r = exports=>{
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, {
            value: "Module"
        }),
        Object.defineProperty(exports, "__esModule", {
            value: !0
        })
    }
    ,
    __webpack_require__.nmd = module=>(module.paths = [],
    module.children || (module.children = []),
    module),
    (()=>{
        var currentChildModule, currentUpdateApplyHandlers, queuedInvalidatedModules, currentModuleData = {}, installedModules = __webpack_require__.c, currentParents = [], registeredStatusHandlers = [], currentStatus = "idle", blockingPromises = 0, blockingPromisesWaiting = [];
        function setStatus(newStatus) {
            currentStatus = newStatus;
            for (var results = [], i = 0; i < registeredStatusHandlers.length; i++)
                results[i] = registeredStatusHandlers[i].call(null, newStatus);
            return Promise.all(results)
        }
        function unblock() {
            0 == --blockingPromises && setStatus("ready").then((function() {
                if (0 === blockingPromises) {
                    var list = blockingPromisesWaiting;
                    blockingPromisesWaiting = [];
                    for (var i = 0; i < list.length; i++)
                        list[i]()
                }
            }
            ))
        }
        function hotCheck(applyOnUpdate) {
            if ("idle" !== currentStatus)
                throw new Error("check() is only allowed in idle status");
            return setStatus("check").then(__webpack_require__.hmrM).then((function(update) {
                return update ? setStatus("prepare").then((function() {
                    var updatedModules = [];
                    return currentUpdateApplyHandlers = [],
                    Promise.all(Object.keys(__webpack_require__.hmrC).reduce((function(promises, key) {
                        return __webpack_require__.hmrC[key](update.c, update.r, update.m, promises, currentUpdateApplyHandlers, updatedModules),
                        promises
                    }
                    ), [])).then((function() {
                        return fn = function() {
                            return applyOnUpdate ? internalApply(applyOnUpdate) : setStatus("ready").then((function() {
                                return updatedModules
                            }
                            ))
                        }
                        ,
                        0 === blockingPromises ? fn() : new Promise((function(resolve) {
                            blockingPromisesWaiting.push((function() {
                                resolve(fn())
                            }
                            ))
                        }
                        ));
                        var fn
                    }
                    ))
                }
                )) : setStatus(applyInvalidatedModules() ? "ready" : "idle").then((function() {
                    return null
                }
                ))
            }
            ))
        }
        function hotApply(options) {
            return "ready" !== currentStatus ? Promise.resolve().then((function() {
                throw new Error("apply() is only allowed in ready status (state: " + currentStatus + ")")
            }
            )) : internalApply(options)
        }
        function internalApply(options) {
            options = options || {},
            applyInvalidatedModules();
            var results = currentUpdateApplyHandlers.map((function(handler) {
                return handler(options)
            }
            ));
            currentUpdateApplyHandlers = void 0;
            var errors = results.map((function(r) {
                return r.error
            }
            )).filter(Boolean);
            if (errors.length > 0)
                return setStatus("abort").then((function() {
                    throw errors[0]
                }
                ));
            var disposePromise = setStatus("dispose");
            results.forEach((function(result) {
                result.dispose && result.dispose()
            }
            ));
            var error, applyPromise = setStatus("apply"), reportError = function(err) {
                error || (error = err)
            }, outdatedModules = [];
            return results.forEach((function(result) {
                if (result.apply) {
                    var modules = result.apply(reportError);
                    if (modules)
                        for (var i = 0; i < modules.length; i++)
                            outdatedModules.push(modules[i])
                }
            }
            )),
            Promise.all([disposePromise, applyPromise]).then((function() {
                return error ? setStatus("fail").then((function() {
                    throw error
                }
                )) : queuedInvalidatedModules ? internalApply(options).then((function(list) {
                    return outdatedModules.forEach((function(moduleId) {
                        list.indexOf(moduleId) < 0 && list.push(moduleId)
                    }
                    )),
                    list
                }
                )) : setStatus("idle").then((function() {
                    return outdatedModules
                }
                ))
            }
            ))
        }
        function applyInvalidatedModules() {
            if (queuedInvalidatedModules)
                return currentUpdateApplyHandlers || (currentUpdateApplyHandlers = []),
                Object.keys(__webpack_require__.hmrI).forEach((function(key) {
                    queuedInvalidatedModules.forEach((function(moduleId) {
                        __webpack_require__.hmrI[key](moduleId, currentUpdateApplyHandlers)
                    }
                    ))
                }
                )),
                queuedInvalidatedModules = void 0,
                !0
        }
        __webpack_require__.hmrD = currentModuleData,
        __webpack_require__.i.push((function(options) {
            var moduleId, me, _main, hot, module = options.module, require = function(require, moduleId) {
                var me = installedModules[moduleId];
                if (!me)
                    return require;
                var fn = function(request) {
                    if (me.hot.active) {
                        if (installedModules[request]) {
                            var parents = installedModules[request].parents;
                            -1 === parents.indexOf(moduleId) && parents.push(moduleId)
                        } else
                            currentParents = [moduleId],
                            currentChildModule = request;
                        -1 === me.children.indexOf(request) && me.children.push(request)
                    } else
                        currentParents = [];
                    return require(request)
                }
                  , createPropertyDescriptor = function(name) {
                    return {
                        configurable: !0,
                        enumerable: !0,
                        get: function() {
                            return require[name]
                        },
                        set: function(value) {
                            require[name] = value
                        }
                    }
                };
                for (var name in require)
                    Object.prototype.hasOwnProperty.call(require, name) && "e" !== name && Object.defineProperty(fn, name, createPropertyDescriptor(name));
                return fn.e = function(chunkId) {
                    return function(promise) {
                        switch (currentStatus) {
                        case "ready":
                            setStatus("prepare");
                        case "prepare":
                            return blockingPromises++,
                            promise.then(unblock, unblock),
                            promise;
                        default:
                            return promise
                        }
                    }(require.e(chunkId))
                }
                ,
                fn
            }(options.require, options.id);
            module.hot = (moduleId = options.id,
            me = module,
            hot = {
                _acceptedDependencies: {},
                _acceptedErrorHandlers: {},
                _declinedDependencies: {},
                _selfAccepted: !1,
                _selfDeclined: !1,
                _selfInvalidated: !1,
                _disposeHandlers: [],
                _main: _main = currentChildModule !== moduleId,
                _requireSelf: function() {
                    currentParents = me.parents.slice(),
                    currentChildModule = _main ? void 0 : moduleId,
                    __webpack_require__(moduleId)
                },
                active: !0,
                accept: function(dep, callback, errorHandler) {
                    if (void 0 === dep)
                        hot._selfAccepted = !0;
                    else if ("function" == typeof dep)
                        hot._selfAccepted = dep;
                    else if ("object" == typeof dep && null !== dep)
                        for (var i = 0; i < dep.length; i++)
                            hot._acceptedDependencies[dep[i]] = callback || function() {}
                            ,
                            hot._acceptedErrorHandlers[dep[i]] = errorHandler;
                    else
                        hot._acceptedDependencies[dep] = callback || function() {}
                        ,
                        hot._acceptedErrorHandlers[dep] = errorHandler
                },
                decline: function(dep) {
                    if (void 0 === dep)
                        hot._selfDeclined = !0;
                    else if ("object" == typeof dep && null !== dep)
                        for (var i = 0; i < dep.length; i++)
                            hot._declinedDependencies[dep[i]] = !0;
                    else
                        hot._declinedDependencies[dep] = !0
                },
                dispose: function(callback) {
                    hot._disposeHandlers.push(callback)
                },
                addDisposeHandler: function(callback) {
                    hot._disposeHandlers.push(callback)
                },
                removeDisposeHandler: function(callback) {
                    var idx = hot._disposeHandlers.indexOf(callback);
                    idx >= 0 && hot._disposeHandlers.splice(idx, 1)
                },
                invalidate: function() {
                    switch (this._selfInvalidated = !0,
                    currentStatus) {
                    case "idle":
                        currentUpdateApplyHandlers = [],
                        Object.keys(__webpack_require__.hmrI).forEach((function(key) {
                            __webpack_require__.hmrI[key](moduleId, currentUpdateApplyHandlers)
                        }
                        )),
                        setStatus("ready");
                        break;
                    case "ready":
                        Object.keys(__webpack_require__.hmrI).forEach((function(key) {
                            __webpack_require__.hmrI[key](moduleId, currentUpdateApplyHandlers)
                        }
                        ));
                        break;
                    case "prepare":
                    case "check":
                    case "dispose":
                    case "apply":
                        (queuedInvalidatedModules = queuedInvalidatedModules || []).push(moduleId)
                    }
                },
                check: hotCheck,
                apply: hotApply,
                status: function(l) {
                    if (!l)
                        return currentStatus;
                    registeredStatusHandlers.push(l)
                },
                addStatusHandler: function(l) {
                    registeredStatusHandlers.push(l)
                },
                removeStatusHandler: function(l) {
                    var idx = registeredStatusHandlers.indexOf(l);
                    idx >= 0 && registeredStatusHandlers.splice(idx, 1)
                },
                data: currentModuleData[moduleId]
            },
            currentChildModule = void 0,
            hot),
            module.parents = currentParents,
            module.children = [],
            currentParents = [],
            options.require = require
        }
        )),
        __webpack_require__.hmrC = {},
        __webpack_require__.hmrI = {}
    }
    )(),
    __webpack_require__.p = "/",
    (()=>{
        var currentUpdatedModulesList, currentUpdateChunks, currentUpdate, currentUpdateRemovedChunks, currentUpdateRuntime, installedChunks = __webpack_require__.hmrS_jsonp = __webpack_require__.hmrS_jsonp || {
            557: 0
        }, waitingUpdateResolves = {};
        function loadUpdateChunk(chunkId, updatedModulesList) {
            return currentUpdatedModulesList = updatedModulesList,
            new Promise(((resolve,reject)=>{
                waitingUpdateResolves[chunkId] = resolve;
                var url = __webpack_require__.p + __webpack_require__.hu(chunkId)
                  , error = new Error;
                __webpack_require__.l(url, (event=>{
                    if (waitingUpdateResolves[chunkId]) {
                        waitingUpdateResolves[chunkId] = void 0;
                        var errorType = event && ("load" === event.type ? "missing" : event.type)
                          , realSrc = event && event.target && event.target.src;
                        error.message = "Loading hot update chunk " + chunkId + " failed.\n(" + errorType + ": " + realSrc + ")",
                        error.name = "ChunkLoadError",
                        error.type = errorType,
                        error.request = realSrc,
                        reject(error)
                    }
                }
                ))
            }
            ))
        }
        function applyHandler(options) {
            function getAffectedModuleEffects(updateModuleId) {
                for (var outdatedModules = [updateModuleId], outdatedDependencies = {}, queue = outdatedModules.map((function(id) {
                    return {
                        chain: [id],
                        id
                    }
                }
                )); queue.length > 0; ) {
                    var queueItem = queue.pop()
                      , moduleId = queueItem.id
                      , chain = queueItem.chain
                      , module = __webpack_require__.c[moduleId];
                    if (module && (!module.hot._selfAccepted || module.hot._selfInvalidated)) {
                        if (module.hot._selfDeclined)
                            return {
                                type: "self-declined",
                                chain,
                                moduleId
                            };
                        if (module.hot._main)
                            return {
                                type: "unaccepted",
                                chain,
                                moduleId
                            };
                        for (var i = 0; i < module.parents.length; i++) {
                            var parentId = module.parents[i]
                              , parent = __webpack_require__.c[parentId];
                            if (parent) {
                                if (parent.hot._declinedDependencies[moduleId])
                                    return {
                                        type: "declined",
                                        chain: chain.concat([parentId]),
                                        moduleId,
                                        parentId
                                    };
                                -1 === outdatedModules.indexOf(parentId) && (parent.hot._acceptedDependencies[moduleId] ? (outdatedDependencies[parentId] || (outdatedDependencies[parentId] = []),
                                addAllToSet(outdatedDependencies[parentId], [moduleId])) : (delete outdatedDependencies[parentId],
                                outdatedModules.push(parentId),
                                queue.push({
                                    chain: chain.concat([parentId]),
                                    id: parentId
                                })))
                            }
                        }
                    }
                }
                return {
                    type: "accepted",
                    moduleId: updateModuleId,
                    outdatedModules,
                    outdatedDependencies
                }
            }
            function addAllToSet(a, b) {
                for (var i = 0; i < b.length; i++) {
                    var item = b[i];
                    -1 === a.indexOf(item) && a.push(item)
                }
            }
            __webpack_require__.f && delete __webpack_require__.f.jsonpHmr,
            currentUpdateChunks = void 0;
            var outdatedDependencies = {}
              , outdatedModules = []
              , appliedUpdate = {}
              , warnUnexpectedRequire = function(module) {};
            for (var moduleId in currentUpdate)
                if (__webpack_require__.o(currentUpdate, moduleId)) {
                    var result, newModuleFactory = currentUpdate[moduleId], abortError = !1, doApply = !1, doDispose = !1, chainInfo = "";
                    switch ((result = newModuleFactory ? getAffectedModuleEffects(moduleId) : {
                        type: "disposed",
                        moduleId
                    }).chain && (chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ")),
                    result.type) {
                    case "self-declined":
                        options.onDeclined && options.onDeclined(result),
                        options.ignoreDeclined || (abortError = new Error("Aborted because of self decline: " + result.moduleId + chainInfo));
                        break;
                    case "declined":
                        options.onDeclined && options.onDeclined(result),
                        options.ignoreDeclined || (abortError = new Error("Aborted because of declined dependency: " + result.moduleId + " in " + result.parentId + chainInfo));
                        break;
                    case "unaccepted":
                        options.onUnaccepted && options.onUnaccepted(result),
                        options.ignoreUnaccepted || (abortError = new Error("Aborted because " + moduleId + " is not accepted" + chainInfo));
                        break;
                    case "accepted":
                        options.onAccepted && options.onAccepted(result),
                        doApply = !0;
                        break;
                    case "disposed":
                        options.onDisposed && options.onDisposed(result),
                        doDispose = !0;
                        break;
                    default:
                        throw new Error("Unexception type " + result.type)
                    }
                    if (abortError)
                        return {
                            error: abortError
                        };
                    if (doApply)
                        for (moduleId in appliedUpdate[moduleId] = newModuleFactory,
                        addAllToSet(outdatedModules, result.outdatedModules),
                        result.outdatedDependencies)
                            __webpack_require__.o(result.outdatedDependencies, moduleId) && (outdatedDependencies[moduleId] || (outdatedDependencies[moduleId] = []),
                            addAllToSet(outdatedDependencies[moduleId], result.outdatedDependencies[moduleId]));
                    doDispose && (addAllToSet(outdatedModules, [result.moduleId]),
                    appliedUpdate[moduleId] = warnUnexpectedRequire)
                }
            currentUpdate = void 0;
            for (var moduleOutdatedDependencies, outdatedSelfAcceptedModules = [], j = 0; j < outdatedModules.length; j++) {
                var outdatedModuleId = outdatedModules[j]
                  , module = __webpack_require__.c[outdatedModuleId];
                module && (module.hot._selfAccepted || module.hot._main) && appliedUpdate[outdatedModuleId] !== warnUnexpectedRequire && !module.hot._selfInvalidated && outdatedSelfAcceptedModules.push({
                    module: outdatedModuleId,
                    require: module.hot._requireSelf,
                    errorHandler: module.hot._selfAccepted
                })
            }
            return {
                dispose: function() {
                    var idx;
                    currentUpdateRemovedChunks.forEach((function(chunkId) {
                        delete installedChunks[chunkId]
                    }
                    )),
                    currentUpdateRemovedChunks = void 0;
                    for (var dependency, queue = outdatedModules.slice(); queue.length > 0; ) {
                        var moduleId = queue.pop()
                          , module = __webpack_require__.c[moduleId];
                        if (module) {
                            var data = {}
                              , disposeHandlers = module.hot._disposeHandlers;
                            for (j = 0; j < disposeHandlers.length; j++)
                                disposeHandlers[j].call(null, data);
                            for (__webpack_require__.hmrD[moduleId] = data,
                            module.hot.active = !1,
                            delete __webpack_require__.c[moduleId],
                            delete outdatedDependencies[moduleId],
                            j = 0; j < module.children.length; j++) {
                                var child = __webpack_require__.c[module.children[j]];
                                child && ((idx = child.parents.indexOf(moduleId)) >= 0 && child.parents.splice(idx, 1))
                            }
                        }
                    }
                    for (var outdatedModuleId in outdatedDependencies)
                        if (__webpack_require__.o(outdatedDependencies, outdatedModuleId) && (module = __webpack_require__.c[outdatedModuleId]))
                            for (moduleOutdatedDependencies = outdatedDependencies[outdatedModuleId],
                            j = 0; j < moduleOutdatedDependencies.length; j++)
                                dependency = moduleOutdatedDependencies[j],
                                (idx = module.children.indexOf(dependency)) >= 0 && module.children.splice(idx, 1)
                },
                apply: function(reportError) {
                    for (var updateModuleId in appliedUpdate)
                        __webpack_require__.o(appliedUpdate, updateModuleId) && (__webpack_require__.m[updateModuleId] = appliedUpdate[updateModuleId]);
                    for (var i = 0; i < currentUpdateRuntime.length; i++)
                        currentUpdateRuntime[i](__webpack_require__);
                    for (var outdatedModuleId in outdatedDependencies)
                        if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
                            var module = __webpack_require__.c[outdatedModuleId];
                            if (module) {
                                moduleOutdatedDependencies = outdatedDependencies[outdatedModuleId];
                                for (var callbacks = [], errorHandlers = [], dependenciesForCallbacks = [], j = 0; j < moduleOutdatedDependencies.length; j++) {
                                    var dependency = moduleOutdatedDependencies[j]
                                      , acceptCallback = module.hot._acceptedDependencies[dependency]
                                      , errorHandler = module.hot._acceptedErrorHandlers[dependency];
                                    if (acceptCallback) {
                                        if (-1 !== callbacks.indexOf(acceptCallback))
                                            continue;
                                        callbacks.push(acceptCallback),
                                        errorHandlers.push(errorHandler),
                                        dependenciesForCallbacks.push(dependency)
                                    }
                                }
                                for (var k = 0; k < callbacks.length; k++)
                                    try {
                                        callbacks[k].call(null, moduleOutdatedDependencies)
                                    } catch (err) {
                                        if ("function" == typeof errorHandlers[k])
                                            try {
                                                errorHandlers[k](err, {
                                                    moduleId: outdatedModuleId,
                                                    dependencyId: dependenciesForCallbacks[k]
                                                })
                                            } catch (err2) {
                                                options.onErrored && options.onErrored({
                                                    type: "accept-error-handler-errored",
                                                    moduleId: outdatedModuleId,
                                                    dependencyId: dependenciesForCallbacks[k],
                                                    error: err2,
                                                    originalError: err
                                                }),
                                                options.ignoreErrored || (reportError(err2),
                                                reportError(err))
                                            }
                                        else
                                            options.onErrored && options.onErrored({
                                                type: "accept-errored",
                                                moduleId: outdatedModuleId,
                                                dependencyId: dependenciesForCallbacks[k],
                                                error: err
                                            }),
                                            options.ignoreErrored || reportError(err)
                                    }
                            }
                        }
                    for (var o = 0; o < outdatedSelfAcceptedModules.length; o++) {
                        var item = outdatedSelfAcceptedModules[o]
                          , moduleId = item.module;
                        try {
                            item.require(moduleId)
                        } catch (err) {
                            if ("function" == typeof item.errorHandler)
                                try {
                                    item.errorHandler(err, {
                                        moduleId,
                                        module: __webpack_require__.c[moduleId]
                                    })
                                } catch (err2) {
                                    options.onErrored && options.onErrored({
                                        type: "self-accept-error-handler-errored",
                                        moduleId,
                                        error: err2,
                                        originalError: err
                                    }),
                                    options.ignoreErrored || (reportError(err2),
                                    reportError(err))
                                }
                            else
                                options.onErrored && options.onErrored({
                                    type: "self-accept-errored",
                                    moduleId,
                                    error: err
                                }),
                                options.ignoreErrored || reportError(err)
                        }
                    }
                    return outdatedModules
                }
            }
        }
        globalThis.webpackHotUpdatewallet_app = (chunkId,moreModules,runtime)=>{
            for (var moduleId in moreModules)
                __webpack_require__.o(moreModules, moduleId) && (currentUpdate[moduleId] = moreModules[moduleId],
                currentUpdatedModulesList && currentUpdatedModulesList.push(moduleId));
            runtime && currentUpdateRuntime.push(runtime),
            waitingUpdateResolves[chunkId] && (waitingUpdateResolves[chunkId](),
            waitingUpdateResolves[chunkId] = void 0)
        }
        ,
        __webpack_require__.hmrI.jsonp = function(moduleId, applyHandlers) {
            currentUpdate || (currentUpdate = {},
            currentUpdateRuntime = [],
            currentUpdateRemovedChunks = [],
            applyHandlers.push(applyHandler)),
            __webpack_require__.o(currentUpdate, moduleId) || (currentUpdate[moduleId] = __webpack_require__.m[moduleId])
        }
        ,
        __webpack_require__.hmrC.jsonp = function(chunkIds, removedChunks, removedModules, promises, applyHandlers, updatedModulesList) {
            applyHandlers.push(applyHandler),
            currentUpdateChunks = {},
            currentUpdateRemovedChunks = removedChunks,
            currentUpdate = removedModules.reduce((function(obj, key) {
                return obj[key] = !1,
                obj
            }
            ), {}),
            currentUpdateRuntime = [],
            chunkIds.forEach((function(chunkId) {
                __webpack_require__.o(installedChunks, chunkId) && void 0 !== installedChunks[chunkId] ? (promises.push(loadUpdateChunk(chunkId, updatedModulesList)),
                currentUpdateChunks[chunkId] = !0) : currentUpdateChunks[chunkId] = !1
            }
            )),
            __webpack_require__.f && (__webpack_require__.f.jsonpHmr = function(chunkId, promises) {
                currentUpdateChunks && __webpack_require__.o(currentUpdateChunks, chunkId) && !currentUpdateChunks[chunkId] && (promises.push(loadUpdateChunk(chunkId)),
                currentUpdateChunks[chunkId] = !0)
            }
            )
        }
        ,
        __webpack_require__.hmrM = ()=>{
            if ("undefined" == typeof fetch)
                throw new Error("No browser support: need fetch API");
            return fetch(__webpack_require__.p + __webpack_require__.hmrF()).then((response=>{
                if (404 !== response.status) {
                    if (!response.ok)
                        throw new Error("Failed to fetch update manifest " + response.statusText);
                    return response.json()
                }
            }
            ))
        }
    }
    )();
    __webpack_require__(34565)
}
)();
//# sourceMappingURL=inpage.js.map
